---
title: 读书笔记|如何更好的创建和销毁对象
date: 2019-04-14 14:55:37
tags: Notes
categories: 读书笔记(Effective Java) 
---

### 静态工厂方法代替构造器

#### 静态工厂方法的几大优势
1. 静态工厂方法有名称，易于区分。

2. 避免不必要的重复对象的创建工作

不必每次调用都创建一个新的对象，可以将构建好的实例缓存起来重复使用

3. 可以返回原返回类型的任何子类型

返回对象有了更大的灵活性

4. 返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值

5. 方法返回对象所属的类，在编写包含静态工厂方法的类时可以不存在


#### 静态工厂方法的几个缺点
+ 类如果不含公有的或者受保护的构造器，就不能被子类化
+ 不易发现

### 遇到多个参数时要使用构建器

#### 当构造器扩展到大量的可选参数时，静态工厂和构造器就显得相当局限了。目前用的比较多的是重叠构造器

```java
NutritionFacts cocaCola = new NutritionFacts(240,8,100,0,35,27);
```

##### 缺点
+ 可读性比较差
+ 容易出错,如参数位置弄错位置

#### 使用setter方案
```java
public class NutritionFacts {
    private int servingSize = -1;
    private int servings = -1;
    private int calories = 0;
    private int fat = 0;
    private int sodium = 0;
    private int carbohydrate = 0;

    public NutritionFacts() {
    }

    public void setServingSize(int servingSize) {
        this.servingSize = servingSize;
    }

    public void setServings(int servings) {
        this.servings = servings;
    }

    public void setCalories(int calories) {
        this.calories = calories;
    }

    public void setFat(int fat) {
        this.fat = fat;
    }

    public void setSodium(int sodium) {
        this.sodium = sodium;
    }

    public void setCarbohydrate(int carbohydrate) {
        this.carbohydrate = carbohydrate;
    }
}

NutritionFacts nutritionFacts = new NutritionFacts();
nutritionFacts.setServingSize(240);
nutritionFacts.setServings(100);
nutritionFacts.setSodium(35);
nutritionFacts.setCarbohydrate(27);
nutritionFacts.setCalories(8);
```

+ 可读性增强
+ 一致性的问题(不安全)

#### 构建器


```java
public class NutritionFacts {
    private int servingSize = -1;
    private int servings = -1;
    private int calories = 0;
    private int fat = 0;
    private int sodium = 0;
    private int carbohydrate = 0;
    
    private NutritionFacts(Builder builder){
        this.servingSize = builder.servingSize;
        this.servings = builder.servings;
        this.calories = builder.calories;
        this.fat = builder.fat;
        this.sodium = builder.sodium;
        this.carbohydrate = builder.carbohydrate;
    }

    public static class Builder{
        private final int servingSize;
        private final int servings;

        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;
        private int carbohydrate = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }
        
        public NutritionFacts build(){
            return new NutritionFacts(this);
        }

        public Builder calories(int val){
            this.calories = val;
            return this;
        }

        public Builder fat(int val){
            this.fat = val;
            return this;
        }

        public Builder sodium(int val){
            this.sodium = val;
            return this;
        }

        public Builder carbohydrate(int val){
            this.carbohydrate = val;
            return this;
        }
    }

    public static void main(String[] args) {
        NutritionFacts nutritionFacts = new NutritionFacts.Builder(240,8).calories(100)
                .sodium(35).carbohydrate(27).build();
    }
}
```

+ 直观、易于阅读(优点)
+ 在注重性能的情况下，创建构建起是个问题(缺点)
+ 最好一开始就用构建器(建议)

#### 小结
如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式是个不错的选择

### 私有构造器或者枚举类型强化Singleton属性

Singleton:仅仅被实例化一次的类

#### Singleton的两种实现
##### 单例模式的实现（一）
```java
public class Elvis {
    public static final Elvis instance = new Elvis();
    
    private Elvis(){}
    
    public void doSomething(){
        System.out.println("do something");
    }
}
```
特点
+ 私有构造器只调用一次，用来实例化公有的静态final域(instance)
+ 没有public或者protect的构造器，保证了instance的唯一性
+ 但是可以通过反射的方式调用私有构造器(可以修改构造器在创建第二次实例时抛出异常)

##### 单例模式的实现（二）
```java
public class Elvis {
    public static final Elvis instance = new Elvis();

    private Elvis(){}
    
    public static Elvis getInstance(){
        return instance;
    }

    public void doSomething(){
        System.out.println("do something");
    }
}
```
特点
+ 添加了一个静态工厂方法，静态工厂方法的调用每次都返回同一个对象引用
+ 公有的静态域是final的，该域总是包含相同的对象引用。公有域方法在性能上不会有任何优势，现在JVM实现能够将静态工厂方法的调用内联化。(内联：函数被调用的地方直接展开，编译器在调用时不会像一般函数那样，参数压栈，返回时参数出栈以及释放资源，直接提高程序的执行速度)

###### Singleton可序列化问题
Singleton仅仅在声明中加上implement Serializable是不够的，必须所有的实例都是瞬时的，并提供一个readResolve方法，否则每次反序列化都会创建一个新的实例

#### 单例模式的实现（三）--- 通过枚举类型实现
```
public enum Elvis {
    INSTANCE;
    
    public void doSomething(){
        System.out.println("do something");
    } 
}
```
特点
+ 简洁
+ 无偿提供了序列化机制，防止多次实例化
+ 单元素的枚举类型是实现Singleton的最佳方法

### 使用依赖注入来引用资源

### 避免创建不必要的对象

### 消除过期的对象引用

### 避免使用终结方法

### try-with-resource优先于try-finally






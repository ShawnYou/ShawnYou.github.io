---
title: 代理模式|动态代理原理浅析
date: 2019-04-05 09:13:59
tags: Design
categories: 设计模式
---

> 为其他对象提供一个代理以控制对这个对象的访问，在不改变目标对象基础上添加额外的功能。

### 如何理解代理模式

+ 两个主体：代理对象和被代理对象
+ 对于被代理对象，事情必须要去做吗，但是自己不想去做或是没有条件去做，需要代理对象代替被代理对象去做。
+ 代理对象能够获取被代理对象的资料信息。 代理层面（获得被代理对象的引用）

#### 生活案例
+ 中介：通常买二手车的时候，会去网上找车源，对车进行质量检测，以及各种过户手续的办理，自己可能不想做这些事情，所以可以找第三方的中介公司来完成这些事情，我只负责把我想要的车辆的信息（价位、车辆新旧程度、品牌）反馈给中介，中介把所有的办好就只管我来签字验收就可以了。

+ 黄牛：当春运火车票比较紧张的时候，我抢不到票，且自己也不想去抢，则可以通过黄牛去买，我只管把我的车票信息给他（初始地、目的地、出发时间、车次），由此不用抢票，也可以买到相应的车票，抢票的过程由黄牛去做。

+ 媒人：平时自己没有时间去交女朋友，则需要媒人去介绍，我们只管把我们想要的女朋友的类型给媒人，媒人则帮我们去寻找合适的对象。

#### 需要类图
+ Subject(抽象主题)

可以是抽象类也可以是接口

+ RealSubject(具体角色)

被代理的对象，业务逻辑的执行者

+ Proxy(代理角色)

代理类，负责对真实角色的应用，把所有抽象主题定义的方法限制委托给真实角色实现，并在真实角色处理完毕前后做相应工作

### 几种代理实现形式
代理有两种主要形式
1. 静态代理

编译前，代码已经创建好，程序运行时，class文件已经存在
2. 动态代理

程序运行时通过反射生成代理类

#### 静态代理
+ 代理类与目标类实现相同的接口
+ 代理类持有目标类的引用，可以控制目标类方法的访问

##### 普通代理
```java
public interface Subject {

    void request();
}
```

```java
public class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("start to request");
    }
}
```
```java
public class Proxy implements Subject{
    private Subject subject;

    public Proxy(Subject subject){
        this.subject = subject;
    }

    @Override
    public void request() {
        this.before();
        subject.request();
        this.after();
    }

    private void before(){
        System.out.println("前置处理。。。。");
    }

    private void after(){
        System.out.println("后置处理。。。。");
    }
}
```
##### 强制代理
+ 只能通过真实角色角色制定的代理类才能访问
+ 不允许直接访问真实角色

```java
public interface Subject {
    void request();

    Subject getProxy();
}
```java
public class SubjectProxy implements Subject{
    private Subject subject;

    public SubjectProxy(Subject subject) {
        this.subject = subject;
    }

    @Override
    public void request() {
        this.subject.request();
    }

    @Override
    public Subject getProxy() {
        return this;
    }
}
```java
public class RealSubject implements Subject{
    private Subject proxy = null;
    @Override
    public void request() {
        if(this.isProxy()){
            System.out.println("start to request");
        }else {
            System.out.println("请使用指定的代理进行访问");
        }

    }

    @Override
    public Subject getProxy() {
        this.proxy = new SubjectProxy(this);
        return this.proxy;
    }

    private boolean isProxy(){
        if(this.proxy == null){
            return false;
        }else {
            return true;
        }
    }
}
```
```java
public class Client {
    public static void main(String[] args) {
        RealSubject subject = new RealSubject();
        Subject proxy = subject.getProxy();
        proxy.request();
    }
}
```

##### 静态代理局限性
+ 不够灵活，每个代理只为一个接口服务，会造成大量代码重复
+ 静态代理类职位特定的接口服务，如果有多个接口，需要生成多个代理对象，不利于系统维护

#### 动态代理
```java
public interface CustomerService {
    void buyCar();
}
```

```java
public class CustomerServiceImpl implements CustomerService{
    @Override
    public void buyCar() {
        System.out.println("决定买这个车了");
    }
}
```

```java
public class CarAgency implements InvocationHandler{
    //被代理对象的引用
    private Object target;

    public Object getInstance(Object target){
        this.target = target;
        Class clazz = target.getClass();
        return Proxy.newProxyInstance(clazz.getClassLoader(),target.getClass().getInterfaces(),this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("办理车辆质量检查报告");
        method.invoke(target,args);
        System.out.println("办理车辆二手车过户");
        return null;
    }
}
```



动态代理源码解析





1. 代理模式的意义（如何案例理解）
2. 三种代理方式
3. 动态代理实现原理
4. 动态代理的实际运用（RPC、Spring等 RMI  收集相关的应用）



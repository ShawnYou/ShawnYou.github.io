---
title: 迭代器模式|手写一个迭代器
date: 2019-10-22 23:25:15
tags: Design
categories: 设计模式
---

### 迭代器模式
我们在日常的开发中，特别是在使用集合的过程中都或多或少使用了迭代器来对集合进行遍历。这时候我们就会思考一个问题，明明简单的For循环就能解决的集合遍历问题，我们非得创造一个迭代器来进行集合的遍历，使用迭代器来遍历到底有什么不一样的地方吗？本着‘存在即合理’的原则，我们通过手写迭代器的方式来深入了解一下迭代器模式的实现和带来的编码好处。

#### 实现案例
有一个书架，我们想要知道这个书架里面堆了哪些书籍，这时候我们就需要对书架里面的书一本一本的遍历，直到没有书本，我们就能清楚的知道数据上堆满了哪些书籍。

+ 可以被遍历的标记(生成迭代器的接口)
首先提供一个接口，来标明这个类是可以被遍历的集合。实现这个接口的类可以生成对应的迭代器。
```java
public interface Aggregate{
    public abstract Iterator iterator();
}
```

+ 迭代器接口
迭代器的抽象接口，定义了两个方法
（1）是否还有下一个元素
（2）返回下一个元素
```java
public interface Iterator{
    public abstract boolean hasNext();
    public abstract Object next();
}
```
+ 集合存储的元素（书本）
```java
public class book{
    private String name;
}
```
+ 迭代器实现类
```java
public class BookShelfIterator{
    private BookShelf bookShelf;
    //指向当前遍历的位置
    private int index;
    ...
    public boolean hasNext(){
        //将当前的index与集合的大小做比较，小于集合大小，说明还有元素。
        if(index < bookShelf.length){
            return true;
        }else{
            return false;
        }
    }

    public Object next(){
        Book book = bookShelf.getBookAt(index);
        index++;
        return book;
    }
}
```

+ 书架类
书架类用于存放书本，可以用来遍历，因此需要实现Aggregate接口
```java
public class BookShelf implements Aggregate{
    ...
    public Iterator iterator(){
        //生成对应的迭代器
        return new BookShelfIterator();
    }
}
```

+ 测试方法
```java
Iterator it = bookShelf.iterator();
while(it.hasNext){
    Book book = (Book)it.next();
}
```
> 由此，我们就自定义实现了一个迭代器，可以满足集合遍历的基本需求

### 迭代器模式的几点思考

#### 为什么要使用迭代模式
遍历与实现分开，无论BookShelf是怎样的实现，只要能够获取到对应的迭代器，遍历方式都是不会变的，利于代码的扩展。

```java
Iterator it = bookShelf.iterator();
while(it.hasNext){
    Book book = (Book)it.next();
}
```

#### 多种迭代器
迭代器实现了遍历集合的方式，那么我们可以设计多种不一样的迭代器。
+ 从后向前遍历
+ 跳跃性遍历





<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>攻城虱</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shawnyou.tech/"/>
  <updated>2019-11-21T14:03:40.329Z</updated>
  <id>https://shawnyou.tech/</id>
  
  <author>
    <name>Shawn You</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01|一条SQL更新语句是如何执行的</title>
    <link href="https://shawnyou.tech/2019/11/21/mysql-notes/02%7C%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>https://shawnyou.tech/2019/11/21/mysql-notes/02|一条SQL更新语句是如何执行的/</id>
    <published>2019-11-21T14:47:29.000Z</published>
    <updated>2019-11-21T14:03:40.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="执行流程-和查询流程保持一致"><a href="#执行流程-和查询流程保持一致" class="headerlink" title="执行流程(和查询流程保持一致)"></a>执行流程(和查询流程保持一致)</h3><ul><li>连接器 –&gt; 连接数据库</li><li>分析器 –&gt; 词法和语法分析这是一条更新语句</li><li>优化器 –&gt; 决定使用哪个索引</li><li>执行器 –&gt; 找到具体的某一行，然后更新</li></ul><h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><blockquote><p>SQL更新过程中涉及两个重要的日志模块</p></blockquote><h4 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h4><ul><li>WHAT<br>redo log(重做日志)类似于掌柜账本记账的模式，先记账(先写日志)，后清账(再写磁盘)</li><li>WHY<br>mysql的每一次更新过程IO成本和查找成本很高。每一次更新操作都要在磁盘中找到对应的记录然后更新。当更新比较频繁的时候，性能就非常的不好。</li><li>HOW<br>当一条记录需要更新的时候：</li></ul><ol><li>InnoDB引擎先把记录写到redo log</li><li>更新内存</li><li>InnoDB引擎在系统空闲的时候，将操作记录更新到磁盘中</li></ol><p>PS：</p><ul><li>redo log是InnoDB特有的日志</li><li>如果更新特别频繁，redo log特别多，系统会放下工作，将一部分redo log的任务更新到磁盘中，为redo log腾出空间</li><li>redo log是固定大熊啊的，可以配置一组四个文件，每个文件1GB, 从头开始写，写到末尾然后继续回到开头写</li><li>InnoDB 可以依靠redo log保证数据库发生异常重启的时候，之前的记录不会丢失(crash-safe)</li></ul><h4 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog(归档日志)"></a>binlog(归档日志)</h4><p>bin log是server层实现的日志，可以应用于所有存储引擎</p><h4 id="redolog与binlog的区别"><a href="#redolog与binlog的区别" class="headerlink" title="redolog与binlog的区别"></a>redolog与binlog的区别</h4><ul><li>redolog是InnoDB独有, binlog是Server层实现的，所有引擎都可以使用</li><li>redolog是物理日志，记录某个数据页做了什么改动，binlog是逻辑日志，记录语句的原始逻辑</li><li>redolog是循环写，空间固定会用完，binlog可以最佳写入，并不会覆盖以前的日志。</li></ul><h3 id="update语句执行的内部流程"><a href="#update语句执行的内部流程" class="headerlink" title="update语句执行的内部流程"></a>update语句执行的内部流程</h3><ol><li>执行器通过引擎找到对应的记录。如果这一行所在数据页在内存中，引擎就从内存中取，否则就从磁盘读入。</li><li>执行器拿到对应的数据，进行更新，然后调用引擎接口写入数据</li><li>引擎将数据更新到内存，同时将更新操作记录到redo日志，此时redo log处于prepare状态，告知执行器执行完成。</li><li>执行器生成binlog,并将binlog写入磁盘</li><li>执行器调用引擎的提交事务接口，引擎将写入的redo log改成提交状态</li></ol><blockquote><p>以上的流程包含了一个两阶段提交</p></blockquote><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><ul><li>what<br>保证redolog与binlog的数据逻辑一致性。</li></ul><ol><li>先写redolog后写binlog<br>redolog写完，binlog还没写完的时候，MySQL异常重启,可以通过redolog将记录恢复。但是当我们需要通过binlog恢复临时库的时候，由于binlog丢失，临时库的数据会少一次更新操作</li><li>先写binlog厚些redolog<br>binlog写完，redolog还没写，系统崩溃之后，由此数据没有被更新。但是binlog已经有了更新的日志，之后用binlog来恢复数据的时候就多了一条更新。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;执行流程-和查询流程保持一致&quot;&gt;&lt;a href=&quot;#执行流程-和查询流程保持一致&quot; class=&quot;headerlink&quot; title=&quot;执行流程(和查询流程保持一致)&quot;&gt;&lt;/a&gt;执行流程(和查询流程保持一致)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;连接器 –&amp;gt; 连接数据
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>01|一条SQL查询语句是如何执行的</title>
    <link href="https://shawnyou.tech/2019/11/20/mysql-notes/01%7C%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>https://shawnyou.tech/2019/11/20/mysql-notes/01|一条SQL查询语句是如何执行的/</id>
    <published>2019-11-20T14:47:29.000Z</published>
    <updated>2019-11-21T12:57:59.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><blockquote><p>负责与客户端建立连接。<br>shou processlist (查看连接)<br>长连接内存占用过大OOM如何解决：</p><ul><li>定期断开长连接</li><li>MySQL5.7以及以上版本，可以在执行完比较大的操作后，通过mysql_reset_connection重新初始化连接资源，使连接恢复到刚刚创建完时的状态。</li></ul></blockquote><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><blockquote><p>建立连接后会优先查询缓存，查询缓存弊大于利，MySQL8.0将查询缓存删除。</p><ul><li>对于一张经常变更的表，缓存经常被清空，缓存的命中率非常低，对于静态表适合做查询缓存。</li><li>按需使用查询缓存。</li></ul></blockquote><h4 id="分析器-分析要做什么"><a href="#分析器-分析要做什么" class="headerlink" title="分析器(分析要做什么)"></a>分析器(分析要做什么)</h4><blockquote><p>如何没有命中查询缓存，就要开始执行SQl语句了。</p><ul><li>词法分析：识别关键词，如select, from ,table….</li><li>语法分析：根据语法规则判断SQL语句的正确性。</li></ul></blockquote><h4 id="优化器-确定执行方案"><a href="#优化器-确定执行方案" class="headerlink" title="优化器(确定执行方案)"></a>优化器(确定执行方案)</h4><ul><li>当存在多个索引的时候，决定索引的选择</li><li>多表关联的时候，决定多个表的连接顺序<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><blockquote><p>根据选择的存储引擎调用引擎接口从第一行开始比对，直到最后一行找出所有满足条件的记录返回结果集。</p></blockquote></li><li>慢查询日志：rows_examined(语句执行过程中的扫描行)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MySQL基础架构&quot;&gt;&lt;a href=&quot;#MySQL基础架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL基础架构&quot;&gt;&lt;/a&gt;MySQL基础架构&lt;/h3&gt;&lt;h4 id=&quot;连接器&quot;&gt;&lt;a href=&quot;#连接器&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>接口与抽象类</title>
    <link href="https://shawnyou.tech/2019/11/20/design-pattern/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://shawnyou.tech/2019/11/20/design-pattern/接口与抽象类/</id>
    <published>2019-11-20T14:47:29.000Z</published>
    <updated>2019-11-21T12:58:06.390Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接口和抽象类是很多设计模式、设计思想、设计原则编程实现的基础。</p></blockquote><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>不允许被实例化</li><li>抽象类包含属性和方法。其中方法可以包含代码实现，也可以不包含代码实现(抽象方法)</li><li>子类集成抽象类。子类必须实现抽象类的抽象方法。</li></ul><h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><ul><li>接口不能包含属性(成员变量)</li><li>接口只能声明方法，方法不能包含方法实现</li><li>类实现接口的时候，必须实现接口的所有方法。</li></ul><h3 id="抽象类与接口类的区别"><a href="#抽象类与接口类的区别" class="headerlink" title="抽象类与接口类的区别"></a>抽象类与接口类的区别</h3><ul><li>抽象类的本质是类，主要只能被子类去继承，体现着is-a的继承关系</li><li>接口类表示一种has-a的关系，体现具有某些功能，表现为一种约定和协议。</li></ul><h3 id="抽象类和接口类能解决什么问题"><a href="#抽象类和接口类能解决什么问题" class="headerlink" title="抽象类和接口类能解决什么问题"></a>抽象类和接口类能解决什么问题</h3><h4 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h4><ul><li>代码复用，避免在子类中编写相同的代码</li></ul><blockquote><p>同样是代码复用，为什么不直接用继承，而要使用抽象类来实现？相比继承来说，抽象类的实现更加的优雅</p></blockquote><ul><li>父类中定义一个被子类继承的无意义的log()方法会使代码的可读性变差。</li><li>创建子类的时候，会忘记重写log()。然而抽象类会强制子类实现。</li><li>继承中，父类是可以被实例化的，我们可以调用空的log()方法，会增加类误用的风险。(可以通过设置私有构造函数解决)</li></ul><h4 id="接口类-1"><a href="#接口类-1" class="headerlink" title="接口类"></a>接口类</h4><blockquote><p>侧重于解耦。对行为进行抽象，之关系接口的协议，不关心具体实现，实现约定与实现相分离。</p></blockquote><h3 id="模拟接口类和抽象类"><a href="#模拟接口类和抽象类" class="headerlink" title="模拟接口类和抽象类"></a>模拟接口类和抽象类</h3><h4 id="模拟接口类"><a href="#模拟接口类" class="headerlink" title="模拟接口类"></a>模拟接口类</h4><blockquote><p>普通类模拟接口类</p><ul><li>protect访问权限，避免类被实例化</li><li>不含具体实现的方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockInteface</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MockInteface</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MethodUnSupportedException(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="抽象类和接口类的使用"><a href="#抽象类和接口类的使用" class="headerlink" title="抽象类和接口类的使用"></a>抽象类和接口类的使用</h3><ul><li>抽象类：is-a的关系，解决代码复用的问题</li><li>接口类：has-a的关系，解决耦合的问题，表示一组行为特征，隔离接口和具体实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;接口和抽象类是很多设计模式、设计思想、设计原则编程实现的基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h3&gt;&lt;ul
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式|手写一个迭代器</title>
    <link href="https://shawnyou.tech/2019/10/22/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/10/22/迭代器模式/</id>
    <published>2019-10-22T15:25:15.000Z</published>
    <updated>2019-11-04T14:54:52.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>我们在日常的开发中，特别是在使用集合的过程中都或多或少使用了迭代器来对集合进行遍历。这时候我们就会思考一个问题，明明简单的For循环就能解决的集合遍历问题，我们非得创造一个迭代器来进行集合的遍历，使用迭代器来遍历到底有什么不一样的地方吗？本着‘存在即合理’的原则，我们通过手写迭代器的方式来深入了解一下迭代器模式的实现和带来的编码好处。</p><h4 id="实现案例"><a href="#实现案例" class="headerlink" title="实现案例"></a>实现案例</h4><p>有一个书架，我们想要知道这个书架里面堆了哪些书籍，这时候我们就需要对书架里面的书一本一本的遍历，直到没有书本，我们就能清楚的知道数据上堆满了哪些书籍。</p><ul><li><p>可以被遍历的标记(生成迭代器的接口)<br>首先提供一个接口，来标明这个类是可以被遍历的集合。实现这个接口的类可以生成对应的迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代器接口<br>迭代器的抽象接口，定义了两个方法<br>（1）是否还有下一个元素<br>（2）返回下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>集合存储的元素（书本）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">book</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代器实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelfIterator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookShelf bookShelf;</span><br><span class="line">    <span class="comment">//指向当前遍历的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//将当前的index与集合的大小做比较，小于集合大小，说明还有元素。</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; bookShelf.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Book book = bookShelf.getBookAt(index);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>书架类<br>书架类用于存放书本，可以用来遍历，因此需要实现Aggregate接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span> <span class="keyword">implements</span> <span class="title">Aggregate</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//生成对应的迭代器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BookShelfIterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = bookShelf.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext)&#123;</span><br><span class="line">    Book book = (Book)it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>由此，我们就自定义实现了一个迭代器，可以满足集合遍历的基本需求</p></blockquote><h3 id="迭代器模式的几点思考"><a href="#迭代器模式的几点思考" class="headerlink" title="迭代器模式的几点思考"></a>迭代器模式的几点思考</h3><h4 id="为什么要使用迭代模式"><a href="#为什么要使用迭代模式" class="headerlink" title="为什么要使用迭代模式"></a>为什么要使用迭代模式</h4><p>遍历与实现分开，无论BookShelf是怎样的实现，只要能够获取到对应的迭代器，遍历方式都是不会变的，利于代码的扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = bookShelf.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext)&#123;</span><br><span class="line">    Book book = (Book)it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多种迭代器"><a href="#多种迭代器" class="headerlink" title="多种迭代器"></a>多种迭代器</h4><p>迭代器实现了遍历集合的方式，那么我们可以设计多种不一样的迭代器。</p><ul><li>从后向前遍历</li><li>跳跃性遍历</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a&gt;迭代器模式&lt;/h3&gt;&lt;p&gt;我们在日常的开发中，特别是在使用集合的过程中都或多或少使用了迭代器来对集合进行遍历。这时候我们就会思考一个问题，明明
      
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://shawnyou.tech/2019/07/03/%E9%87%8D%E6%9E%84/%E9%87%8D%E6%9E%84/"/>
    <id>https://shawnyou.tech/2019/07/03/重构/重构/</id>
    <published>2019-07-03T14:43:46.340Z</published>
    <updated>2019-07-08T13:50:08.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重构总结（TODO）"><a href="#重构总结（TODO）" class="headerlink" title="重构总结（TODO）"></a>重构总结（TODO）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="1-什么是重构"><a href="#1-什么是重构" class="headerlink" title="1.什么是重构"></a>1.什么是重构</h2><blockquote><p>重构是对软件的内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高代码可理解性，降低维护成本。</p></blockquote><p>关键：</p><ul><li>更好的可读性</li><li>更好的可扩展性</li><li>功能保持一致</li></ul><h2 id="为什么要重构"><a href="#为什么要重构" class="headerlink" title="为什么要重构"></a>为什么要重构</h2><ul><li>改进软件设计<br>整理代码，使代码结构回到最初设计，维持代码该有的形态，避免软件腐烂变质。</li><li>使软件更容易理解<br>代码是人与及其交互的语言。保持语言的简洁有助于：<br>（1）理解代码<br>（2）后来者维护代码</li><li>帮助找到Bug<br>重构过程可以重新梳理逻辑，找到潜在的Bug。</li><li>提高编程速度<br>良好的设计师快速开发的根本。</li></ul><h2 id="何时进行重构"><a href="#何时进行重构" class="headerlink" title="何时进行重构"></a>何时进行重构</h2><p>事不过三，三则重构</p><ul><li>添加功能时重构<br>添加功能时，理解需要修改的代码，使添加功能更加轻松。</li><li>修改错误时候重构<br>好的代码是足够清晰以至于能够肉眼观察bug，所以当遇到bug时，说明设计不够清晰，因而需要重构</li><li>复审代码时重构</li></ul><h3 id="重构的期望"><a href="#重构的期望" class="headerlink" title="重构的期望"></a>重构的期望</h3><ul><li>容易阅读</li><li>所有的逻辑都只在唯一地点指定</li><li>新的改动不会危及现有行为</li><li>尽可能简单的表达条件逻辑</li></ul><h2 id="代码的坏味道（什么样的代码需要重构）"><a href="#代码的坏味道（什么样的代码需要重构）" class="headerlink" title="代码的坏味道（什么样的代码需要重构）"></a>代码的坏味道（什么样的代码需要重构）</h2><ol><li>重复代码（Duplicated Code）</li></ol><ul><li>同一个类中的两个函数具有相同的代码，可以使用Extract Method提炼吃重复代码</li><li>两个兄弟子类具有相同的代码，则提炼相同代码（Extract Method）,再将提炼出来的函数推送给父类（Pull up method）</li><li>对于部分相同的情况，则分离出相似部分和差异部分，使用模板设计模式。</li><li>两个不相关类出现重复代码，则将重复代码提取到一个独立类。 </li></ul><ol start="2"><li>过长的函数（Long method）</li></ol><ul><li>小型函数作为“间接层”具有解释能力、共享能力、选择能力</li><li>当需要用注释来描述代码的时候，就应该对函数进行分解，把需要说明的部分放入独立的函数，以其用途来命名</li><li>函数传参里有过多的参数和临时变量，应该尽量消除临时变量，使参数列表更加简洁。</li></ul><ol start="3"><li>过大的类（Large Class）</li><li>过长的参数列（Long Paramenter List）</li><li>发散式变化（Divergent Change）</li><li>散弹式修改（Shotgun Surgery）</li><li>依恋情节（Feature Envy）</li><li>数据泥团（Data Clumps）</li><li>基本类型偏执（Primitive Obsession）</li><li>Switch现身（Switch Statement）</li><li>平行继承体系（Parallel Inheritance Hierarchies）</li><li>冗赘类（Lazy Class）</li><li>夸夸其谈未来性（Speculative Generality）</li><li>令人迷惑的临时字段（Temporary Field）</li><li>过度耦合的消息链（Message Chains）</li><li>中间人（Middle Man）</li><li>狎昵关系（Inappropriate Intimacy）</li><li>异曲同工的类（Alternative Classes with Different Interfaces）</li><li>不完美的库类（Incomplete Library Class）</li><li>纯稚的数据类（Data Class）</li><li>被拒绝的遗赠（Refused Bequest）</li><li>过多的注释（Comments）</li></ol><p>重构列表</p><p>重新组织函数</p><ol><li>提炼函数（Extract Method）<br>适用场景</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重构总结（TODO）&quot;&gt;&lt;a href=&quot;#重构总结（TODO）&quot; class=&quot;headerlink&quot; title=&quot;重构总结（TODO）&quot;&gt;&lt;/a&gt;重构总结（TODO）&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringCache源码| Spring Cache的AOP实现原理</title>
    <link href="https://shawnyou.tech/2019/06/27/Spring-boot/%E7%BC%93%E5%AD%98%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA/"/>
    <id>https://shawnyou.tech/2019/06/27/Spring-boot/缓存方法拦截/</id>
    <published>2019-06-27T14:51:50.000Z</published>
    <updated>2019-06-30T14:41:57.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h2><p>Spring Cache是通过AOP面向切面编程的思想来对缓存的操作进行封装，通过拦截器对实现了Spring Cache注解的方法进行拦截，可以根据注解信息去完成相应的缓存操作。</p><h2 id="2-CacheInterceptor拦截器"><a href="#2-CacheInterceptor拦截器" class="headerlink" title="2. CacheInterceptor拦截器"></a>2. CacheInterceptor拦截器</h2><p>Spring Cache提供了一个缓存拦截器，负责拦截方法调用执行缓存逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">extends</span> <span class="title">CacheAspectSupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被拦截的方法都会走invoke</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//invocation就是一个连接点(Joinpoint),其实就是对方调用方法的封装。</span></span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        CacheOperationInvoker aopAllianceInvoker = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ThrowableWrapper(var2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//核心的方法，来自于父类</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.execute(aopAllianceInvoker, invocation.getThis(), method, invocation.getArguments());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ThrowableWrapper var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5.getOriginal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheIntercepto实现了MethodInterceptor，MethodInterceptor主要对方法进行拦截，查看MethodInterceptor的继承图，发现MethodInterceptor就是一个Advice，在Spring AOP的概念里面，Advice就是一个通知，通知封装了AOP的横切逻辑。由此来说CacheInterceptor作为一个通知，他里面肯定包含缓存操作的横切逻辑，能够处理方法调用前后的缓存操作。</p><h3 id="2-1-查看父类的核心方法execute"><a href="#2-1-查看父类的核心方法execute" class="headerlink" title="2.1 查看父类的核心方法execute"></a>2.1 查看父类的核心方法execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">execute</span><span class="params">(CacheOperationInvoker invoker, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//是否初始化成功</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.initialized) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = <span class="keyword">this</span>.getTargetClass(target);</span><br><span class="line">            <span class="comment">//获取CacheOperation资源类，负责解析Spring Cache注解的类</span></span><br><span class="line">            CacheOperationSource cacheOperationSource = <span class="keyword">this</span>.getCacheOperationSource();</span><br><span class="line">            <span class="keyword">if</span>(cacheOperationSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//解析注解，得到CacheOperation的集合。</span></span><br><span class="line">                Collection&lt;CacheOperation&gt; operations = cacheOperationSource.getCacheOperations(method, targetClass);</span><br><span class="line">                <span class="keyword">if</span>(!CollectionUtils.isEmpty(operations)) &#123;</span><br><span class="line">                    <span class="comment">//调用内部方法execute，封装了一个缓存操作的上下文并传入</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.execute(invoker, method, <span class="keyword">new</span> CacheAspectSupport.CacheOperationContexts(operations, method, args, target, targetClass));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要作用：</p><ol><li>获取缓存操作集合CacheOperation</li><li>封装缓存操作上下文，并调用内部的execute方法</li></ol><h3 id="2-2-核心内部方法execute"><a href="#2-2-核心内部方法execute" class="headerlink" title="2.2 核心内部方法execute"></a>2.2 核心内部方法execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">execute</span><span class="params">(CacheOperationInvoker invoker, Method method, CacheAspectSupport.CacheOperationContexts contexts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(contexts.isSynchronized()) &#123;</span><br><span class="line">            <span class="comment">//获取CacheableOperation对应的缓存操作上下文。</span></span><br><span class="line">            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)contexts.get(CacheableOperation.class).iterator().next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) &#123;</span><br><span class="line">                Object key = <span class="keyword">this</span>.generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class="line">                <span class="comment">//获取缓存对象</span></span><br><span class="line">                Cache cache = (Cache)context.getCaches().iterator().next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.wrapCacheValue(method, cache.get(key, () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.unwrapReturnValue(<span class="keyword">this</span>.invokeOperation(invoker));</span><br><span class="line">                    &#125;));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ValueRetrievalException var10) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (ThrowableWrapper)var10.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.invokeOperation(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1. 处理BeforeInvocation = true的缓存删除操作</span></span><br><span class="line">            <span class="keyword">this</span>.processCacheEvicts(contexts.get(CacheEvictOperation.class), <span class="keyword">true</span>, CacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class="line">            <span class="comment">//2. 查找是否有@Cacheable的缓存数据</span></span><br><span class="line">            ValueWrapper cacheHit = <span class="keyword">this</span>.findCachedItem(contexts.get(CacheableOperation.class));</span><br><span class="line">            List&lt;CacheAspectSupport.CachePutRequest&gt; cachePutRequests = <span class="keyword">new</span> LinkedList();</span><br><span class="line">            <span class="keyword">if</span>(cacheHit == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果没有缓存数据，则封装成CachePutRequest</span></span><br><span class="line">                <span class="keyword">this</span>.collectPutRequests(contexts.get(CacheableOperation.class), CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object cacheValue;</span><br><span class="line">            Object returnValue;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cacheHit != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.hasCachePut(contexts)) &#123;</span><br><span class="line">                <span class="comment">//获取缓存数据里面的值</span></span><br><span class="line">                cacheValue = cacheHit.get();</span><br><span class="line">                returnValue = <span class="keyword">this</span>.wrapCacheValue(method, cacheValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有找到Cacheable的缓存数据，或者缓存注解是CachePut则调用方法，获取方法返回值</span></span><br><span class="line">                returnValue = <span class="keyword">this</span>.invokeOperation(invoker);</span><br><span class="line">                cacheValue = <span class="keyword">this</span>.unwrapReturnValue(returnValue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 将CachePut注解封装成CachePutRequest</span></span><br><span class="line">            <span class="keyword">this</span>.collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);</span><br><span class="line">            Iterator var8 = cachePutRequests.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//遍历cachePutRequest，将方法调用的返回值置入缓存中。</span></span><br><span class="line">                CacheAspectSupport.CachePutRequest cachePutRequest = (CacheAspectSupport.CachePutRequest)var8.next();</span><br><span class="line">                cachePutRequest.apply(cacheValue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理BeforeInvocation = false的缓存删除操作</span></span><br><span class="line">            <span class="keyword">this</span>.processCacheEvicts(contexts.get(CacheEvictOperation.class), <span class="keyword">false</span>, cacheValue);</span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果不需要同步，该方法主要完成了以下的逻辑</p><ol><li>处理BeforeInvocation = true的缓存删除操作 </li><li>通过@Cacheable注解找到对应的缓存值。</li><li>如果没有找到对应的缓存数据，则将@Cacheable封装成CachePutRequest，标记为一个插入缓存的请求。</li><li>进行方法调用</li><li>将CachePut注解封装成CachePutRequest</li><li>遍历CachePutReqeust集合，将方法调用的返回值置入缓存中。</li><li>处理BeforeInvocation = false的缓存删除操作  </li></ol><p>梳理一下，这个方法里面包括三个注解的逻辑</p><ol><li><p>@Cacheable<br>(1) 首先从缓存中找@Cacheable对应的缓存<br>(2) 如果缓存存在，则取出缓存值作为返回值<br>(3) 如果缓存不存在，则进行方法调用，获取返回值，并将返回值置入缓存</p></li><li><p>@CachePut<br>(1) 如果包含cachePut注解，则进行方法调用。<br>(2) 获取方法返回值，并置入缓存之中。</p></li><li><p>@CacheEvic<br>(1) 在方法调用签执行缓存删除操作。<br>(2) 在方法调用后执行缓存删除操作。</p></li></ol><h4 id="2-2-1-processCacheEvicts"><a href="#2-2-1-processCacheEvicts" class="headerlink" title="2.2.1 processCacheEvicts"></a>2.2.1 processCacheEvicts</h4><p>我们来看看缓存删除的具体逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//beforeInvocation指的是方法调用前还是调用后，@CacheEvict可以进行设置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCacheEvicts</span><span class="params">(Collection&lt;CacheAspectSupport.CacheOperationContext&gt; contexts, <span class="keyword">boolean</span> beforeInvocation, @Nullable Object result)</span> </span>&#123;</span><br><span class="line">        Iterator var4 = contexts.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)var4.next();</span><br><span class="line">            CacheEvictOperation operation = (CacheEvictOperation)context.metadata.operation;</span><br><span class="line">            <span class="keyword">if</span>(beforeInvocation == operation.isBeforeInvocation() &amp;&amp; <span class="keyword">this</span>.isConditionPassing(context, result)) &#123;</span><br><span class="line">                <span class="comment">//处理缓存删除操作</span></span><br><span class="line">                <span class="keyword">this</span>.performCacheEvict(context, operation, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performCacheEvict</span><span class="params">(CacheAspectSupport.CacheOperationContext context, CacheEvictOperation operation, @Nullable Object result)</span> </span>&#123;</span><br><span class="line">        Object key = <span class="keyword">null</span>;</span><br><span class="line">        Iterator var5 = context.getCaches().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//遍历获取Cache对象</span></span><br><span class="line">            Cache cache = (Cache)var5.next();</span><br><span class="line">            <span class="keyword">if</span>(operation.isCacheWide()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logInvalidating(context, operation, (Object)<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//删除全部缓存</span></span><br><span class="line">                <span class="keyword">this</span>.doClear(cache);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    key = <span class="keyword">this</span>.generateKey(context, result);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.logInvalidating(context, operation, key);</span><br><span class="line">                <span class="comment">//删除指定key的缓存</span></span><br><span class="line">                <span class="keyword">this</span>.doEvict(cache, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-2-findCachedItem-获取缓存数据"><a href="#2-2-2-findCachedItem-获取缓存数据" class="headerlink" title="2.2.2 findCachedItem(获取缓存数据)"></a>2.2.2 findCachedItem(获取缓存数据)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ValueWrapper <span class="title">findCachedItem</span><span class="params">(Collection&lt;CacheAspectSupport.CacheOperationContext&gt; contexts)</span> </span>&#123;</span><br><span class="line">        Object result = CacheOperationExpressionEvaluator.NO_RESULT;</span><br><span class="line">        Iterator var3 = contexts.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)var3.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isConditionPassing(context, result)) &#123;</span><br><span class="line">                <span class="comment">//生成相应的Cache key</span></span><br><span class="line">                Object key = <span class="keyword">this</span>.generateKey(context, result);</span><br><span class="line">                <span class="comment">//通过缓存上下文和key找寻相应的缓存包装对象</span></span><br><span class="line">                ValueWrapper cached = <span class="keyword">this</span>.findInCaches(context, key);</span><br><span class="line">                <span class="keyword">if</span>(cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cached;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.trace(<span class="string">"No cache entry for key '"</span> + key + <span class="string">"' in cache(s) "</span> + context.getCacheNames());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ValueWrapper <span class="title">findInCaches</span><span class="params">(CacheAspectSupport.CacheOperationContext context, Object key)</span> </span>&#123;</span><br><span class="line">        Iterator var3 = context.getCaches().iterator();</span><br><span class="line"></span><br><span class="line">        Cache cache;</span><br><span class="line">        ValueWrapper wrapper;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!var3.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取缓存对象，并通过key去查找缓存值</span></span><br><span class="line">            cache = (Cache)var3.next();</span><br><span class="line">            wrapper = <span class="keyword">this</span>.doGet(cache, key);</span><br><span class="line">        &#125; <span class="keyword">while</span>(wrapper == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"Cache entry for key '"</span> + key + <span class="string">"' found in cache '"</span> + cache.getName() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3collectPutRequests-封装存储缓存的请求"><a href="#2-2-3collectPutRequests-封装存储缓存的请求" class="headerlink" title="2.2.3collectPutRequests(封装存储缓存的请求)"></a>2.2.3collectPutRequests(封装存储缓存的请求)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectPutRequests</span><span class="params">(Collection&lt;CacheAspectSupport.CacheOperationContext&gt; contexts, @Nullable Object result, Collection&lt;CacheAspectSupport.CachePutRequest&gt; putRequests)</span> </span>&#123;</span><br><span class="line">        Iterator var4 = contexts.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)var4.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isConditionPassing(context, result)) &#123;</span><br><span class="line">                Object key = <span class="keyword">this</span>.generateKey(context, result);</span><br><span class="line">                <span class="comment">//通过key和缓存上下文封装一个插入缓存的请求。</span></span><br><span class="line">                putRequests.add(<span class="keyword">new</span> CacheAspectSupport.CachePutRequest(context, key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>目前，关于Spring Cache的源码分析就告一段落了，总的来说，SpringCache的分析文章主要对缓存注解实现的源码做了一个简要的分析，目的是能够对缓存操作的AOP实现原理有一个清晰的认识。能够搞清楚Spring Cache是如何借助AOP的思想来实现如何简单、快捷且代码侵入低的缓存组件。由此我们可以借鉴这些思想和案例来丰富我们的阅历，以助于提高我们的技术水平，帮助我们能够实现类似的开源组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-简述&quot;&gt;&lt;a href=&quot;#1-简述&quot; class=&quot;headerlink&quot; title=&quot;1. 简述&quot;&gt;&lt;/a&gt;1. 简述&lt;/h2&gt;&lt;p&gt;Spring Cache是通过AOP面向切面编程的思想来对缓存的操作进行封装，通过拦截器对实现了Spring Cache
      
    
    </summary>
    
      <category term="Spring" scheme="https://shawnyou.tech/categories/Spring/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringCache源码| SpringCache缓存注解解析</title>
    <link href="https://shawnyou.tech/2019/06/26/Spring-boot/%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://shawnyou.tech/2019/06/26/Spring-boot/缓存注解解析与应用/</id>
    <published>2019-06-26T14:51:50.000Z</published>
    <updated>2019-06-30T14:53:36.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-缓存的解析"><a href="#1-缓存的解析" class="headerlink" title="1.缓存的解析"></a>1.缓存的解析</h2><p>Spring Cache提供了缓存解析器，负责为缓存注解抽象成一个缓存信息对象。我们通过面向对象的编程方式就能够轻松的获取缓存操作信息</p><h3 id="1-1CacheAnnotationParser缓存注解解析器"><a href="#1-1CacheAnnotationParser缓存注解解析器" class="headerlink" title="1.1CacheAnnotationParser缓存注解解析器"></a>1.1CacheAnnotationParser缓存注解解析器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheAnnotationParser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对类上面的缓存注解进行解析</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line">    <span class="comment">//对方法上面的注解进行解析</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Method var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheAnnotationParser有一个实现类SpringCacheAnnotationParser,两个方法的实现是一样的，最终method也会转换成Class。所以这里针对parseCacheAnnotations(Class&lt;?&gt; var1)做解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取</span></span><br><span class="line">    SpringCacheAnnotationParser.DefaultCacheConfig defaultConfig = <span class="keyword">this</span>.getDefaultCacheConfig(type);</span><br><span class="line">    <span class="comment">//2. 通过DefaultCacheConfig信息和class去解析缓存注解</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parseCacheAnnotations(defaultConfig, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    SpringCacheAnnotationParser.DefaultCacheConfig defaultConfig = <span class="keyword">this</span>.getDefaultCacheConfig(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parseCacheAnnotations(defaultConfig, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-2getDefaultCacheConfig"><a href="#1-2getDefaultCacheConfig" class="headerlink" title="1.2getDefaultCacheConfig"></a>1.2getDefaultCacheConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpringCacheAnnotationParser.<span class="function">DefaultCacheConfig <span class="title">getDefaultCacheConfig</span><span class="params">(Class&lt;?&gt; target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取类上面的@CacheConfig注解信息</span></span><br><span class="line">        CacheConfig annotation = (CacheConfig)AnnotatedElementUtils.findMergedAnnotation(target, CacheConfig.class);</span><br><span class="line">        <span class="comment">//如果@CacheConfig不存在，则构建一个默认的DefaultCacheConfig</span></span><br><span class="line">        <span class="keyword">return</span> annotation != <span class="keyword">null</span> ? <span class="keyword">new</span> SpringCacheAnnotationParser.DefaultCacheConfig(annotation.cacheNames(), annotation.keyGenerator(), annotation.cacheManager(), annotation.cacheResolver()) : <span class="keyword">new</span> SpringCacheAnnotationParser.DefaultCacheConfig();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-parseCacheAnnotations"><a href="#1-3-parseCacheAnnotations" class="headerlink" title="1.3. parseCacheAnnotations"></a>1.3. parseCacheAnnotations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(SpringCacheAnnotationParser.DefaultCacheConfig cachingConfig, AnnotatedElement ae)</span> </span>&#123;</span><br><span class="line">        Collection&lt;CacheOperation&gt; ops = <span class="keyword">this</span>.parseCacheAnnotations(cachingConfig, ae, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (ops != <span class="keyword">null</span> &amp;&amp; ops.size() &gt; <span class="number">1</span> &amp;&amp; ae.getAnnotations().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Collection&lt;CacheOperation&gt; localOps = <span class="keyword">this</span>.parseCacheAnnotations(cachingConfig, ae, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (localOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> localOps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ops;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法只是一个空壳，真正的逻辑在this.parseCacheAnnotations(cachingConfig, ae, false)这里面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(SpringCacheAnnotationParser.DefaultCacheConfig cachingConfig, AnnotatedElement ae, <span class="keyword">boolean</span> localOnly)</span> </span>&#123;</span><br><span class="line">        Collection&lt;CacheOperation&gt; ops = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//解析@Cacheable</span></span><br><span class="line">        Collection&lt;Cacheable&gt; cacheables = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, Cacheable.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, Cacheable.class);</span><br><span class="line">        <span class="keyword">if</span> (!cacheables.isEmpty()) &#123;</span><br><span class="line">            ops = <span class="keyword">this</span>.lazyInit((Collection)<span class="keyword">null</span>);</span><br><span class="line">            Iterator var6 = cacheables.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                Cacheable cacheable = (Cacheable)var6.next();</span><br><span class="line">                ops.add(<span class="keyword">this</span>.parseCacheableAnnotation(ae, cachingConfig, cacheable));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析@cacheEvict</span></span><br><span class="line">        Collection&lt;CacheEvict&gt; evicts = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, CacheEvict.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, CacheEvict.class);</span><br><span class="line">        <span class="keyword">if</span> (!evicts.isEmpty()) &#123;</span><br><span class="line">            ops = <span class="keyword">this</span>.lazyInit(ops);</span><br><span class="line">            Iterator var13 = evicts.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var13.hasNext()) &#123;</span><br><span class="line">                CacheEvict evict = (CacheEvict)var13.next();</span><br><span class="line">                ops.add(<span class="keyword">this</span>.parseEvictAnnotation(ae, cachingConfig, evict));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析@CachePut</span></span><br><span class="line">        Collection&lt;CachePut&gt; puts = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, CachePut.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, CachePut.class);</span><br><span class="line">        <span class="keyword">if</span> (!puts.isEmpty()) &#123;</span><br><span class="line">            ops = <span class="keyword">this</span>.lazyInit(ops);</span><br><span class="line">            Iterator var15 = puts.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                CachePut put = (CachePut)var15.next();</span><br><span class="line">                ops.add(<span class="keyword">this</span>.parsePutAnnotation(ae, cachingConfig, put));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析Cache</span></span><br><span class="line">        Collection&lt;Caching&gt; cachings = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, Caching.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, Caching.class);</span><br><span class="line">        <span class="keyword">if</span> (!cachings.isEmpty()) &#123;</span><br><span class="line">            ops = <span class="keyword">this</span>.lazyInit(ops);</span><br><span class="line">            Iterator var17 = cachings.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var17.hasNext()) &#123;</span><br><span class="line">                Caching caching = (Caching)var17.next();</span><br><span class="line">                Collection&lt;CacheOperation&gt; cachingOps = <span class="keyword">this</span>.parseCachingAnnotation(ae, cachingConfig, caching);</span><br><span class="line">                <span class="keyword">if</span> (cachingOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ops.addAll(cachingOps);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ops;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>由上可知，代码分别对@Cacheable,@CachePut,@CacheEvict进行解析，一旦发现相应的注解，就对注解信息封装成对应的CacheOperation(缓存操作信息对象)。封装过程的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CacheableOperation <span class="title">parseCacheableAnnotation</span><span class="params">(AnnotatedElement ae, SpringCacheAnnotationParser.DefaultCacheConfig defaultConfig, Cacheable cacheable)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> Builder();</span><br><span class="line">        builder.setName(ae.toString());</span><br><span class="line">        builder.setCacheNames(cacheable.cacheNames());</span><br><span class="line">        builder.setCondition(cacheable.condition());</span><br><span class="line">        builder.setUnless(cacheable.unless());</span><br><span class="line">        builder.setKey(cacheable.key());</span><br><span class="line">        builder.setKeyGenerator(cacheable.keyGenerator());</span><br><span class="line">        builder.setCacheManager(cacheable.cacheManager());</span><br><span class="line">        builder.setCacheResolver(cacheable.cacheResolver());</span><br><span class="line">        builder.setSync(cacheable.sync());</span><br><span class="line">        defaultConfig.applyDefault(builder);</span><br><span class="line">        CacheableOperation op = builder.build();</span><br><span class="line">        <span class="comment">//验证key()与keyGenerator()  以及CacheManager与CacheResolver之间的排他性。代码逻辑如下。</span></span><br><span class="line">        <span class="keyword">this</span>.validateCacheOperation(ae, op);</span><br><span class="line">        <span class="keyword">return</span> op;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateCacheOperation</span><span class="params">(AnnotatedElement ae, CacheOperation operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(operation.getKey()) &amp;&amp; StringUtils.hasText(operation.getKeyGenerator())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid cache annotation configuration on '"</span> + ae.toString() + <span class="string">"'. Both 'key' and 'keyGenerator' attributes have been set. These attributes are mutually exclusive: either set the SpEL expression used tocompute the key at runtime or set the name of the KeyGenerator bean to use."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(operation.getCacheManager()) &amp;&amp; StringUtils.hasText(operation.getCacheResolver())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid cache annotation configuration on '"</span> + ae.toString() + <span class="string">"'. Both 'cacheManager' and 'cacheResolver' attributes have been set. These attributes are mutually exclusive: the cache manager is used to configure adefault cache resolver if none is set. If a cache resolver is set, the cache managerwon't be used."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-4小结"><a href="#1-4小结" class="headerlink" title="1.4小结"></a>1.4小结</h3><p>由此Spring Cache通过缓存注解解析器，将对应的缓存注解解析成了CacheOperation对象，CacheOperation对象封装了缓存注解信息的细节，可以指导相应的缓存操作。</p><h2 id="2-谈谈CacheOperation缓存封装类"><a href="#2-谈谈CacheOperation缓存封装类" class="headerlink" title="2.谈谈CacheOperation缓存封装类"></a>2.谈谈CacheOperation缓存封装类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheOperation</span> <span class="keyword">implements</span> <span class="title">BasicOperation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; cacheNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String keyGenerator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cacheManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cacheResolver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String condition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String toString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheOperation是一个抽象的缓存操作类，它封装了Cache操作的基本属性，是对缓存信息的抽象</p><ol><li>CacheableOperation(@Cacheable)</li><li>CachePutOperation(@CachePut)</li><li>CacheEvictOperation(@CacheEvict)</li></ol><h2 id="3-缓存操作资源类"><a href="#3-缓存操作资源类" class="headerlink" title="3.缓存操作资源类"></a>3.缓存操作资源类</h2><p>Spring Cache提供了一个缓存操作资源接口(CacheOperationSource)来调用缓存注解的解析工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheOperationSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为一个执行方法返回所有的缓存操作集合</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Collection&lt;CacheOperation&gt; <span class="title">getCacheOperations</span><span class="params">(Method var1, @Nullable Class&lt;?&gt; var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCachingConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractCachingConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyCachingConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(</span><br><span class="line">        name = &#123;<span class="string">"org.springframework.cache.config.internalCacheAdvisor"</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanFactoryCacheOperationSourceAdvisor <span class="title">cacheAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanFactoryCacheOperationSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryCacheOperationSourceAdvisor();</span><br><span class="line">        advisor.setCacheOperationSource(<span class="keyword">this</span>.cacheOperationSource());</span><br><span class="line">        advisor.setAdvice(<span class="keyword">this</span>.cacheInterceptor());</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.enableCaching != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisor.setOrder(((Integer)<span class="keyword">this</span>.enableCaching.getNumber(<span class="string">"order"</span>)).intValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheOperationSource <span class="title">cacheOperationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationCacheOperationSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheInterceptor <span class="title">cacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CacheInterceptor interceptor = <span class="keyword">new</span> CacheInterceptor();</span><br><span class="line">        interceptor.configure(<span class="keyword">this</span>.errorHandler, <span class="keyword">this</span>.keyGenerator, <span class="keyword">this</span>.cacheResolver, <span class="keyword">this</span>.cacheManager);</span><br><span class="line">        interceptor.setCacheOperationSource(<span class="keyword">this</span>.cacheOperationSource());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在@Enable文章的代码解析中，在创建Advisor的时候将CacheOperationSource作为属性传递进去了。那么在方法调用时，AOP会通过CacheInterceptor拦截方法，调用CacheOperationSource获取解析方法上面的缓存注解。</p><p>CacheOperationSource有三个实现类，Spring Cache采用AnnotationCacheOperationSource来处理缓存注解的解析工作。</p><p>查看AnnotationCacheOperationSource的继承体系。</p><p>CacheOperationSource的设计采用的是模板模式的方式,获取CacheOperation的主要的通用逻辑在父类AbstractFallbackCacheOperationSource中,子类AnnotationCacheOperationSource主要实现差异化的功能，接下来看一下他们的实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationCacheOperationSource</span> <span class="keyword">extends</span> <span class="title">AbstractFallbackCacheOperationSource</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略了部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只允许public方法 执行缓存操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> publicMethodsOnly;</span><br><span class="line">    <span class="comment">//缓存注解解析器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;CacheAnnotationParser&gt; annotationParsers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Class上面对应的缓存操作(实现父类的方法，方法的调用的父类中)</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.determineCacheOperations((parser) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> parser.parseCacheAnnotations(clazz);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Method上面对应的缓存操作(实现父类的方法，方法的调用的父类中)</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.determineCacheOperations((parser) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> parser.parseCacheAnnotations(method);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历解析器集合，获取所有的CacheOperation</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;CacheOperation&gt; <span class="title">determineCacheOperations</span><span class="params">(AnnotationCacheOperationSource.CacheOperationProvider provider)</span> </span>&#123;</span><br><span class="line">        Collection&lt;CacheOperation&gt; ops = <span class="keyword">null</span>;</span><br><span class="line">        Iterator var3 = <span class="keyword">this</span>.annotationParsers.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">            CacheAnnotationParser annotationParser = (CacheAnnotationParser)var3.next();</span><br><span class="line">            Collection&lt;CacheOperation&gt; annOps = provider.getCacheOperations(annotationParser);</span><br><span class="line">            <span class="keyword">if</span> (annOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ops == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ops = annOps;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Collection&lt;CacheOperation&gt; combined = <span class="keyword">new</span> ArrayList(((Collection)ops).size() + annOps.size());</span><br><span class="line">                    combined.addAll((Collection)ops);</span><br><span class="line">                    combined.addAll(annOps);</span><br><span class="line">                    ops = combined;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Collection)ops;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用CacheAnnotationParser进行注解解析的函数式接口</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheOperationProvider</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function">Collection&lt;CacheOperation&gt; <span class="title">getCacheOperations</span><span class="params">(CacheAnnotationParser var1)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1查看AbstractFallbackCacheOperationSource源码"><a href="#3-1查看AbstractFallbackCacheOperationSource源码" class="headerlink" title="3.1查看AbstractFallbackCacheOperationSource源码"></a>3.1查看AbstractFallbackCacheOperationSource源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFallbackCacheOperationSource</span> <span class="keyword">implements</span> <span class="title">CacheOperationSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Collection&lt;CacheOperation&gt; NULL_CACHING_ATTRIBUTE = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护了一个缓存操作类的map, key为method和class的包装，可以确保唯一性。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Collection&lt;CacheOperation&gt;&gt; attributeCache = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行缓存注解解析工作的主要逻辑</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;CacheOperation&gt; <span class="title">getCacheOperations</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取method和class组成的唯一key</span></span><br><span class="line">            Object cacheKey = <span class="keyword">this</span>.getCacheKey(method, targetClass);</span><br><span class="line">            <span class="comment">//从缓存中去查找CacheOperation.</span></span><br><span class="line">            Collection&lt;CacheOperation&gt; cached = (Collection)<span class="keyword">this</span>.attributeCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cached != NULL_CACHING_ATTRIBUTE ? cached : <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果attributeCache没有发现，则进行缓存操作的解析</span></span><br><span class="line">                Collection&lt;CacheOperation&gt; cacheOps = <span class="keyword">this</span>.computeCacheOperations(method, targetClass);</span><br><span class="line">                <span class="keyword">if</span> (cacheOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.logger.trace(<span class="string">"Adding cacheable method '"</span> + method.getName() + <span class="string">"' with attribute: "</span> + cacheOps);</span><br><span class="line">                    &#125;</span><br><span class="line">                    将解析结构存入attributeCache,供下次使用</span><br><span class="line">                    <span class="keyword">this</span>.attributeCache.put(cacheKey, cacheOps);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.attributeCache.put(cacheKey, NULL_CACHING_ATTRIBUTE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> cacheOps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取由Method和Class产生的唯一key</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getCacheKey</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodClassKey(method, targetClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始解析缓存注解</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;CacheOperation&gt; <span class="title">computeCacheOperations</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断非pulic方法 是否可以获取缓存注解信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找到特定的方法</span></span><br><span class="line">            Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用子类实现 从方法上找缓存注解</span></span><br><span class="line">            Collection&lt;CacheOperation&gt; opDef = <span class="keyword">this</span>.findCacheOperations(specificMethod);</span><br><span class="line">            <span class="keyword">if</span> (opDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> opDef;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//调用子类实现，试着从Class上获取缓存注解</span></span><br><span class="line">                opDef = <span class="keyword">this</span>.findCacheOperations(specificMethod.getDeclaringClass());</span><br><span class="line">                <span class="keyword">if</span> (opDef != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> opDef;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//前面没有找到的话，则从原始执行方法上去找</span></span><br><span class="line">                    <span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">                        opDef = <span class="keyword">this</span>.findCacheOperations(method);</span><br><span class="line">                        <span class="keyword">if</span> (opDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> opDef;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//从原始执行方法的类上去找</span></span><br><span class="line">                        opDef = <span class="keyword">this</span>.findCacheOperations(method.getDeclaringClass());</span><br><span class="line">                        <span class="keyword">if</span> (opDef != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> opDef;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由子类实现逻辑</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line">    <span class="comment">//由子类实现逻辑</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(Method var1)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>本章本章主要从SpringCache 缓存注解的解析工作入手分析，主要的关键点如下：<br>（1）Spring cache提供了一个缓存注解解析类，专门负责解析类或者方法层次上面注解<br>（2）解析的过程将注解信息封装成CacheOperation的对象中，由此方面操作。<br>（3）提供了一个缓存操作资源类(CacheOperationSource)负责管控缓存注解的解析过程。只需将这个缓存操作资源置入想要的地方，就能在需要的地方完成缓存注解解析，提供了一个缓存信息的操作对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-缓存的解析&quot;&gt;&lt;a href=&quot;#1-缓存的解析&quot; class=&quot;headerlink&quot; title=&quot;1.缓存的解析&quot;&gt;&lt;/a&gt;1.缓存的解析&lt;/h2&gt;&lt;p&gt;Spring Cache提供了缓存解析器，负责为缓存注解抽象成一个缓存信息对象。我们通过面向对象的编
      
    
    </summary>
    
      <category term="Spring" scheme="https://shawnyou.tech/categories/Spring/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringCache源码| SpringCache源码总览</title>
    <link href="https://shawnyou.tech/2019/06/24/Spring-boot/SpringCache%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://shawnyou.tech/2019/06/24/Spring-boot/SpringCache源码解析/</id>
    <published>2019-06-24T14:51:50.000Z</published>
    <updated>2019-06-30T15:07:07.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Spring提供了一种基于注解（annotation）的缓存技术，他并不是具体的缓存使用方案，而是一个对缓存使用的抽象方案。只要代码使用相应的缓存注解，就能使用各种定义的缓存操作。由此一来缓存的操作非常的便捷，对代码的侵入比较少，让开发者更关注于业务逻辑的实现。</p><h3 id="1-1-如何使用Spring-Cache"><a href="#1-1-如何使用Spring-Cache" class="headerlink" title="1.1 如何使用Spring Cache"></a>1.1 如何使用Spring Cache</h3><h2 id="2-SpringCache的原理"><a href="#2-SpringCache的原理" class="headerlink" title="2. SpringCache的原理"></a>2. SpringCache的原理</h2><p>缓存的操作相对固定，可以借助AOP面向切面编程的思想将缓存操作作为通用的逻辑封装起来。SpringCache借助AOP的思想将缓存操作封装成了通用的模块。接下来通过一个流程图来了解一下Spring Cache缓存模块的原理。</p><h3 id="2-1-SpringCache的基本接口和注解"><a href="#2-1-SpringCache的基本接口和注解" class="headerlink" title="2.1 SpringCache的基本接口和注解"></a>2.1 SpringCache的基本接口和注解</h3><h4 id="2-1-1-Cache和CacheManager"><a href="#2-1-1-Cache和CacheManager" class="headerlink" title="2.1.1 Cache和CacheManager"></a>2.1.1 Cache和CacheManager</h4><ol><li>Cache<br>Cache接口是缓存操作的基础接口，它提供了关于缓存的增、删、改、查的相关操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回原始的缓存对象</span></span><br><span class="line">    <span class="function">Object <span class="title">getNativeCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回包装值</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Cache.<span class="function">ValueWrapper <span class="title">get</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">    <span class="comment">//获取指定类型的缓存</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Object var1, @Nullable Class&lt;T&gt; var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Object var1, Callable&lt;T&gt; var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Object var1, @Nullable Object var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入缓存</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Cache.<span class="function">ValueWrapper <span class="title">putIfAbsent</span><span class="params">(Object var1, @Nullable Object var2)</span></span>;</span><br><span class="line">    <span class="comment">//删除指定key的缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">evict</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">    <span class="comment">//清空缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Cache有两个实现类ConcurrentMapCache和NoOpCache</p><p>（1）ConcurrentMapCache<br>Cache接口的默认实现<br>（2）NoOpCache<br>测试用</p><ol start="2"><li>CacheManager<br>CacheManager是一个用于管理Cache对象的集合。SpringCache提供了四种CacheManager的实现。<br><img src="/.tech//cacheManager.jpg" alt="CacheManager继承图"><br>(1)SimpleCacheManager<br>简单的CacheManager实现。主要用于测试<br>(2)NoOpCacheManager<br>测试用的CacherManager<br>(3)CompositeCacheManager<br>组合CacheManager, 可以集成多种CacheManager实例，支持多种缓存容器<br>(4)ConcurentMapCacheManager<br>SpringCache默认的CacheManager实现。使用ConcurrentMap作为缓存技术。</li></ol><p>这里就SpringCache提供了默认的缓存容器实现方案(ConcurentMapCacheManager)做一个源码分析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentMapCacheManager</span> <span class="keyword">implements</span> <span class="title">CacheManager</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认创建大小为16的ConcurrentMap来存储Cache对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Cache&gt; cacheMap = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//是否可以动态创建缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> dynamic = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//是否允许存null值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowNullValues = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> storeByValue = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> SerializationDelegate serialization;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentMapCacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentMapCacheManager</span><span class="params">(String... cacheNames)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setCacheNames(Arrays.asList(cacheNames));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化Cache,初始化过后，dynamic设置为false,不会再动态创建Cache.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCacheNames</span><span class="params">(@Nullable Collection&lt;String&gt; cacheNames)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var2 = cacheNames.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                String name = (String)var2.next();</span><br><span class="line">                <span class="keyword">this</span>.cacheMap.put(name, <span class="keyword">this</span>.createConcurrentMapCache(name));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.dynamic = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.dynamic = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowNullValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.allowNullValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据name获取Cache实例，如果Cache实例不存在，则动态创建一个缓存Cache实例。</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cache <span class="title">getCache</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Cache cache = (Cache)<span class="keyword">this</span>.cacheMap.get(name);</span><br><span class="line">        <span class="comment">//如果初始化过Cache,则getCache的时候不会动态创建Cache.</span></span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.dynamic) &#123;</span><br><span class="line">            ConcurrentMap var3 = <span class="keyword">this</span>.cacheMap;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.cacheMap) &#123;</span><br><span class="line">                cache = (Cache)<span class="keyword">this</span>.cacheMap.get(name);</span><br><span class="line">                <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cache = <span class="keyword">this</span>.createConcurrentMapCache(name);</span><br><span class="line">                    <span class="keyword">this</span>.cacheMap.put(name, cache);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建ConcurrentMapCache对象</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Cache <span class="title">createConcurrentMapCache</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        SerializationDelegate actualSerialization = <span class="keyword">this</span>.isStoreByValue() ? <span class="keyword">this</span>.serialization : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentMapCache(name, <span class="keyword">new</span> ConcurrentHashMap(<span class="number">256</span>), <span class="keyword">this</span>.isAllowNullValues(), actualSerialization);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Cache接口提供了缓存操作的基础操作(增、删、改、查),CacheManager提供了集中管理Cache对象的功能。两个接口一起提供了缓存操作的基本功能。同时这两个接口也是SpringCache对外提供的扩展点。可以根据需要去扩展想要的缓存对象(Cache)和缓存管理器(CacheManager),假如想用Redis作为缓存容器，则可以自定义RedisCache和RedisCacheManager。</p><h3 id="SpringCache核心注解"><a href="#SpringCache核心注解" class="headerlink" title="SpringCache核心注解"></a>SpringCache核心注解</h3><p>SpringCache提供了几个缓存操作的核心注解</p><ol><li>@Cacheable<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可作用于类和方法</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Cacheable &#123;</span><br><span class="line">    <span class="comment">//cache的名称</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"cacheNames"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//cache的名称</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] cacheNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//缓存值的key,使用SPEL手动指定缓存键的组合方式，默认情况是使用所有参数来组合缓存键</span></span><br><span class="line">    <span class="comment">// #root.method：用于获取当前方法的Method实例</span></span><br><span class="line">    <span class="comment">// #root.target：用于获取当前方法的target实例</span></span><br><span class="line">    <span class="comment">// #root.caches：用于获取当前方法关联的缓存</span></span><br><span class="line">    <span class="comment">// #root.methodName：用于获取当前方法的名称</span></span><br><span class="line">    <span class="comment">// #root.targetClass：用于获取目标类类型</span></span><br><span class="line">    <span class="comment">// #root.args[1]：获取当前方法的第二个参数，等同于：#p1和#a1和#argumentName</span></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//缓存键生成器,功能与key()具有排他性。keyGenerator是一个函数接口，可以通过自定义逻辑来实现key的生成策略</span></span><br><span class="line">    <span class="function">String <span class="title">keyGenerator</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//设置自定义的缓存管理器，与缓存解析器具有排他性</span></span><br><span class="line">    <span class="function">String <span class="title">cacheManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//设置自定义的缓存解析器</span></span><br><span class="line">    <span class="function">String <span class="title">cacheResolver</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//执行缓存的条件，条件不满足就不会执行缓存操作</span></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//禁止缓存功能，设置的条件满足的话</span></span><br><span class="line">    <span class="function">String <span class="title">unless</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//设置是否对多个针对同一key执行缓存加载的操作的线程进行同步</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sync</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>作用：</p><ul><li>直接从缓存中拿数据，如果缓存未命中，则执行方法，将方法返回的结果存入缓存。</li><li>@Cacheable可以作用在类上，表示类中的所有方法都使用了@Cacheable。</li></ul><ol start="2"><li>@CachePut<br>@CachePut参数含义与@Cacheable一样<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CachePut &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"cacheNames"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] cacheNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">keyGenerator</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">cacheManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">cacheResolver</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">unless</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>作用：<br>作用与@Cacheable保持一致</p><ol start="3"><li>@CacheEvict<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheEvict &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"cacheNames"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] cacheNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">keyGenerator</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">cacheManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">cacheResolver</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//指定当前缓存名称下的所有缓存是否全部删除。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allEntries</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="comment">//指定删除缓存的操作在方法调用前还是调用后执行，默认False,先用调用方法，后执行缓存删除。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">beforeInvocation</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>作用</p><ul><li>从缓存中删除数据</li><li>allEntries来指定是否删除CacheName中的所有缓存数据</li><li>beforeInvocation表示缓存操作的执行顺序</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring Cache提供了基础且核心的接口和注解，使我们能够更加便捷的操作缓存<br>但是我们不禁有个疑问?这些缓存接口和注解是如何作用到我们的方法上的。我们是如何获取到注解信息并通过这些信息指导缓存操作的？下一篇就聊一聊缓存注解的解析和应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Spring提供了一种基于注解（annotation）的缓存技术，他并不是具体的缓存使用方案，而是一个对缓存使用的抽象方
      
    
    </summary>
    
      <category term="Spring" scheme="https://shawnyou.tech/categories/Spring/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码|初识AutoProxyRegistrar</title>
    <link href="https://shawnyou.tech/2019/06/24/Spring-boot/%E5%88%9D%E8%AF%86AutoProxyRegistrar/"/>
    <id>https://shawnyou.tech/2019/06/24/Spring-boot/初识AutoProxyRegistrar/</id>
    <published>2019-06-24T14:51:50.000Z</published>
    <updated>2019-06-27T13:37:13.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AutoProxyRegistrar源码分析"><a href="#AutoProxyRegistrar源码分析" class="headerlink" title="AutoProxyRegistrar源码分析"></a>AutoProxyRegistrar源码分析</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;AutoProxyRegistrar源码分析&quot;&gt;&lt;a href=&quot;#AutoProxyRegistrar源码分析&quot; class=&quot;headerlink&quot; title=&quot;AutoProxyRegistrar源码分析&quot;&gt;&lt;/a&gt;AutoProxyRegistrar源码
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://shawnyou.tech/categories/SpringBoot/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源碼|@EnbaleXxx的实现原理</title>
    <link href="https://shawnyou.tech/2019/06/16/Spring-boot/@Enable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://shawnyou.tech/2019/06/16/Spring-boot/@Enable源码解析/</id>
    <published>2019-06-16T06:55:37.000Z</published>
    <updated>2019-06-26T13:35:22.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-EnableXxx实现原理解析"><a href="#1-EnableXxx实现原理解析" class="headerlink" title="1.EnableXxx实现原理解析"></a>1.EnableXxx实现原理解析</h3><blockquote><p>Spring Boot的核心作用在于他具有强大的自动配置的功能，在Spring框架的基础上利用约定大于配置减少了Spring开发中配置复杂等问题。Spring Boot提供了很多类似于@EnableXXX的注解，这些注解有什么用呢？解决了Spring Boot什么问题？ 接下来我们通过源码来学习一下关@EnableXXX相关注解。</p></blockquote><h4 id="1-1常见的-Enable注解"><a href="#1-1常见的-Enable注解" class="headerlink" title="1.1常见的@Enable注解"></a>1.1常见的@Enable注解</h4><ul><li>@EnableCaching</li><li>@EnableAsync</li><li>@EnbaleJpaRepositories</li><li>@EnableAutoConfiguration</li></ul><h4 id="1-2-EnableXxxx源码入口"><a href="#1-2-EnableXxxx源码入口" class="headerlink" title="1.2 @EnableXxxx源码入口"></a>1.2 @EnableXxxx源码入口</h4><p>本文主要以@EnableCaching作为核心来讲解一下SpringBoot关于@EnbaleXXX注解实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;CachingConfigurationSelector.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCaching &#123;</span><br><span class="line">    <span class="comment">//动态代理的两种实现方式（JDK动态代理或者CGLIB）,默认使用JDK动态代理</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理实现的两种方式（AspectJ或者动态代理），默认使用动态代理</span></span><br><span class="line">    <span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 2147483647</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableCaching是Spring Cache的入口，开启了注解式的缓存支持。</p><ol><li>设置动态代理的实现方式，默认采用JDK动态代理。</li><li>默认采用动态代理的方式实现代理</li><li>通过@Import注解导入了一个CachingConfigurationSelector配置类。</li></ol><p>关于@Import，可以参照博客<a href="http://shawnyou.tech/2019/06/15/Spring-boot/@Import%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">@Import注解</a><br>接下来根据@Import导入的CachingConfigurationSelector类进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableCaching</span>&gt; </span>&#123;</span><br><span class="line">    、、、、只保留关键代码</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据@EnableCaching注解的信息确定需要导入容器的Bean的类名</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">null</span>.$SwitchMap$org$springframework$context$annotation$AdviceMode[adviceMode.ordinal()]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getProxyImports();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getAspectJImports();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取动态代理的配置Bean.</span></span><br><span class="line">    <span class="keyword">private</span> String[] getProxyImports() &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList(<span class="number">3</span>);</span><br><span class="line">        result.add(AutoProxyRegistrar.class.getName());</span><br><span class="line">        result.add(ProxyCachingConfiguration.class.getName());</span><br><span class="line">        <span class="keyword">if</span>(jsr107Present &amp;&amp; jcacheImplPresent) &#123;</span><br><span class="line">            result.add(<span class="string">"org.springframework.cache.jcache.config.ProxyJCacheConfiguration"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于AspectJ代理模式，不作分析</span></span><br><span class="line">    <span class="keyword">private</span> String[] getAspectJImports() &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList(<span class="number">2</span>);</span><br><span class="line">        result.add(<span class="string">"org.springframework.cache.aspectj.AspectJCachingConfiguration"</span>);</span><br><span class="line">        <span class="keyword">if</span>(jsr107Present &amp;&amp; jcacheImplPresent) &#123;</span><br><span class="line">            result.add(<span class="string">"org.springframework.cache.aspectj.AspectJJCacheConfiguration"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">    &#125;</span><br><span class="line">    、、、只保留关键代码、</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，CachingConfigurationSelector的父类AdviceModeImportSelector实现了ImportSelector接口，导入两个关键的动态代理配置类。</p><ol><li>AutoProxyRegistrar<br>AutoProxyRegistrar就是一个自动代理注册器，他负责给容器注册了一个InfrastructureAdvisorAutoProxyCreator，他就是一个后置增强处理器，负责在Bean初始化后通过动态代理生成代理对象，关于AutoProxyRegistrar的解析，这里有专门的博客对AutoProxyRegistrar创建代理的过程进行阐述。</li><li>ProxyCachingConfiguration <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCachingConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractCachingConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyCachingConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(</span><br><span class="line">        name = &#123;<span class="string">"org.springframework.cache.config.internalCacheAdvisor"</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanFactoryCacheOperationSourceAdvisor <span class="title">cacheAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanFactoryCacheOperationSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryCacheOperationSourceAdvisor();</span><br><span class="line">        advisor.setCacheOperationSource(<span class="keyword">this</span>.cacheOperationSource());</span><br><span class="line">        advisor.setAdvice(<span class="keyword">this</span>.cacheInterceptor());</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.enableCaching != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisor.setOrder(((Integer)<span class="keyword">this</span>.enableCaching.getNumber(<span class="string">"order"</span>)).intValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheOperationSource <span class="title">cacheOperationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationCacheOperationSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheInterceptor <span class="title">cacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CacheInterceptor interceptor = <span class="keyword">new</span> CacheInterceptor();</span><br><span class="line">        interceptor.configure(<span class="keyword">this</span>.errorHandler, <span class="keyword">this</span>.keyGenerator, <span class="keyword">this</span>.cacheResolver, <span class="keyword">this</span>.cacheManager);</span><br><span class="line">        interceptor.setCacheOperationSource(<span class="keyword">this</span>.cacheOperationSource());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>ProxyCachingConfiguration向容器中注入了三个Bean，一起组装了一个BeanFactoryCacheOperationSourceAdvisor，它是一个PointAdvisor(切面),整合了PointCut(切点)和Advice(通知)两个模块，确定了在什么方法上(PointCut)执行什么样的缓存操作(Advice)。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>@Enable通过@Import注解能够将指定的配置文件或者Bean装配到Spring容器中，完成自动装配的功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-EnableXxx实现原理解析&quot;&gt;&lt;a href=&quot;#1-EnableXxx实现原理解析&quot; class=&quot;headerlink&quot; title=&quot;1.EnableXxx实现原理解析&quot;&gt;&lt;/a&gt;1.EnableXxx实现原理解析&lt;/h3&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://shawnyou.tech/categories/SpringBoot/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源碼|深入理解@Import注解</title>
    <link href="https://shawnyou.tech/2019/06/15/Spring-boot/@Import%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://shawnyou.tech/2019/06/15/Spring-boot/@Import源码解析/</id>
    <published>2019-06-15T06:55:37.000Z</published>
    <updated>2019-06-25T15:04:47.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深入理解-Import注解"><a href="#深入理解-Import注解" class="headerlink" title="深入理解@Import注解"></a>深入理解@Import注解</h3><blockquote><p>查看SpringBoot相关组件的源码，会发现有很多地方运用了@Import注解，这个注解有什么用呢，工作原理是什么，我们可以利用这个@Import来做什么？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Import的使用方式"><a href="#Import的使用方式" class="headerlink" title="@Import的使用方式"></a>@Import的使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        ServiceImpl service = applicationContext.getBean(ServiceImpl.class);</span><br><span class="line">        Assert.notNull(service,<span class="string">"service has inject successful"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><p>通过@Import将Class加载到AppConfig类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(value = ServiceImpl.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata var1, BeanDefinitionRegistry var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义BeanDefinitionRegistrar的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceImpl.class);</span><br><span class="line">        <span class="comment">//BeanDefinitionRegistry将生成的BeanDefinition注册到容器中去</span></span><br><span class="line">        beanDefinitionRegistry.registerBeanDefinition(<span class="string">"service"</span>,builder.getBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(value = ServiceBeanDefinitionRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过ImportBeanDefinitionRegistrar实现的Import可以针对Bean注册容器的过程进行自定义"><a href="#通过ImportBeanDefinitionRegistrar实现的Import可以针对Bean注册容器的过程进行自定义" class="headerlink" title="通过ImportBeanDefinitionRegistrar实现的Import可以针对Bean注册容器的过程进行自定义"></a>通过ImportBeanDefinitionRegistrar实现的Import可以针对Bean注册容器的过程进行自定义</h4><h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h3><p>告诉容器需要注入哪些类的类名就可以实现Bean的注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">//annotationMetadata是关于注解的元数据信息,可以根据需要获取注解的信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;ServiceImpl.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(value = ServiceImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总结<br>获取注解元数据信息，返回一组需要注入类的类名，有框架来生成对应的实体类从而注入到容器中去。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;深入理解-Import注解&quot;&gt;&lt;a href=&quot;#深入理解-Import注解&quot; class=&quot;headerlink&quot; title=&quot;深入理解@Import注解&quot;&gt;&lt;/a&gt;深入理解@Import注解&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;查看SpringBoot相
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://shawnyou.tech/categories/SpringBoot/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|如何更好的创建和销毁对象</title>
    <link href="https://shawnyou.tech/2019/04/14/effectiveJava/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <id>https://shawnyou.tech/2019/04/14/effectiveJava/创建对象/</id>
    <published>2019-04-14T06:55:37.000Z</published>
    <updated>2019-04-17T14:46:10.930Z</updated>
    
    <content type="html"><![CDATA[<h3 id="静态工厂方法代替构造器"><a href="#静态工厂方法代替构造器" class="headerlink" title="静态工厂方法代替构造器"></a>静态工厂方法代替构造器</h3><h4 id="静态工厂方法的几大优势"><a href="#静态工厂方法的几大优势" class="headerlink" title="静态工厂方法的几大优势"></a>静态工厂方法的几大优势</h4><ol><li><p>静态工厂方法有名称，易于区分。</p></li><li><p>避免不必要的重复对象的创建工作</p></li></ol><p>不必每次调用都创建一个新的对象，可以将构建好的实例缓存起来重复使用</p><ol start="3"><li>可以返回原返回类型的任何子类型</li></ol><p>返回对象有了更大的灵活性</p><ol start="4"><li><p>返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值</p></li><li><p>方法返回对象所属的类，在编写包含静态工厂方法的类时可以不存在</p></li></ol><h4 id="静态工厂方法的几个缺点"><a href="#静态工厂方法的几个缺点" class="headerlink" title="静态工厂方法的几个缺点"></a>静态工厂方法的几个缺点</h4><ul><li>类如果不含公有的或者受保护的构造器，就不能被子类化</li><li>不易发现</li></ul><h3 id="遇到多个参数时要使用构建器"><a href="#遇到多个参数时要使用构建器" class="headerlink" title="遇到多个参数时要使用构建器"></a>遇到多个参数时要使用构建器</h3><h4 id="当构造器扩展到大量的可选参数时，静态工厂和构造器就显得相当局限了。目前用的比较多的是重叠构造器"><a href="#当构造器扩展到大量的可选参数时，静态工厂和构造器就显得相当局限了。目前用的比较多的是重叠构造器" class="headerlink" title="当构造器扩展到大量的可选参数时，静态工厂和构造器就显得相当局限了。目前用的比较多的是重叠构造器"></a>当构造器扩展到大量的可选参数时，静态工厂和构造器就显得相当局限了。目前用的比较多的是重叠构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts(<span class="number">240</span>,<span class="number">8</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">35</span>,<span class="number">27</span>);</span><br></pre></td></tr></table></figure><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>可读性比较差</li><li>容易出错,如参数位置弄错位置</li></ul><h4 id="使用setter方案"><a href="#使用setter方案" class="headerlink" title="使用setter方案"></a>使用setter方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servingSize = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servings = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServingSize</span><span class="params">(<span class="keyword">int</span> servingSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServings</span><span class="params">(<span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servings = servings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCalories</span><span class="params">(<span class="keyword">int</span> calories)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calories = calories;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFat</span><span class="params">(<span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fat = fat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSodium</span><span class="params">(<span class="keyword">int</span> sodium)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sodium = sodium;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCarbohydrate</span><span class="params">(<span class="keyword">int</span> carbohydrate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NutritionFacts nutritionFacts = <span class="keyword">new</span> NutritionFacts();</span><br><span class="line">nutritionFacts.setServingSize(<span class="number">240</span>);</span><br><span class="line">nutritionFacts.setServings(<span class="number">100</span>);</span><br><span class="line">nutritionFacts.setSodium(<span class="number">35</span>);</span><br><span class="line">nutritionFacts.setCarbohydrate(<span class="number">27</span>);</span><br><span class="line">nutritionFacts.setCalories(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li>可读性增强</li><li>一致性的问题(不安全)</li></ul><h4 id="构建器"><a href="#构建器" class="headerlink" title="构建器"></a>构建器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servingSize = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servings = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servingSize = builder.servingSize;</span><br><span class="line">        <span class="keyword">this</span>.servings = builder.servings;</span><br><span class="line">        <span class="keyword">this</span>.calories = builder.calories;</span><br><span class="line">        <span class="keyword">this</span>.fat = builder.fat;</span><br><span class="line">        <span class="keyword">this</span>.sodium = builder.sodium;</span><br><span class="line">        <span class="keyword">this</span>.carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.calories = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.fat = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sodium = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.carbohydrate = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NutritionFacts nutritionFacts = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>,<span class="number">8</span>).calories(<span class="number">100</span>)</span><br><span class="line">                .sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直观、易于阅读(优点)</li><li>在注重性能的情况下，创建构建起是个问题(缺点)</li><li>最好一开始就用构建器(建议)</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式是个不错的选择</p><h3 id="私有构造器或者枚举类型强化Singleton属性"><a href="#私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="私有构造器或者枚举类型强化Singleton属性"></a>私有构造器或者枚举类型强化Singleton属性</h3><p>Singleton:仅仅被实例化一次的类</p><h4 id="Singleton的两种实现"><a href="#Singleton的两种实现" class="headerlink" title="Singleton的两种实现"></a>Singleton的两种实现</h4><h5 id="单例模式的实现（一）"><a href="#单例模式的实现（一）" class="headerlink" title="单例模式的实现（一）"></a>单例模式的实现（一）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis instance = <span class="keyword">new</span> Elvis();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>私有构造器只调用一次，用来实例化公有的静态final域(instance)</li><li>没有public或者protect的构造器，保证了instance的唯一性</li><li>但是可以通过反射的方式调用私有构造器(可以修改构造器在创建第二次实例时抛出异常)</li></ul><h5 id="单例模式的实现（二）"><a href="#单例模式的实现（二）" class="headerlink" title="单例模式的实现（二）"></a>单例模式的实现（二）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis instance = <span class="keyword">new</span> Elvis();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>添加了一个静态工厂方法，静态工厂方法的调用每次都返回同一个对象引用</li><li>公有的静态域是final的，该域总是包含相同的对象引用。公有域方法在性能上不会有任何优势，现在JVM实现能够将静态工厂方法的调用内联化。(内联：函数被调用的地方直接展开，编译器在调用时不会像一般函数那样，参数压栈，返回时参数出栈以及释放资源，直接提高程序的执行速度)</li></ul><h6 id="Singleton可序列化问题"><a href="#Singleton可序列化问题" class="headerlink" title="Singleton可序列化问题"></a>Singleton可序列化问题</h6><p>Singleton仅仅在声明中加上implement Serializable是不够的，必须所有的实例都是瞬时的，并提供一个readResolve方法，否则每次反序列化都会创建一个新的实例</p><h4 id="单例模式的实现（三）—-通过枚举类型实现"><a href="#单例模式的实现（三）—-通过枚举类型实现" class="headerlink" title="单例模式的实现（三）— 通过枚举类型实现"></a>单例模式的实现（三）— 通过枚举类型实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Elvis &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    public void doSomething()&#123;</span><br><span class="line">        System.out.println(&quot;do something&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>简洁</li><li>无偿提供了序列化机制，防止多次实例化</li><li>单元素的枚举类型是实现Singleton的最佳方法</li></ul><h3 id="使用依赖注入来引用资源"><a href="#使用依赖注入来引用资源" class="headerlink" title="使用依赖注入来引用资源"></a>使用依赖注入来引用资源</h3><p>静态工具类引用底层资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dictionary DICTIONARY = <span class="keyword">new</span> Dictionary();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Singleton引用底层资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary = <span class="keyword">new</span> Dictionary();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上引入资源的两种形式都不太好。因为没法支持多种词典。所以静态资源类和Singleton类不适合作需要引用底层资源的类。</p><p>所以使用依赖注入来引入底层资源，当创建一个新的实例时，将该资源传到构造器中去。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Dictionary dictionary)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = dictionary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="依赖注入的变体形式"><a href="#依赖注入的变体形式" class="headerlink" title="依赖注入的变体形式"></a>依赖注入的变体形式</h4><p>将资源工厂传给构造器</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>不要使用Singleton和静态工具类来实现依赖一个或者多个底层资源的类</li><li>尽量将资源或者创建资源的工厂传给构造器，（或者工厂方法、builder）,这样会增加类的灵活性、重用性和可测试性</li></ul><h3 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><p>最好重用对象而不是每次需要的时候创建一个相同功能的新对象，这样可以提高性能，缩短响应时间。</p><h4 id="String创建的案例"><a href="#String创建的案例" class="headerlink" title="String创建的案例"></a>String创建的案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">String s = <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure><p>第一个语句： 每次执行都会创建新的String实例，这些创建的对象都是不必要的。如果用在一个频繁调用的方法中，就回创建成千上万不必要的String实例。</p><p>第二个语句： 对于所有在同一台虚拟机运行的代码，只要它们包含相同的字符串字面常量，该对象就会被重用。</p><ul><li>java会在方法区运行时常量池保存”test”,当下次调用String = “test”,java会直接返回这个对象的引用，而不会重新创建对象，由此节省了内存开销，可以放心在循环中使用</li><li>String s = new String(“test”)实际创建了两个对象，一个对象在堆中，一个保存在常量池</li></ul><h4 id="优先使用静态工厂方法而不是构造器来创建对象"><a href="#优先使用静态工厂方法而不是构造器来创建对象" class="headerlink" title="优先使用静态工厂方法而不是构造器来创建对象"></a>优先使用静态工厂方法而不是构造器来创建对象</h4><ul><li>构造器每次调用都会创建新对象，而静态工厂方法不会这样，静态工厂方法可以重用对象，也可以加缓存</li><li>如果反复需要一些创建成本比较高的对象，建议缓存下来重用。</li></ul><h4 id="不要创建多个适配器"><a href="#不要创建多个适配器" class="headerlink" title="不要创建多个适配器"></a>不要创建多个适配器</h4><p>如果对象是可以变化的，也可以实现重用</p><p>适配器：把功能委托给一个后备对象，从而为后备对象提供一个可以替代的接口，适配器除了后备对象，没有其他任何信息。</p><ul><li>Map接口的keyset()返回Map对象的Set视图，包含Map的所有键</li><li>每次调用都返回Map对象锁对应的Set实例，即便Map内容会有所变化，也能反映到Set实例中。</li></ul><p>所以没有必要创建多个Set实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> AbstractSet&lt;K&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;K&gt;() &#123;</span><br><span class="line">                        <span class="keyword">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> i.hasNext();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> i.next().getKey();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            i.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.size();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    AbstractMap.<span class="keyword">this</span>.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.containsKey(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="避免自动装箱造成重复对象的创建"><a href="#避免自动装箱造成重复对象的创建" class="headerlink" title="避免自动装箱造成重复对象的创建"></a>避免自动装箱造成重复对象的创建</h4><p>自动装箱会导致多余对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>;i&lt;=Integer.MAX_VALUE;i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>声明的变量是Long而不是long,所以每一次循环都会构造多余的Long实例， 所以要优先使用基本类型而不是装箱基本类型，当心无意识的自动装箱。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>通过维护对象池来避免创建对象也不是好事情，除非对象池中的对象是非常重要的对象。</li><li>维护对象池会把代码弄得很乱，同时增加内存占用，损害性能</li></ul><h3 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h3><p>虽然java帮助我们完成了大部分内存管理的工作，但是我们还不不能对内存管理置之不理。</p><ol><li>Stack引发的内存溢出的问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACOTY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACOTY];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span></span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"no element"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length == size)&#123;</span><br><span class="line">            elements = Arrays.copyOf(elements,<span class="number">2</span>*size+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>栈先增长，后收缩，对于弹出来的对象，栈依旧维护者这些对象的引用，所以这些对象不会被当做垃圾回收</li><li>所以一旦对象引用已经过期，只需清空这些引用就可以了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"no element"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line">        elements[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意点： 清空对象引用是一种例外，而不是一种规范行为，对于栈这种自己管理内存的情况，程序员就应该警惕内存泄露问题。</p><ol start="2"><li>缓存引起的内存泄露</li></ol><p>缓存容易被遗忘，一旦时间长了,日积月累的缓存容易出现内存溢出的情况。</p><ol start="3"><li>监听器和回调造成的内存溢出</li></ol><h3 id="避免使用终结方法"><a href="#避免使用终结方法" class="headerlink" title="避免使用终结方法"></a>避免使用终结方法</h3><h3 id="try-with-resource优先于try-finally"><a href="#try-with-resource优先于try-finally" class="headerlink" title="try-with-resource优先于try-finally"></a>try-with-resource优先于try-finally</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;静态工厂方法代替构造器&quot;&gt;&lt;a href=&quot;#静态工厂方法代替构造器&quot; class=&quot;headerlink&quot; title=&quot;静态工厂方法代替构造器&quot;&gt;&lt;/a&gt;静态工厂方法代替构造器&lt;/h3&gt;&lt;h4 id=&quot;静态工厂方法的几大优势&quot;&gt;&lt;a href=&quot;#静态工厂方法
      
    
    </summary>
    
      <category term="读书笔记(Effective Java)" scheme="https://shawnyou.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Effective-Java/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="https://shawnyou.tech/2019/04/14/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/04/14/适配器模式/</id>
    <published>2019-04-14T01:44:58.000Z</published>
    <updated>2019-11-10T05:13:01.343Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式"></a>什么是适配器模式</h3><blockquote><p>将一个接口变换成客户期待的另一个的接口，从而使原本因接口不匹配无法一起工作的两个类能够一起工作。<br>生活中不乏这样的案例，如电脑的电源适配器，它的作用主要是解决家用电和电脑之间的兼容问题</p></blockquote><p>通过适配器模式可以解决‘现有程序’和‘所需程序’之间的差异，让现有程序和所需程序能够完美的兼容。</p><h3 id="如何做一个将”交流100伏特电压”转换成“直流12伏特电压”的适配器"><a href="#如何做一个将”交流100伏特电压”转换成“直流12伏特电压”的适配器" class="headerlink" title="如何做一个将”交流100伏特电压”转换成“直流12伏特电压”的适配器"></a>如何做一个将”交流100伏特电压”转换成“直流12伏特电压”的适配器</h3><h3 id="适配器模式的两种实现"><a href="#适配器模式的两种实现" class="headerlink" title="适配器模式的两种实现"></a>适配器模式的两种实现</h3><ul><li>类适配器模式(继承）</li><li>对象适配器模式(委托)</li></ul><h4 id="继承适配器模式"><a href="#继承适配器模式" class="headerlink" title="继承适配器模式"></a>继承适配器模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span></span>&#123;</span><br><span class="line">    <span class="comment">//现有的实际情况</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithParen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithAster</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">""</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">    <span class="comment">//需求接口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">extends</span> <span class="title">Banner</span> <span class="keyword">implements</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">    <span class="comment">//适配器类：在实现了现有的需求接口的方法中对原有的功能情况进行包装，以达到适配以前功能的目的。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        showWithParen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>&#123;</span><br><span class="line">        showWithAster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Print p = <span class="keyword">new</span> PringBanner(<span class="string">"hello"</span>);</span><br><span class="line">p.pritWeak();</span><br><span class="line">p.printStrong();</span><br></pre></td></tr></table></figure><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>面向接口编程，客户端代码只需要通过Print接口进行调用，隐藏了方法实现。(连接笔记本电脑的12伏特电压就有可能是由100伏特交流电压通过适配器转换而成的)</li></ul><h4 id="委托适配器模式"><a href="#委托适配器模式" class="headerlink" title="委托适配器模式"></a>委托适配器模式</h4><p>通过委托来实现适配器</p><ul><li>适配器(PrintBanner)通过调用现有需求的方法(Print)来间接调用以前的的功能(Banner)</li><li>Banner通过委托的形式传入到适配器(PrintBanner)中,现有功能(Print)作为抽象类被适配器继承。</li></ul><blockquote><p>Talk is cheap, show me the code</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">publc <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">    <span class="comment">//抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">extends</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过委托的形式将原有功能注入进来，由此虽然调用的是新的功能方法，但实际调用的还是以前的老功能，由此实现了新、老功能之间的适配兼容。</span></span><br><span class="line">    <span class="keyword">private</span> Banner banner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        banner.shouwWithParen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>&#123;</span><br><span class="line">        banner.showWithAster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是适配器模式&quot;&gt;&lt;a href=&quot;#什么是适配器模式&quot; class=&quot;headerlink&quot; title=&quot;什么是适配器模式&quot;&gt;&lt;/a&gt;什么是适配器模式&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;将一个接口变换成客户期待的另一个的接口，从而使原本因接口不匹配无法
      
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://shawnyou.tech/2019/04/13/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/04/13/策略模式/</id>
    <published>2019-04-13T12:44:43.000Z</published>
    <updated>2019-04-14T11:53:15.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><h4 id="一个主题切换案例"><a href="#一个主题切换案例" class="headerlink" title="一个主题切换案例"></a>一个主题切换案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyTheme</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTheme</span> <span class="keyword">implements</span> <span class="title">Theme</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"设置默认主题"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DarkTheme</span> <span class="keyword">implements</span> <span class="title">Theme</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"设置暗黑风格主题"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorfulTheme</span> <span class="keyword">implements</span> <span class="title">Theme</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"设置彩色风格主题"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThemeManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Theme theme;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThemeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.theme = <span class="keyword">new</span> DefaultTheme();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTheme</span><span class="params">(Theme theme)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.theme = theme;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyTheme</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.theme.applyTheme();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThemeManager themeManager = <span class="keyword">new</span> ThemeManager();</span><br><span class="line">        <span class="comment">//设置黑暗风格主题</span></span><br><span class="line">        themeManager.setTheme(<span class="keyword">new</span> DarkTheme());</span><br><span class="line">        themeManager.applyTheme();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主题模式更换的案例中，不同的主题风格就是一个个策略，我们可以根须需要选择不同的策略。</p><h3 id="如何理解策略模式"><a href="#如何理解策略模式" class="headerlink" title="如何理解策略模式"></a>如何理解策略模式</h3><blockquote><p>定义椅子算法，将每个算法都以类的方式凤凰钻起来，并且使他们可以互相交换。</p></blockquote><p>类图（TODO）</p><p>策略模式模型抽象</p><ul><li>Context封装角色</li></ul><p>主题更换案例中的ThemeManager就是一个封装角色，也叫上下文角色，拼比高层对策略的直接访问。</p><ul><li>Strategy抽象策略角色</li></ul><p>定义每个策略必须具有的方法和属性</p><ul><li>ConcreteStrategy具体策略角色</li></ul><p>抽象策略的实现，具体的算法</p><h3 id="策略模式的优点"><a href="#策略模式的优点" class="headerlink" title="策略模式的优点"></a>策略模式的优点</h3><ul><li>算法可以自由切换</li><li>避免了多重条件的判断</li><li>良好的扩展性(符合开闭原则)</li></ul><h3 id="策略模式的缺点"><a href="#策略模式的缺点" class="headerlink" title="策略模式的缺点"></a>策略模式的缺点</h3><ul><li>策略类会逐渐增多(超过四个考虑使用混合模式)</li><li>策略类必须向外暴露(违反迪米特法则) — 上层模块必须知道哪些策略，才能使用哪些策略，可用工厂方法模式修正</li></ul><h3 id="策略模式的具体应用"><a href="#策略模式的具体应用" class="headerlink" title="策略模式的具体应用"></a>策略模式的具体应用</h3><ul><li>Shiro权限控制框架有三种验证策略</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实际案例&quot;&gt;&lt;a href=&quot;#实际案例&quot; class=&quot;headerlink&quot; title=&quot;实际案例&quot;&gt;&lt;/a&gt;实际案例&lt;/h3&gt;&lt;h4 id=&quot;一个主题切换案例&quot;&gt;&lt;a href=&quot;#一个主题切换案例&quot; class=&quot;headerlink&quot; title=&quot;一
      
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>装饰器模式</title>
    <link href="https://shawnyou.tech/2019/04/13/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/04/13/装饰器模式/</id>
    <published>2019-04-13T06:55:37.000Z</published>
    <updated>2019-04-14T11:54:07.979Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个故事"><a href="#一个故事" class="headerlink" title="一个故事"></a>一个故事</h3><p>小明今年买了一个毛坯房，计划六月份装修作为婚房使用。小明选择了自定义的装修方案。线槽、刷漆、家具定制、门窗定制都是由不同的厂家来定制安装。</p><h3 id="通过装饰器模式来模拟装修"><a href="#通过装饰器模式来模拟装修" class="headerlink" title="通过装饰器模式来模拟装修"></a>通过装饰器模式来模拟装修</h3><ul><li>毛坯房是一个被装饰的对象</li><li>线槽、刷漆、家具定制、门窗定制等就是装饰对象，他们负责对毛坯房进行装饰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decorate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoughHouse</span> <span class="keyword">implements</span> <span class="title">House</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"毛坯房要开始装修了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDecorate</span> <span class="keyword">implements</span> <span class="title">House</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> House house;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDecorate</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.house = house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷漆的装饰类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrushingHouseDecorate</span> <span class="keyword">extends</span> <span class="title">HouseDecorate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrushingHouseDecorate</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(house);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.decorate();</span><br><span class="line">        System.out.println(<span class="string">"房屋装修------刷漆"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>家具定制的装饰类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedFurnitureHouseDecorate</span> <span class="keyword">extends</span> <span class="title">HouseDecorate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomizedFurnitureHouseDecorate</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(house);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.decorate();</span><br><span class="line">        System.out.println(<span class="string">"房屋装修------定制家具"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>门窗定制的装饰类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoorWindowHouseDecorate</span> <span class="keyword">extends</span> <span class="title">HouseDecorate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoorWindowHouseDecorate</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(house);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.decorate();</span><br><span class="line">        System.out.println(<span class="string">"房屋装修------门窗定制"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线槽安装的装饰类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrunkingHouseDecorate</span> <span class="keyword">extends</span> <span class="title">HouseDecorate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrunkingHouseDecorate</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(house);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.decorate();</span><br><span class="line">        System.out.println(<span class="string">"房屋装修------安装线槽"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        House house = <span class="keyword">new</span> RoughHouse();</span><br><span class="line"></span><br><span class="line">        house = <span class="keyword">new</span> BrushingHouseDecorate(house);</span><br><span class="line">        house = <span class="keyword">new</span> TrunkingHouseDecorate(house);</span><br><span class="line">        house = <span class="keyword">new</span> CustomizedFurnitureHouseDecorate(house);</span><br><span class="line">        house = <span class="keyword">new</span> DoorWindowHouseDecorate(house);</span><br><span class="line"></span><br><span class="line">        house.decorate();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Result<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">毛坯房要开始装修了</span><br><span class="line">房屋装修------刷漆</span><br><span class="line">房屋装修------安装线槽</span><br><span class="line">房屋装修------定制家具</span><br><span class="line">房屋装修------门窗定制</span><br></pre></td></tr></table></figure></p><h3 id="如何理解装饰器模式"><a href="#如何理解装饰器模式" class="headerlink" title="如何理解装饰器模式"></a>如何理解装饰器模式</h3><blockquote><p>动态的给一个对象添加额外的职责。提供了比集成更有弹性的替代方案</p></blockquote><ul><li>装饰器<br>刷漆装修、安装线槽、定制家具、门窗定制都是属于装饰器。当我们居住一段时间后，想把厕所改造一下，我们只需要再构造一个装饰器，对房屋就是包装装饰就完成了工作，而不需要做过多的改变。</li><li>被装饰对象<br>毛坯房就是属于被装饰对象</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>装饰器与被装饰对象实现同一个接口</li><li>装饰器持有被装饰对象的引用</li><li>可以随意添加装饰器</li></ul><p>看到装饰器模式的前两个特点，我们是不是有种似曾相识的感觉，这不是静态代理的特点吗？装饰器就好比代理类，他持有被代理对象（被装饰对象）的引用，去做被代理对象能做但是不想做的事情。</p><h3 id="装饰器模式与静态代理"><a href="#装饰器模式与静态代理" class="headerlink" title="装饰器模式与静态代理"></a>装饰器模式与静态代理</h3><ol><li>静态代理<br>想做但不能做，需要找一个能干的人帮我做</li><li>装饰器模式<br>我想做，但不能做，需要找各具特色的人来帮我做</li></ol><h4 id="用一个例子来说明"><a href="#用一个例子来说明" class="headerlink" title="用一个例子来说明"></a>用一个例子来说明</h4><p>这是一个代理类的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.before();</span><br><span class="line">        subject.request();</span><br><span class="line">        <span class="keyword">this</span>.after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置处理。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置处理。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们想给主题添加一点操作日志，最简单的方法就是添加一个log();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"添加日志"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于需求，我们是不可控的，未来需求不断的增长，代理类会越来越大，难以维护，而且也不符合开闭原则。</p><h4 id="如何应用"><a href="#如何应用" class="headerlink" title="如何应用"></a>如何应用</h4><ul><li>装饰器模式与静态代理模式都是包装模式，为其添加特定的功能</li><li>功能单一，可以选择代理模式</li><li>功能较多其需要动态扩张海燕，可以选择装饰器模式</li></ul><h3 id="装饰器模式应用场景"><a href="#装饰器模式应用场景" class="headerlink" title="装饰器模式应用场景"></a>装饰器模式应用场景</h3><ul><li>Java IO流<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">while</span> ((str = in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br></pre></td></tr></table></figure></li></ul><p>查看DataInputStream源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> <span class="keyword">implements</span> <span class="title">DataInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a DataInputStream that uses the specified</span></span><br><span class="line"><span class="comment">     * underlying InputStream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  in   the specified input stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The input stream to be filtered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &lt;code&gt;FilterInputStream&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * by assigning the  argument &lt;code&gt;in&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * to the field &lt;code&gt;this.in&lt;/code&gt; so as</span></span><br><span class="line"><span class="comment">     * to remember it for later use.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   in   the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if</span></span><br><span class="line"><span class="comment">     *          this instance is to be created without an underlying stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源代码可以看出</p><ul><li>装饰器<br>FilterInputStream及其子类（DataInputstream）</li><li>被装饰对象<br>InputStream</li></ul><p>由此可以设计出很多具有不同的特性的IO流。</p><h3 id="装饰器模式的优点"><a href="#装饰器模式的优点" class="headerlink" title="装饰器模式的优点"></a>装饰器模式的优点</h3><ul><li>扩展方式了灵活</li><li>每个装饰器互相独立不受影响</li><li>装饰模式是继承的替代方案，能够解决类膨胀的问题，继承是静态增加功能，装饰模式是动态增加功能。不管装饰多少层，返回的还是父类，实现的是is-a的关系。如果需要去掉某个功能，装饰模式去掉封装就可以了，但是继承就必须修改代码。</li><li></li><li>动态扩展装饰器类</li></ul><h3 id="装饰器模式的缺点"><a href="#装饰器模式的缺点" class="headerlink" title="装饰器模式的缺点"></a>装饰器模式的缺点</h3><ul><li>多层装饰比较复杂(类似剥洋葱)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一个故事&quot;&gt;&lt;a href=&quot;#一个故事&quot; class=&quot;headerlink&quot; title=&quot;一个故事&quot;&gt;&lt;/a&gt;一个故事&lt;/h3&gt;&lt;p&gt;小明今年买了一个毛坯房，计划六月份装修作为婚房使用。小明选择了自定义的装修方案。线槽、刷漆、家具定制、门窗定制都是由
      
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="https://shawnyou.tech/2019/04/13/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/04/13/责任链模式/</id>
    <published>2019-04-13T04:36:10.000Z</published>
    <updated>2019-04-14T11:54:33.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个故事"><a href="#一个故事" class="headerlink" title="一个故事"></a>一个故事</h3><blockquote><p>小张需要申请一台显示器，需要在公司内部系统提交审核清单。审核清单的审批流程要经过直属领导、部门领导、资源部领导几个环节审批，其中任何一个环节审核不通过，显示器就申请不下来。</p></blockquote><h3 id="责任链模式来模拟审批流程"><a href="#责任链模式来模拟审批流程" class="headerlink" title="责任链模式来模拟审批流程"></a>责任链模式来模拟审批流程</h3><p>审批流程就像一个链条一样，一级一级审批，直到最后资源部领导核查通过，小张就能拿到想要的显示器了</p><h4 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VerifyHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> VerifyHandler nextVerify;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextVerify</span><span class="params">(VerifyHandler nextVerify)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextVerify = nextVerify;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">examine</span><span class="params">(Request request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextVerify</span><span class="params">(Request request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nextVerify != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.nextVerify.examine(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeamLeaderVerifyHandler</span> <span class="keyword">extends</span> <span class="title">VerifyHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">examine</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        System.out.println(request.getRequest());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"直属领导审批通过"</span>);</span><br><span class="line"></span><br><span class="line">        nextVerify(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApartmentVerifyHandler</span> <span class="keyword">extends</span> <span class="title">VerifyHandler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">examine</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"部门领导审批通过"</span>);</span><br><span class="line"></span><br><span class="line">        nextVerify(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceVerifyHandler</span> <span class="keyword">extends</span> <span class="title">VerifyHandler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">examine</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"资源部领导审批通过"</span>);</span><br><span class="line">        System.out.println(<span class="string">"发放显示器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String request;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(String request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TeamLeaderVerifyHandler teamLeaderVerifyHandler = <span class="keyword">new</span> TeamLeaderVerifyHandler();</span><br><span class="line">        ApartmentVerifyHandler apartmentVerifyHandler = <span class="keyword">new</span> ApartmentVerifyHandler();</span><br><span class="line">        ResourceVerifyHandler resourceVerifyHandler = <span class="keyword">new</span> ResourceVerifyHandler();</span><br><span class="line"></span><br><span class="line">        teamLeaderVerifyHandler.setNextVerify(apartmentVerifyHandler);</span><br><span class="line">        apartmentVerifyHandler.setNextVerify(resourceVerifyHandler);</span><br><span class="line"></span><br><span class="line">        Request request = <span class="keyword">new</span> Request(<span class="string">"申请一条显示器"</span>);</span><br><span class="line">        teamLeaderVerifyHandler.examine(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何理解责任链模式"><a href="#如何理解责任链模式" class="headerlink" title="如何理解责任链模式"></a>如何理解责任链模式</h3><blockquote><p>使多个对象都有机会处理请求，从未避免了发送者与接收者之间的耦合关系，将这些对象连成一个链条，沿着链条传递请求。其结构和链表是类似的。</p></blockquote><p>当有审批流程进入时，先经过直属领导审批，待直属领导审批通过后，再把审批请求传递给部门领导，部门领导审批过后再传递给资源部领导，由此类推，形成一个链条，链条上的每个对象的职责各不相同。</p><h3 id="责任链模式模型抽象"><a href="#责任链模式模型抽象" class="headerlink" title="责任链模式模型抽象"></a>责任链模式模型抽象</h3><p>类图（TODO）</p><h3 id="责任链模式的应用"><a href="#责任链模式的应用" class="headerlink" title="责任链模式的应用"></a>责任链模式的应用</h3><ul><li>过滤器</li><li>拦截器</li></ul><h3 id="责任链模式的优点"><a href="#责任链模式的优点" class="headerlink" title="责任链模式的优点"></a>责任链模式的优点</h3><ul><li>请求者与接收者之间解耦</li><li>符合开闭原则，易于扩展</li></ul><h3 id="责任链模式的缺点"><a href="#责任链模式的缺点" class="headerlink" title="责任链模式的缺点"></a>责任链模式的缺点</h3><ul><li>性能问题。链表较长的时候会有性能问题（应该设置节点阈值）</li><li>调试逻辑比较复杂（调用者不知道被哪些接受者调用）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一个故事&quot;&gt;&lt;a href=&quot;#一个故事&quot; class=&quot;headerlink&quot; title=&quot;一个故事&quot;&gt;&lt;/a&gt;一个故事&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;小张需要申请一台显示器，需要在公司内部系统提交审核清单。审核清单的审批流程要经过直属领导、部门领导
      
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="https://shawnyou.tech/2019/04/09/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/04/09/命令模式/</id>
    <published>2019-04-09T13:34:52.000Z</published>
    <updated>2019-04-14T14:13:44.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是命令模式"><a href="#什么是命令模式" class="headerlink" title="什么是命令模式"></a>什么是命令模式</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是命令模式&quot;&gt;&lt;a href=&quot;#什么是命令模式&quot; class=&quot;headerlink&quot; title=&quot;什么是命令模式&quot;&gt;&lt;/a&gt;什么是命令模式&lt;/h3&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://shawnyou.tech/2019/04/06/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/04/06/原型模式/</id>
    <published>2019-04-06T10:26:01.000Z</published>
    <updated>2019-04-14T14:14:12.187Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://posw9yxeh.bkt.clouddn.com/images/common/gratisography-307-thumbnail-small.jpg" alt><br><a id="more"></a><br>关于克隆，我们会想到《西游记》里面孙悟空的猴毛分身，也会想到《火影忍者》里面的影分身之术。他们都是用一个物体复制若干个一模一样的物体。在面向对象的系统中，我们也可以通过克隆来复制一些对象—也就是我们所说的原型模式</p><blockquote><p>用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象，也就是利用一个原型对象来指明我们要创建对象的类型，然后通过复制这个对象来获取一模一样的对象实例</p></blockquote><h3 id="一个简单的原型模式Demo"><a href="#一个简单的原型模式Demo" class="headerlink" title="一个简单的原型模式Demo"></a>一个简单的原型模式Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeClass</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PrototypeClass <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PrototypeClass prototypeClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prototypeClass = (PrototypeClass)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (CloneNotSupportedException e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prototypeClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现Cloneable接口，在JVM中只有具有这个标记的对象才有可能被拷贝</li><li>重写覆盖Clone()方法</li></ul><h3 id="为什么要用原型模式"><a href="#为什么要用原型模式" class="headerlink" title="为什么要用原型模式"></a>为什么要用原型模式</h3><ul><li>性能优良。 原型模式是在内存二进制流的拷贝，比直接new一个对象性能要好得多。所以特别是要在一个循环体内产生大量对象的时候，原型模式更好体现其优点</li><li>避开构造函数的束缚（既是优点也是缺点）<br>直接在内存中拷贝，构造函数是不会执行的</li></ul><h3 id="原型模式应用场景"><a href="#原型模式应用场景" class="headerlink" title="原型模式应用场景"></a>原型模式应用场景</h3><ol><li>资源优化场景</li><li>性能和安全要求场景</li><li>一个对象多个修改者的场景</li></ol><h3 id="两种拷贝方式"><a href="#两种拷贝方式" class="headerlink" title="两种拷贝方式"></a>两种拷贝方式</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>只拷贝本对象，对象内部的数组、引用对象都不拷贝，还是指向原生对象的内部元素地址。原始类型（int、long、char）以及String都会被拷贝</p><h5 id="如何才能保证成员变量不被拷贝（保证以下两个条件）"><a href="#如何才能保证成员变量不被拷贝（保证以下两个条件）" class="headerlink" title="如何才能保证成员变量不被拷贝（保证以下两个条件）"></a>如何才能保证成员变量不被拷贝（保证以下两个条件）</h5><ul><li>必须是类的成员变量，而不是方法内变量</li><li>必须是一个可变的引用对象，而不是一个原始类型或者不可变对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thing</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Thing <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thing thing = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thing = (Thing)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (CloneNotSupportedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> thing;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浅克隆是不安全的方式，两个对象共享了一个私有变量，大家都能够进行修改。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepThing</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DeepThing <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DeepThing thing = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thing = (DeepThing)<span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="keyword">this</span>.list = (ArrayList&lt;String&gt;)<span class="keyword">this</span>.list.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (CloneNotSupportedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> thing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.add(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>原型模式向客户隐藏了创建对象的复杂性，客户只需要知道创建对象类型，就可以获得对象一模一样的新对象。</li><li>有两种克隆方式：深克隆、浅克隆<ul><li>浅克隆；不安全，对象公有私有变量</li><li>有时对象的复制可能会比较复杂</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://posw9yxeh.bkt.clouddn.com/images/common/gratisography-307-thumbnail-small.jpg&quot; alt&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="https://shawnyou.tech/2019/04/05/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/04/05/中介者模式/</id>
    <published>2019-04-05T01:13:59.000Z</published>
    <updated>2019-04-14T14:13:31.240Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://posw9yxeh.bkt.clouddn.com/images/common/gratisography-157-thumbnail-small.jpg" alt><br><a id="more"></a></p><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><h4 id="如何理解中介者模式"><a href="#如何理解中介者模式" class="headerlink" title="如何理解中介者模式"></a>如何理解中介者模式</h4><p>复杂的进销存系统类图</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><ul><li>虽然不同类型的参与者完成各自的活动，但是每个类相互关联耦合</li><li>每个类与多个朋友类相互交互，朋友类越多，耦合性越大，要修改一个，就得修改一大片— 违反迪米特法则</li><li>不同参与者之间交互过于复杂，维护比较困难</li></ul><p>使用一个中介者对象，他将各个对象之间的交互封装起来作为一个中间桥梁，降低各个参与者的耦合性。</p><h4 id="中介者类图"><a href="#中介者类图" class="headerlink" title="中介者类图"></a>中介者类图</h4><ul><li>每个参与者只负责自己的业务逻辑，不属于自己的交给中介者去处理</li><li>每个参与者不再交互交流，简化了各模块间的耦合性</li></ul><ol><li>抽象中介者类</li></ol><p>定义统一的接口，用于各个参与者角色之间的通信<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ConcreteColleagueA concreteColleagueA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ConcreteColleagueB concreteColleagueB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mediator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        concreteColleagueA = <span class="keyword">new</span> ConcreteColleagueA(<span class="keyword">this</span>);</span><br><span class="line">        concreteColleagueB = <span class="keyword">new</span> ConcreteColleagueB(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomethingA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomethingB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Q:为什么使用参与类实现类注入，而不使用抽象类注入(接口注入)</span><br><span class="line">A:因为每个参与类没有必须要完成的业务方法(没有相同的方法), 假如有相同的方法，当然要注入抽象类做到依赖倒置。</span><br></pre></td></tr></table></figure></p><ol start="2"><li>抽象参与者类</li></ol><p>每一个参与者必须知道中介者角色，所以通过构造函数传入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>具体中介者类</li></ol><p>协调各个参与者实现协作工作行为，要依赖各个参与者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.concreteColleagueA.selfMethod();</span><br><span class="line">        <span class="keyword">super</span>.concreteColleagueB.selfMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.concreteColleagueA.selfMethod();</span><br><span class="line">        <span class="keyword">super</span>.concreteColleagueB.selfMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>具体参与者类A</li></ol><ul><li>自身的行为selfMethod,用于处理自身的业务逻辑</li><li>依赖的行为depMethod,依靠中介者去完成<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleagueA</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleagueA</span><span class="params">(Mediator mediator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//自己的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//不能处理的业务逻辑，交给中介者处理</span></span><br><span class="line">        <span class="keyword">super</span>.mediator.doSomethingA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="5"><li><p>具体参与者类B</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleagueB</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleagueB</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//自己能够处理的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.mediator.doSomethingB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteColleagueB</span> <span class="keyword">extends</span> <span class="title">Colleague</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteColleagueB</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//自己能够处理的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.mediator.doSomethingB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>用一个中介对象封装一系列的对象交互，中介者使对象不需要显示的相互作用，从而使其耦合松散,并且可以独立的改变他们之间的交互</p></blockquote><h4 id="中介者模式有什么优势"><a href="#中介者模式有什么优势" class="headerlink" title="中介者模式有什么优势"></a>中介者模式有什么优势</h4><ol><li>系统更加灵活，各个参与者相互独立</li><li>减少类间的依赖，参与类只依赖中介者，减少了依赖，降低了类间的耦合<h4 id="中介者模式存在的问题"><a href="#中介者模式存在的问题" class="headerlink" title="中介者模式存在的问题"></a>中介者模式存在的问题</h4></li><li>中介者承担了太多的职责，一旦出现问题，整个系统都会受影响</li><li>中介者会变得非常复杂，原本参与者间的关系转换成了中介者与参与者的关系，参与者越多，中介者就越复杂</li></ol><h4 id="中介者模式要慎用"><a href="#中介者模式要慎用" class="headerlink" title="中介者模式要慎用"></a>中介者模式要慎用</h4><ol><li>量力而行。 中介者模式会使中介者逻辑复杂化。使用不当会把问题变得复杂，如果本身就只有简单的几个依赖关系，就没必要用终结者模式。所以要根据情况权衡中介者模式的使用</li><li>中介者适合多个对象紧密耦合的情况–蜘蛛网结构，中介者模式能将蜘蛛网结构梳理成星型结构</li></ol><h4 id="留下的问题"><a href="#留下的问题" class="headerlink" title="留下的问题"></a>留下的问题</h4><p>Q:不符合依赖倒置原则，很少使用接口或者抽象类</p><ul><li>参与者之间是协作关系，处理不同的任务，不能严格定义参与者需要具有的方法，不能抽象出一个统一的父类</li><li>每个中介者所围绕的参与类各不相同，不能抽象出一个具有共性的中介者</li><li>两个对象不能提炼出共性，就不要追求两者的抽象</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://posw9yxeh.bkt.clouddn.com/images/common/gratisography-157-thumbnail-small.jpg&quot; alt&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>代理模式|动态代理原理浅析</title>
    <link href="https://shawnyou.tech/2019/04/05/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/04/05/代理模式/</id>
    <published>2019-04-05T01:13:59.000Z</published>
    <updated>2019-04-14T14:13:36.023Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://posw9yxeh.bkt.clouddn.com/images/common/gratisography-306-thumbnail-small.jpg" alt><br><a id="more"></a></p><blockquote><p>为其他对象提供一个代理以控制对这个对象的访问，在不改变目标对象基础上添加额外的功能。</p></blockquote><h3 id="如何理解代理模式"><a href="#如何理解代理模式" class="headerlink" title="如何理解代理模式"></a>如何理解代理模式</h3><ul><li>两个主体：代理对象和被代理对象</li><li>对于被代理对象，事情必须要去做吗，但是自己不想去做或是没有条件去做，需要代理对象代替被代理对象去做。</li><li>代理对象能够获取被代理对象的资料信息。 代理层面（获得被代理对象的引用）</li></ul><h4 id="生活案例"><a href="#生活案例" class="headerlink" title="生活案例"></a>生活案例</h4><ul><li><p>中介：通常买二手车的时候，会去网上找车源，对车进行质量检测，以及各种过户手续的办理，自己可能不想做这些事情，所以可以找第三方的中介公司来完成这些事情，我只负责把我想要的车辆的信息（价位、车辆新旧程度、品牌）反馈给中介，中介把所有的办好就只管我来签字验收就可以了。</p></li><li><p>黄牛：当春运火车票比较紧张的时候，我抢不到票，且自己也不想去抢，则可以通过黄牛去买，我只管把我的车票信息给他（初始地、目的地、出发时间、车次），由此不用抢票，也可以买到相应的车票，抢票的过程由黄牛去做。</p></li><li><p>媒人：平时自己没有时间去交女朋友，则需要媒人去介绍，我们只管把我们想要的女朋友的类型给媒人，媒人则帮我们去寻找合适的对象。</p></li></ul><h4 id="需要类图"><a href="#需要类图" class="headerlink" title="需要类图"></a>需要类图</h4><ul><li>Subject(抽象主题)</li></ul><p>可以是抽象类也可以是接口</p><ul><li>RealSubject(具体角色)</li></ul><p>被代理的对象，业务逻辑的执行者</p><ul><li>Proxy(代理角色)</li></ul><p>代理类，负责对真实角色的应用，把所有抽象主题定义的方法限制委托给真实角色实现，并在真实角色处理完毕前后做相应工作</p><h3 id="几种代理实现形式"><a href="#几种代理实现形式" class="headerlink" title="几种代理实现形式"></a>几种代理实现形式</h3><p>代理有两种主要形式</p><ol><li>静态代理</li></ol><p>编译前，代码已经创建好，程序运行时，class文件已经存在</p><ol start="2"><li>动态代理</li></ol><p>程序运行时通过反射生成代理类</p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><ul><li>代理类与目标类实现相同的接口</li><li>代理类持有目标类的引用，可以控制目标类方法的访问</li></ul><h5 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start to request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.before();</span><br><span class="line">        subject.request();</span><br><span class="line">        <span class="keyword">this</span>.after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置处理。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置处理。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="强制代理"><a href="#强制代理" class="headerlink" title="强制代理"></a>强制代理</h5><ul><li>只能通过真实角色角色制定的代理类才能访问</li><li>不允许直接访问真实角色</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Subject <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubjectProxy</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject.request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject proxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isProxy())&#123;</span><br><span class="line">            System.out.println(<span class="string">"start to request"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"请使用指定的代理进行访问"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = <span class="keyword">new</span> SubjectProxy(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.proxy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RealSubject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        Subject proxy = subject.getProxy();</span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态代理局限性"><a href="#静态代理局限性" class="headerlink" title="静态代理局限性"></a>静态代理局限性</h5><ul><li>不够灵活，每个代理只为一个接口服务，会造成大量代码重复</li><li>静态代理类职位特定的接口服务，如果有多个接口，需要生成多个代理对象，不利于系统维护</li></ul><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buyCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerServiceImpl</span> <span class="keyword">implements</span> <span class="title">CustomerService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"决定买这个车了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarAgency</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理对象的引用</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Class clazz = target.getClass();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(clazz.getClassLoader(),target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"办理车辆质量检查报告"</span>);</span><br><span class="line">        method.invoke(target,args);</span><br><span class="line">        System.out.println(<span class="string">"办理车辆二手车过户"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理源码解析</p><ol><li>代理模式的意义（如何案例理解）</li><li>三种代理方式</li><li>动态代理实现原理</li><li>动态代理的实际运用（RPC、Spring等 RMI  收集相关的应用）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://posw9yxeh.bkt.clouddn.com/images/common/gratisography-306-thumbnail-small.jpg&quot; alt&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
</feed>

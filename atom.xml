<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>攻城虱</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-27T14:43:53.784Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Shawn You</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>里氏替换原则</title>
    <link href="http://yoursite.com/2019/03/27/parentReplace/"/>
    <id>http://yoursite.com/2019/03/27/parentReplace/</id>
    <published>2019-03-27T12:56:55.000Z</published>
    <updated>2019-03-27T14:43:53.784Z</updated>
    
    <content type="html"><![CDATA[<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>继承作为面向对象设计的重要手段，具有以下的特点</p><p>优点</p><ul><li>代码共享，减少重复工作</li><li>提高代码复用性</li><li>子类形似于父类而区别于父类</li><li>提高代码扩展性</li></ul><p>缺点</p><ul><li>代码侵入性，继承必须拥有父类的所有方法</li><li>降低代码灵活性，子类必须拥有父类的属性和方法</li><li>增强了耦合性，当父类被改变时，需要考虑到子类的修改</li></ul><p>什么叫里氏替换原则</p><blockquote><p>所有引用基类的地方必须能够透明的使用其子类的对象（）</p></blockquote><p>由此里氏替换原则是为继承定义的一个规范</p><ul><li>子类必完全实现父类的方法</li><li>子类可以有自己独特的个性</li><li>覆盖或者实现父类的方法时，输入参数可以被放大</li><li>覆盖或实现父类方法时，输出结果可以被缩小</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;里氏替换原则&quot;&gt;&lt;a href=&quot;#里氏替换原则&quot; class=&quot;headerlink&quot; title=&quot;里氏替换原则&quot;&gt;&lt;/a&gt;里氏替换原则&lt;/h3&gt;&lt;p&gt;继承作为面向对象设计的重要手段，具有以下的特点&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码共享，减少
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>接口隔离原则|</title>
    <link href="http://yoursite.com/2019/03/27/interfaceIsolate/"/>
    <id>http://yoursite.com/2019/03/27/interfaceIsolate/</id>
    <published>2019-03-27T12:56:31.000Z</published>
    <updated>2019-03-27T14:43:53.784Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是接口隔离原则"><a href="#什么是接口隔离原则" class="headerlink" title="什么是接口隔离原则"></a>什么是接口隔离原则</h3><ul><li>客户端不应该依赖它不需要的接口</li><li>类间的依赖关系应该建立在最小的接口上</li></ul><p>总的来说，就是建立单一的接口，不要建立臃肿庞大的接口，接口尽量细化，接口的方法尽量少</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是接口隔离原则&quot;&gt;&lt;a href=&quot;#什么是接口隔离原则&quot; class=&quot;headerlink&quot; title=&quot;什么是接口隔离原则&quot;&gt;&lt;/a&gt;什么是接口隔离原则&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;客户端不应该依赖它不需要的接口&lt;/li&gt;
&lt;li&gt;类间的依赖关系应该建立
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>开闭原则|</title>
    <link href="http://yoursite.com/2019/03/27/openClose/"/>
    <id>http://yoursite.com/2019/03/27/openClose/</id>
    <published>2019-03-27T12:55:03.000Z</published>
    <updated>2019-03-30T13:09:45.088Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>单一职责原则</title>
    <link href="http://yoursite.com/2019/03/25/singleResponsibility/"/>
    <id>http://yoursite.com/2019/03/25/singleResponsibility/</id>
    <published>2019-03-25T15:25:15.000Z</published>
    <updated>2019-03-27T14:43:47.148Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>应该有且只有一个原因引起累的变更。</p><h3 id="一个例子去理解单一职责原则"><a href="#一个例子去理解单一职责原则" class="headerlink" title="一个例子去理解单一职责原则"></a>一个例子去理解单一职责原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface IPhone &#123;</span><br><span class="line">    //接通</span><br><span class="line">    public void dial(String phoneNumber);</span><br><span class="line">    //聊天</span><br><span class="line">    public void chat(Object o);</span><br><span class="line">    //挂断</span><br><span class="line">    public void hangup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个Iphone的接口，包含了电话的三个功能，接通、聊天、挂断。 试想一下这个接口符合单一职责原则吗？（一个类或者接口只有一个原因引起变化） </p><p>很明显，IPhone包括了两个职责,应该设计成两个接口。</p><ol><li>信号的接通与果断</li><li>通话（数据传输）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IConnectionManager &#123;</span><br><span class="line">    void dial(String phoneNumber);</span><br><span class="line"></span><br><span class="line">    void hangup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IDataTransfer &#123;</span><br><span class="line">    void transfer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单一职责原则的好处"><a href="#单一职责原则的好处" class="headerlink" title="单一职责原则的好处"></a>单一职责原则的好处</h3><ol><li>降低类的复杂度，职责清晰、明确</li><li>复杂度降低，可读性提高</li><li>可维护性提高</li><li>变更的风险降低</li></ol><h3 id="职责没有量化的标准"><a href="#职责没有量化的标准" class="headerlink" title="职责没有量化的标准"></a>职责没有量化的标准</h3><p>类的单一职责原则受非常多的网因素制约，从理论上是非常优秀，但从实际的角度上来讲，单一职责原却难以落地。类职责的划分没有量化的标准，因为职责和变化原因都是不可度量的，因项目而异，因环境而异。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单一职责原则&quot;&gt;&lt;a href=&quot;#单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则&quot;&gt;&lt;/a&gt;单一职责原则&lt;/h3&gt;&lt;p&gt;应该有且只有一个原因引起累的变更。&lt;/p&gt;
&lt;h3 id=&quot;一个例子去理解单一职责原则&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>迪米特法则|如何降低类间耦合</title>
    <link href="http://yoursite.com/2019/03/25/dimite/"/>
    <id>http://yoursite.com/2019/03/25/dimite/</id>
    <published>2019-03-25T13:54:12.000Z</published>
    <updated>2019-03-30T13:09:25.300Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发一直在推崇一个概念-低耦合、高内聚。 那什么样的代码设计才算得上低耦合、高内聚的代码。本文通过迪米特法则来讲解一下如何进行低耦合的代码设计。</p><blockquote><p>迪米特法则也叫最小知识原则（Least Knowledge Principle）,即一个类应该对自己需要耦合和调用的类保持最少的认识。也就是一个类对自己依赖的类知道的越少越好。因而迪米特法则应该遵循一下的要义</p><ol><li>被依赖者，只应该暴露应该暴露的方法</li><li>依赖者，只依赖应该依赖的对象</li></ol></blockquote><h3 id="一个案例"><a href="#一个案例" class="headerlink" title="一个案例"></a>一个案例</h3><p>David Bock根据迪米特法则给出了一个超市购物的案例。<br>三个关键信息：消费者、钱包、收银员<br>定义了三个类，分别是Customer、Wallet、PaperBoy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Customer &#123;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line">    private Wallet myWallet;</span><br><span class="line">    public String getFirstName()&#123;</span><br><span class="line">        return firstName;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getLastName()&#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    public Wallet getWallet()&#123;</span><br><span class="line">        return myWallet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Wallet &#123;</span><br><span class="line">    private float value;</span><br><span class="line">    public float getTotalMoney() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setTotalMoney(float newValue) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addMoney(float deposit) &#123;</span><br><span class="line">        value += deposit;</span><br><span class="line">    &#125;</span><br><span class="line">    public void subtractMoney(float debit) &#123;</span><br><span class="line">        value -= debit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Paperboy &#123;</span><br><span class="line">    public void charge(Customer myCustomer, double payment) &#123;</span><br><span class="line">        Wallet theWallet = myCustomer.getWallet();</span><br><span class="line">        if (theWallet.getTotalMoney() &gt; payment) &#123;</span><br><span class="line">            theWallet.subtractMoney(payment);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //money not enough</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这三个类可以看出， PaperBoy承担了大多数的功能实现。PaperBoy从消费者那里拿到了钱包，核点钱包的的金钱并自己从中拿去购物的费用。paperBoy既与Customer发生直接交互，又与Wallet发生间接交互，不符合最小知识原则（迪米特法则）。案例主要存在以下问题</p><ul><li>Wallet暴露太多方法，其实Customer只要能够用钱包进行付钱就行了。所以这违反了迪米特法则的第一条（被依赖者，只暴露应该暴露的方法）</li><li>让PaperBoy与Wallet直接交互是错误的行为，Wallet是Customer的私有财物，ParperBoy是无权过问Wallet的情况的， 所以从职责的角度上来看，这是不符合逻辑，违反了迪米特法则的第二条（依赖者，只依赖应该依赖的对象）</li></ul><h3 id="如何进行修改"><a href="#如何进行修改" class="headerlink" title="如何进行修改"></a>如何进行修改</h3><ul><li>PaperBoy不再与钱包发生直接关系，直接向customer要钱</li><li>钱包只暴露付钱的方法给Customer。 方法暴露越多，后期需求变更的影响越大。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PaperBoy &#123;</span><br><span class="line">    private Customer customer;</span><br><span class="line"></span><br><span class="line">    public PaperBoy(Customer customer)&#123;</span><br><span class="line">        this.customer = customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void charge(float payment)&#123;</span><br><span class="line">        customer.pay(payment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Customer &#123;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line">    private Wallet myWallet;</span><br><span class="line"></span><br><span class="line">    public Customer(String firstName, String lastName, Wallet myWallet) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">        this.myWallet = myWallet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getFirstName()&#123;</span><br><span class="line">        return firstName;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getLastName()&#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pay(float payment)&#123;</span><br><span class="line">        myWallet.pay(payment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Wallet &#123;</span><br><span class="line">    private float value;</span><br><span class="line">    private float getTotalMoney() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setTotalMoney(float newValue) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    private void addMoney(float deposit) &#123;</span><br><span class="line">        value += deposit;</span><br><span class="line">    &#125;</span><br><span class="line">    private void subtractMoney(float debit) &#123;</span><br><span class="line">        value -= debit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pay(float payment)&#123;</span><br><span class="line">        if(getTotalMoney()&gt;payment)&#123;</span><br><span class="line">            subtractMoney(payment);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迪米特法则核心观念— 类间解耦、弱耦合</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;软件开发一直在推崇一个概念-低耦合、高内聚。 那什么样的代码设计才算得上低耦合、高内聚的代码。本文通过迪米特法则来讲解一下如何进行低耦合的代码设计。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;迪米特法则也叫最小知识原则（Least Knowledge Principle）,即
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>关于单例模式的几种变体形式</title>
    <link href="http://yoursite.com/2019/03/22/singleton/"/>
    <id>http://yoursite.com/2019/03/22/singleton/</id>
    <published>2019-03-22T13:14:01.000Z</published>
    <updated>2019-03-23T14:54:41.764Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://posw9yxeh.bkt.clouddn.com/static/images/singleton-1.jpg" alt><br><a id="more"></a></p><p>单例模式是一种简单的的设计模式。虽然简单，但是应用却是十分的广泛。所有有必要针对单例模式的知识点进行梳理。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p>确保类只有一个实例，并自动实例化向整个系统提供全局的访问点。从定义上可以推断出单例模式更倾向于节约资源，利于资源的重用从而节约时间。所以应用单例模式的对象应该具有以下特点：</p></blockquote><ul><li>频繁地创建、销毁且性能无法优化</li><li>消耗大量资源（读取配置、产生依赖对象），可以在应用启动时直接产生一个单例对象</li><li>避免资源的多重占用 </li><li>设置全局的访问点，优化和共享资源访问</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h3 id="单例模式设计的几点考虑"><a href="#单例模式设计的几点考虑" class="headerlink" title="单例模式设计的几点考虑"></a>单例模式设计的几点考虑</h3><ul><li>延迟加载</li><li>线程安全</li><li>并发性能</li><li>序列化/反序列化安全</li></ul><table><thead><tr><th>name</th><th>延迟加载</th><th>线程安全</th><th>并发性能</th><th>序列化/反序列化安全</th></tr></thead><tbody><tr><td>饿汉式</td><td>N</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>懒汉式(不加锁)</td><td>Y</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>懒汉式(加锁)</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>DCL</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>静态内部类</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>枚举</td><td>N</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table><h3 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h3><ol><li>饿汉式</li></ol><p>类加载时完成初始化</p><ul><li><p>类加载慢</p></li><li><p>获取对象速度快</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton singleton = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>懒汉式</li></ol><p>获取对象的时候完成初始化，实现懒加载。但是线程不安全，高并发下会出现多个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if( instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>懒汉式（加锁）</li></ol><p>线程安全的懒汉式单例模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SafeSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static SafeSingleton instance = null;</span><br><span class="line"></span><br><span class="line">    private SafeSingleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized SafeSingleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new SafeSingleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>双重检查DCL</li></ol><ul><li><p>synchronized同步代码块保证只创建一个对象。</p></li><li><p>条件判断使对象创建过后，不在进入同步块，减少锁的粒度。</p></li><li><p>volatitle防止指令重排序(否则出现一个线程创建一般的对象呗另一个线程访问，造成空指针)。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>静态内部类</li></ol><ul><li><p>利用ClassLoader的机制保证了线程安全</p></li><li><p>相比饿汉式单例模式，实现懒加载，只有显示调用SingleHolder才会触发初始化。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line"></span><br><span class="line">        private static final Singleton instance = new Singleton();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static final Singleton getInstance()&#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>枚举</li></ol><ul><li>线程安全（虚拟机加载枚举的时候，会使用ClassLoader的loadClass方法，这个方法使用同步代码块保证线程安全）</li></ul><ul><li>解决反序列化破坏单例的问题:<ul><li>普通序列化过程中，通过反射调用默认构造函数来初始化对象，反序列化的对象是新建的</li><li>枚举的反序列化不是通过构造函数实现，因此不会发生于由于反序列化导致的单例破坏问题</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    public void getInstance()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何设计优秀的单例模式"><a href="#如何设计优秀的单例模式" class="headerlink" title="如何设计优秀的单例模式"></a>如何设计优秀的单例模式</h3><h3 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h3><ol><li>双重校验DCL为什么使用volatile</li><li>synchronized与volatile的区别</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://posw9yxeh.bkt.clouddn.com/static/images/singleton-1.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>模板模式</title>
    <link href="http://yoursite.com/2019/03/22/templateMethod/"/>
    <id>http://yoursite.com/2019/03/22/templateMethod/</id>
    <published>2019-03-22T13:14:01.000Z</published>
    <updated>2019-03-31T05:30:26.007Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://posw9yxeh.bkt.clouddn.com/images/common/gratisography-271-thumbnail-small.jpg" alt><br><a id="more"></a></p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><blockquote><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤</p></blockquote><h3 id="如何理解模板模式"><a href="#如何理解模板模式" class="headerlink" title="如何理解模板模式"></a>如何理解模板模式</h3><p>在我们的认识中，模板就是一些约定俗成的东西，是一些自然而然的事物规律。当我们想要解决一些具有模板规律的事情的时候，手中的模板就是一个个整齐待发的磨具，能够轻松进行重复制造、生产。由此想了想，生活中哪些事情满足模板模式的规律：</p><ol><li>制茶，制茶是一个很有讲究的学问。制造茶的流程总是相对固定的。采青-&gt; 萎凋-&gt;发酵-&gt; 杀青 -&gt; 揉捻 -&gt; 干燥 -&gt; 初制茶。每个工坊的制作工艺有所差别，有些工坊的手工揉捻做的比较好，有些工坊的萎凋做的比较有特点，所以生产出来的茶叶有所区别。但是他们的总体流程是相对差不多的，都遵循相同的制作模板。</li><li>造车，车的总体功能差不多， 能够启动、停止，能够鸣笛、跑路。但是不同型号的车是有所差异的。有些车是手动挡，有些是自动挡。</li></ol><p>我们可以根据这类食物的规律总结一下特点：</p><ul><li>具有一个抽象的模板，这个模板决定了这类事物的总体流程规律（父类抽象模板）</li><li>不同的事物虽然具有共同的抽象模板，但是彼此有着个性化的差异（个性化子类）</li><li>子类的个性化特点能够重新定义整个事物的最终呈现结构，就好比不同的茶叶工坊的制作工艺的差别会导致这个茶叶具有不同销量和名声。不同型号的车会导致车具有不同的价格和市场。</li></ul><p>程序是现实世界的抽象，模板模式的类可以总结如下：</p><p>抽象模板</p><ul><li>基本方法</li></ul><p>子类的个性化方法，由子类去实现，如制茶过程中每一个环节（发酵…）</p><ul><li>模板方法</li></ul><p>对基本方法的调度，已完成固定的逻辑。如制茶这样的模板方法就是将制茶每个环节的调度，完成造茶这么一个逻辑。</p><p>注意：</p><ol><li>基本方法尽量设计成protected类型，符合迪米特法则，若非必要，尽量不要扩大父类的访问权限。</li><li>模板方法一般设计成final类型，不要被覆写</li></ol><h3 id="为什么要用模板模式"><a href="#为什么要用模板模式" class="headerlink" title="为什么要用模板模式"></a>为什么要用模板模式</h3><ol><li>封装不变部分，扩展可变部分</li></ol><p>不变的流程规律由父类来实现，而可变的每个环节由子类来控制。</p><ol start="2"><li><p>提取公共部分代码，便于维护</p></li><li><p>行为由父类控制、子类实现</p></li></ol><p>基本方法由子类实现，子类可以通过扩展类来增加相应功能，符合开闭原则。</p><p>模板模式实现</p><p>模板模式也有缺陷</p><p>四思维方式与以往有所不同，不好理解。</p><p>常规思路:</p><ul><li><p>抽象类-&gt;最抽象、最一般的事物属性和方法</p></li><li><p>具体类-&gt;具体的事物属性和方法</p></li></ul><p>模板模式思路：</p><ul><li><p>抽象类-&gt;定义部分抽象方法</p></li><li><p>实现类-&gt;子类的执行结果对父类结构产生影响</p></li></ul><p>总结一下</p><p>模板模式的扩展–钩子函数的应用<br>由子类的一个方法返回值来决定公共部分的执行结果</p><p>引申</p><h3 id="父类怎么调用子类的方法"><a href="#父类怎么调用子类的方法" class="headerlink" title="父类怎么调用子类的方法"></a>父类怎么调用子类的方法</h3><ol><li>子类传递到父类的有参构造中</li><li>反射</li><li>父类调用子类的静态方法</li></ol><p>其实模板模式就间接的实现了父类依赖子类的场景</p><ul><li>父类建立框架-&gt;子类重写父类 -&gt; 调用父类继承方法-&gt; 影响父类结果</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://posw9yxeh.bkt.clouddn.com/images/common/gratisography-271-thumbnail-small.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式|如何优雅的new对象</title>
    <link href="http://yoursite.com/2019/03/22/factory/"/>
    <id>http://yoursite.com/2019/03/22/factory/</id>
    <published>2019-03-22T13:14:01.000Z</published>
    <updated>2019-03-31T04:05:53.469Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://posw9yxeh.bkt.clouddn.com/images/factory/factory-1.jpg" alt><br><a id="more"></a></p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在面向对象编程（OOP）中，通过new去实例化一个对象是再正常不过的事情。但是每当new一个对象，后面都会跟一个具体类，这使得代码与具体类过度耦合，让我们陷入面向实现编程的漩涡里面。每当有新的需求变更，我们代码的扩展性就比较差。</p><p>手动new对象有哪些问题</p><ul><li>与具体类耦合，每当有新的变化，就必须改变代码（不符合对修改关闭）</li><li>无法借助接口、多态的力量去隔离变化（与面向接口编程相违背）</li></ul><p>如何才能优雅的new对象</p><ul><li>对扩展开放，应对后期的各种需求</li><li>对修改关闭，对于新的需求，不改变原有的代码</li><li>不关心构造对象的细节和复杂过程，轻松获取对象实例</li></ul><p>可以通过工厂模式来构造我们想要的对象。</p><blockquote><p>工厂模式是一种常用的创建型设计模式，在基类中定义了创建对象的接口，让子类来决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。</p></blockquote><p>工厂模式包括我们所熟知的简单工厂模式、工厂方法模式、抽象工厂工厂模式。其中简单工厂模式在一定程度上只算是一种编程思想，还谈不上设计模式。但它作为工厂方法模式和抽象工厂模式的基石，还是有必要深入了解一下。</p><h2 id="造车案例来了解一下不同的工厂模式"><a href="#造车案例来了解一下不同的工厂模式" class="headerlink" title="造车案例来了解一下不同的工厂模式"></a>造车案例来了解一下不同的工厂模式</h2><ol><li>客户想要一辆奔驰车，客户需要奔驰车的设计图纸相应的汽车零件来自己制造。当客户想要悍马车，手上的设计图纸和汽车零件已经毫无用处，需要获取悍马车的设计图纸以及汽车零件（不符合对修改关闭）</li><li>客户不需要自己生产汽车，由工厂来提供服务，客户需要什么车，工厂就生产什么车。但是每当客户有新的需求的时候，工厂就得想尽办法去找相关的图纸和零件来交付生产。—简单工厂模式（不符合对修改关闭）</li><li>客户的需求太多，一个工厂完全应付不过来，所以工厂就开始建立新的场地，有些场地只生产宝马车，有些场地只生产悍马车，这样客户想要什么样的车就找对应的车工厂去提货。— 工厂方法模式</li><li>客户的需求逐渐升级，不同型号的车具有不同配置，所以每一个具体工厂应该具备生产不同型号车辆的能力，奥迪的工厂不仅能生产A4，也能生产A6、A8。所以一个工厂应该具备生产不同型号车辆的生产车间—抽象工厂模式</li></ol><h2 id="几种工厂模式的实现"><a href="#几种工厂模式的实现" class="headerlink" title="几种工厂模式的实现"></a>几种工厂模式的实现</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><blockquote><p>定义一个工厂类，根据传入的参数不同返回不同的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class RectShape implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;draw rectangle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class CircleShape implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;draw circle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory &#123;</span><br><span class="line">    public static Shape getShape(String type)&#123;</span><br><span class="line">        Shape shape = null;</span><br><span class="line">        if(&quot;circle&quot;.equalsIgnoreCase(type))&#123;</span><br><span class="line">            shape = new CircleShape();</span><br><span class="line">        &#125;else if(&quot;rectangle&quot;.equalsIgnoreCase(type))&#123;</span><br><span class="line">            shape = new RectShape();</span><br><span class="line">        &#125;</span><br><span class="line">        return shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Shape circle = ShapeFactory.getShape(&quot;circle&quot;);</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        Shape rectangle = ShapeFactory.getShape(&quot;rectangle&quot;);</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用场景：<ul><li>只有一个工厂类，对于创建对象不多的案例比较适合</li><li>工厂类封装了对象的创建过程，客户端不需要关心对象的创建过程。</li></ul></li></ul><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><blockquote><p>简单工厂的深入化， 通过创建不同的对象工厂来取代统一的工厂。让子类来决定哪一个类实例化，让一个类的实例化延迟到子类。</p></blockquote><p>案例：有一个图片加载器，可以加载jpg、png、gif等图片格式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 图片加载器接口</span><br><span class="line"> */</span><br><span class="line">public interface Reader &#123;</span><br><span class="line">    void read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * gif 图片加载器</span><br><span class="line"> */</span><br><span class="line">public class GifReader implements Reader&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;gif picture reader&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * png 图片加载器</span><br><span class="line"> */</span><br><span class="line">public class PngReader implements Reader&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;png picture reader&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * jpg 图片加载器</span><br><span class="line"> */</span><br><span class="line">public class JpgReader implements Reader&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;jpg picture reader&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * gif 图片加载器工厂</span><br><span class="line"> */</span><br><span class="line">public class GifReaderFactory implements ReaderFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Reader getReader() &#123;</span><br><span class="line">        return new GifReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * jpg 图片加载器工厂</span><br><span class="line"> */</span><br><span class="line">public class JpgReaderFactory implements ReaderFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Reader getReader() &#123;</span><br><span class="line">        return new JpgReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * png 图片加载器工厂</span><br><span class="line"> */</span><br><span class="line">public class PngReaderFactory implements ReaderFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Reader getReader() &#123;</span><br><span class="line">        return new PngReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 客户端</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GifReaderFactory gifReaderFactory = new GifReaderFactory();</span><br><span class="line">        Reader gifReader = gifReaderFactory.getReader();</span><br><span class="line">        gifReader.read();</span><br><span class="line"></span><br><span class="line">        PngReaderFactory pngReaderFactory = new PngReaderFactory();</span><br><span class="line">        Reader pngReader = pngReaderFactory.getReader();</span><br><span class="line">        pngReader.read();</span><br><span class="line"></span><br><span class="line">        JpgReaderFactory jpgReaderFactory = new JpgReaderFactory();</span><br><span class="line">        Reader jpgReader = jpgReaderFactory.getReader();</span><br><span class="line">        jpgReader.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂方法模式优点</p><ul><li>良好的封装性。调用者需要创建一个产品对象，只需要知道产品工厂的类名就可以了，不要了解对象创建过程，降低模块间的耦合。</li><li>良好的扩展性。当有新增产品类的需求变化，只要适当扩展一个工厂类就可以完成拥抱变化</li><li>屏蔽产品类。产品类如何变化，调用者不需要关心—切换数据源（数据库从MySQL切换到Oracle,需要改动的只是切换一下驱动名称）</li><li>典型的解耦框架。<ul><li>高层模块需要知道产品抽象类，不关心实现类—迪米特法则</li><li>只依赖产品类的抽象 — 依赖倒置原则</li><li>产品子类替换产品父类 — 里氏替换原则</li></ul></li></ul><p>应用场景</p><ul><li>所以生成对象的地方都可以使用工厂方法模式，但是要权衡增加工厂类进行管理带来的代码复杂度</li><li>需要灵活、可扩展的框架是，可以采用工厂方法模式</li><li>客户端不需要知道它所创建对象的类，只需要知道创建的工厂名就可以完成创建过程</li></ul><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><blockquote><p>为创建一组相关或相互依赖的对象提供一个借口，而无需指定他们的具体类。</p></blockquote><p>案例：设计一个兼容Android、ios、Wp三个操作系统的游戏，每个系统都有一套操作控制和界面控制器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 界面控制器</span><br><span class="line"> */</span><br><span class="line">public interface UIController &#123;</span><br><span class="line">    void display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作控制器</span><br><span class="line"> */</span><br><span class="line">public interface OperationController &#123;</span><br><span class="line">    void control();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * wp ui controller</span><br><span class="line"> */</span><br><span class="line">public class WpUIController implements UIController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;wp ui controller&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ios 界面控制器</span><br><span class="line"> */</span><br><span class="line">public class IosUIController implements UIController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;ios ui controller&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 安卓界面控制器</span><br><span class="line"> */</span><br><span class="line">public class AndroidUIController implements UIController&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;android ui controller&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * wp 操作控制器</span><br><span class="line"> */</span><br><span class="line">public class WpOperationController implements OperationController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void control() &#123;</span><br><span class="line">        System.out.println(&quot;wp operation controller&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ios 操作控制器</span><br><span class="line"> */</span><br><span class="line">public class IosOperationController implements OperationController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void control() &#123;</span><br><span class="line">        System.out.println(&quot;ios operation controller&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 安卓操作控制器</span><br><span class="line"> */</span><br><span class="line">public class AndroidOperationController implements OperationController&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void control() &#123;</span><br><span class="line">        System.out.println(&quot;android opration controller&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface SystemFactory &#123;</span><br><span class="line">    OperationController createOperationController();</span><br><span class="line">    UIController createUIController();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * ios 工厂</span><br><span class="line"> */</span><br><span class="line">public class IosFactory implements SystemFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OperationController createOperationController() &#123;</span><br><span class="line">        return new IosOperationController();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UIController createUIController() &#123;</span><br><span class="line">        return new IosUIController();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * wp 工厂</span><br><span class="line"> */</span><br><span class="line">public class WpFactory implements SystemFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OperationController createOperationController() &#123;</span><br><span class="line">        return new WpOperationController();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UIController createUIController() &#123;</span><br><span class="line">        return new WpUIController();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 安卓工厂</span><br><span class="line"> */</span><br><span class="line">public class AndroidFactory implements SystemFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OperationController createOperationController() &#123;</span><br><span class="line">        return new AndroidOperationController();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UIController createUIController() &#123;</span><br><span class="line">        return new AndroidUIController();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AndroidFactory androidFactory = new AndroidFactory();</span><br><span class="line">        OperationController androidOperation = androidFactory.createOperationController();</span><br><span class="line">        androidOperation.control();</span><br><span class="line"></span><br><span class="line">        UIController androidUI = androidFactory.createUIController();</span><br><span class="line">        androidUI.display();</span><br><span class="line"></span><br><span class="line">        IosFactory iosFactory = new IosFactory();</span><br><span class="line">        OperationController iosOperation = iosFactory.createOperationController();</span><br><span class="line">        iosOperation.control();</span><br><span class="line"></span><br><span class="line">        UIController iosUI = iosFactory.createUIController();</span><br><span class="line">        iosUI.display();</span><br><span class="line"></span><br><span class="line">        WpFactory wpFactory = new WpFactory();</span><br><span class="line">        OperationController wpOperation = wpFactory.createOperationController();</span><br><span class="line">        wpOperation.control();</span><br><span class="line"></span><br><span class="line">        UIController wpUI = wpFactory.createUIController();</span><br><span class="line">        wpUI.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点</p><ul><li>封装性。高层模块不需要关心产品实现类</li></ul><p>缺点</p><ul><li>产品族扩展困难,当要新增一个控制器，所有的实现类都要改变—违反开闭原则，改变了契约，所有与契约有关系的代码都要改变</li></ul><p>应用场景</p><ul><li>不关心对象创建过程</li><li>需要一组对象功能完成某种功能</li><li>系统结构稳定，不会频繁的增加产品族功能，增加产品族功能就回修改原有代码，不符合开闭原则。</li></ul><p>注意<br>产品族扩展困难(增加控制器)，但是产品扩展容易(增加小米系统的支持)，也就是纵向扩展困难，横向扩展容易，从产品横向扩展来说，抽象工厂模式是符合开闭原则的</p><p>参考文档</p><p><a href="https://juejin.im/entry/58f5e080b123db2fa2b3c4c6" target="_blank" rel="noopener">https://juejin.im/entry/58f5e080b123db2fa2b3c4c6</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://posw9yxeh.bkt.clouddn.com/images/factory/factory-1.jpg&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="http://yoursite.com/tags/Design/"/>
    
  </entry>
  
</feed>

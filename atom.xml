<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>攻城虱</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shawnyou.tech/"/>
  <updated>2020-05-25T01:48:59.292Z</updated>
  <id>https://shawnyou.tech/</id>
  
  <author>
    <name>Shawn You</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>30|如何解耦代码</title>
    <link href="https://shawnyou.tech/2020/05/25/design-pattern-notes/30%7C%E5%A6%82%E4%BD%95%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81/"/>
    <id>https://shawnyou.tech/2020/05/25/design-pattern-notes/30|如何解耦代码/</id>
    <published>2020-05-25T01:50:29.000Z</published>
    <updated>2020-05-25T01:48:59.292Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是代码的可测试性"><a href="#什么是代码的可测试性" class="headerlink" title="什么是代码的可测试性"></a>什么是代码的可测试性</h3><blockquote><p>代码的可测试性就是根据代码编写单元测试的容易程度。对测试性差的代码往往难以编写单元测试，因为他们没有遵循设计原则与思想，比如基于接口而非实现编程，依赖反转等。</p></blockquote><h3 id="如何编写可测试性的代码"><a href="#如何编写可测试性的代码" class="headerlink" title="如何编写可测试性的代码"></a>如何编写可测试性的代码</h3><ol><li>依赖注入</li></ol><p>通过依赖注入的形式引入其他类、方法，可以便于外部服务的Mock.</p><ol start="2"><li>Mock</li></ol><p>对于外界服务，我们不关系外部系统服务的正确性，所以我们对外部服务进行Mock,然后采用依赖注入的形式</p><ol start="3"><li>抽象封装<br>比如代码中有一段是关于日期过期的判断，这种情况可以将这块代码封装起来。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId) &#123; protected boolean isExpired() &#123; return true; &#125; &#125;;</span><br></pre></td></tr></table></figure><h3 id="测试性差的代码"><a href="#测试性差的代码" class="headerlink" title="测试性差的代码"></a>测试性差的代码</h3><ol><li>代码中包含未决行为逻辑</li><li>滥用可变全局变量</li><li>滥用静态方法</li><li>使用复杂的继承关系</li><li>高度耦合的代码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是代码的可测试性&quot;&gt;&lt;a href=&quot;#什么是代码的可测试性&quot; class=&quot;headerlink&quot; title=&quot;什么是代码的可测试性&quot;&gt;&lt;/a&gt;什么是代码的可测试性&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;代码的可测试性就是根据代码编写单元测试的容易程度。
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>29|代码的可测试性</title>
    <link href="https://shawnyou.tech/2020/05/25/design-pattern-notes/29%7C%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7/"/>
    <id>https://shawnyou.tech/2020/05/25/design-pattern-notes/29|代码的可测试性/</id>
    <published>2020-05-25T01:45:29.000Z</published>
    <updated>2020-05-25T01:48:01.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是代码的可测试性"><a href="#什么是代码的可测试性" class="headerlink" title="什么是代码的可测试性"></a>什么是代码的可测试性</h3><blockquote><p>代码的可测试性就是根据代码编写单元测试的容易程度。对测试性差的代码往往难以编写单元测试，因为他们没有遵循设计原则与思想，比如基于接口而非实现编程，依赖反转等。</p></blockquote><h3 id="如何编写可测试性的代码"><a href="#如何编写可测试性的代码" class="headerlink" title="如何编写可测试性的代码"></a>如何编写可测试性的代码</h3><ol><li>依赖注入</li></ol><p>通过依赖注入的形式引入其他类、方法，可以便于外部服务的Mock.</p><ol start="2"><li>Mock</li></ol><p>对于外界服务，我们不关系外部系统服务的正确性，所以我们对外部服务进行Mock,然后采用依赖注入的形式</p><ol start="3"><li>抽象封装<br>比如代码中有一段是关于日期过期的判断，这种情况可以将这块代码封装起来。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId) &#123; protected boolean isExpired() &#123; return true; &#125; &#125;;</span><br></pre></td></tr></table></figure><h3 id="测试性差的代码"><a href="#测试性差的代码" class="headerlink" title="测试性差的代码"></a>测试性差的代码</h3><ol><li>代码中包含未决行为逻辑</li><li>滥用可变全局变量</li><li>滥用静态方法</li><li>使用复杂的继承关系</li><li>高度耦合的代码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是代码的可测试性&quot;&gt;&lt;a href=&quot;#什么是代码的可测试性&quot; class=&quot;headerlink&quot; title=&quot;什么是代码的可测试性&quot;&gt;&lt;/a&gt;什么是代码的可测试性&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;代码的可测试性就是根据代码编写单元测试的容易程度。
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>28|重构的技术手段</title>
    <link href="https://shawnyou.tech/2020/05/25/design-pattern-notes/28%7C%E9%87%8D%E6%9E%84%E7%9A%84%E6%8A%80%E6%9C%AF%E6%89%8B%E6%AE%B5/"/>
    <id>https://shawnyou.tech/2020/05/25/design-pattern-notes/28|重构的技术手段/</id>
    <published>2020-05-25T00:45:29.000Z</published>
    <updated>2020-05-25T00:39:09.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="重构的技术手段"><a href="#重构的技术手段" class="headerlink" title="重构的技术手段"></a>重构的技术手段</h3><blockquote><p>最能保证重构不出错的手段 – 单元测试</p></blockquote><h3 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h3><ol><li>测试粒度小</li><li>测试对象：类或者函数</li></ol><h3 id="为什么要写单元测试"><a href="#为什么要写单元测试" class="headerlink" title="为什么要写单元测试"></a>为什么要写单元测试</h3><ol><li>帮助发现代码中的bug</li><li>帮助发现代码设计中的问题</li></ol><p>代码的可测试性是衡量代码质量的一个标准，如果单元测试写起来很吃力，说明代码设计有些问题。</p><ol start="3"><li>单元测试是对集成测试的有力补充。</li><li>写单元测试的过程就是代码重构的过程</li><li>阅读单元测试可以快速熟悉代码</li><li>单元测试是TDD落地执行的改进方案。</li></ol><h3 id="如何编写单元测试"><a href="#如何编写单元测试" class="headerlink" title="如何编写单元测试"></a>如何编写单元测试</h3><ol><li>利用测试框架，如JUnit,TestNG,Spring Test等</li><li>设计覆盖各种输入、异常、边界条件的测试用例</li></ol><ul><li>编写单元测试尽管繁琐，但并不是太耗时；</li><li>我们可以稍微放低对单元测试代码质量的要求；</li><li>覆盖率作为衡量单元测试质量的唯一标准是不合理的；</li><li>单元测试不要依赖被测代码的具体实现逻辑；</li><li>单元测试框架无法测试，多半是因为代码的可测试性不好。</li></ul><h3 id="单元测试为何难以落地"><a href="#单元测试为何难以落地" class="headerlink" title="单元测试为何难以落地"></a>单元测试为何难以落地</h3><ol><li>单元测试繁琐，技术挑战小，不愿意执行。</li><li>研发氛围“快、糙、猛”，难以执行。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;重构的技术手段&quot;&gt;&lt;a href=&quot;#重构的技术手段&quot; class=&quot;headerlink&quot; title=&quot;重构的技术手段&quot;&gt;&lt;/a&gt;重构的技术手段&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;最能保证重构不出错的手段 – 单元测试&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>27|重构初体验</title>
    <link href="https://shawnyou.tech/2020/05/24/design-pattern-notes/27%7C%E9%87%8D%E6%9E%84%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://shawnyou.tech/2020/05/24/design-pattern-notes/27|重构初体验/</id>
    <published>2020-05-24T11:45:29.000Z</published>
    <updated>2020-05-24T13:49:27.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><blockquote><p>重构是对软件内部结构的改善，目的是在不改变可见行为的前提下，使其更易理解，修改成本更低。</p></blockquote><h4 id="重构的目的-Why"><a href="#重构的目的-Why" class="headerlink" title="重构的目的(Why)"></a>重构的目的(Why)</h4><ol><li>防止代码腐化到无可救药的地步。</li><li>避免过度设计的有效手段，因为项目的初期不可能遇见未来100%的需求，需要不断的持续迭代重构来完善它，所以我们可以借助重构来避免过度设计。</li><li>重构能够帮助我们应用比较经典的设计思想、设计原则以及编程规范。</li></ol><h4 id="重构的对象-What"><a href="#重构的对象-What" class="headerlink" title="重构的对象(What)"></a>重构的对象(What)</h4><ol><li>大型重构(系统、模块、代码结构等)</li></ol><p>手段： 分层、模块化、解耦、抽象可复用组件<br>风险： 引入bug的风险较大</p><ol start="2"><li>小型重构(类、函数、变量等代码细节)</li></ol><p>手段：提取重复代码、规范命名、消除超大类。<br>风险：引入bug的风险小</p><h4 id="重构的时机-When"><a href="#重构的时机-When" class="headerlink" title="重构的时机(When)"></a>重构的时机(When)</h4><p>可持续重构：持续重构应该成为一种开发习惯，形成一种可持续、可演进的方式。</p><h4 id="重构的方法-How"><a href="#重构的方法-How" class="headerlink" title="重构的方法(How)"></a>重构的方法(How)</h4><ol><li>大型重构</li></ol><p>分阶段进行，小步重构，保证仓库内的代码始终是处于可运行、逻辑正确的状态。</p><ol start="2"><li>小型重构：</li></ol><p>只要有时间随时都可以做。</p><blockquote><p>对于重构的事情，项目leader要担起责任来，始终要保持项目中的代码处于良好的状态，避免形成“破窗效应”</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;重构&quot;&gt;&lt;a href=&quot;#重构&quot; class=&quot;headerlink&quot; title=&quot;重构&quot;&gt;&lt;/a&gt;重构&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;重构是对软件内部结构的改善，目的是在不改变可见行为的前提下，使其更易理解，修改成本更低。&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>22|迪米特法则</title>
    <link href="https://shawnyou.tech/2020/05/24/design-pattern-notes/22%7C%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/"/>
    <id>https://shawnyou.tech/2020/05/24/design-pattern-notes/22|迪米特法则/</id>
    <published>2020-05-24T07:45:29.000Z</published>
    <updated>2020-05-24T08:40:28.313Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则(LOD)–最小知识原则，即不该有直接依赖关系的类之间不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。</p><ol><li>不该有直接依赖关系的类之间不要有依赖</li></ol><p>NetworkTransporter底层通讯类尽可能通用，所以不应该依赖于太具体的请求对象HtmlRequest。</p><ol start="2"><li>有依赖关系的类之间，尽量只依赖必要的接口</li></ol><p>序列化与饭序列化。对于序列化功能应该分成序列化、反序列化两个独立的接口，这样的话，对于只需要序列化的类就不必去依赖反序列化的功能</p><h3 id="如何理解高内聚、低耦合"><a href="#如何理解高内聚、低耦合" class="headerlink" title="如何理解高内聚、低耦合"></a>如何理解高内聚、低耦合</h3><blockquote><p>高内聚、低耦合是重要的设计思想，能够提高代码的可读性与可维护性，缩小功能改动导致的代码改动范围。</p></blockquote><ol><li>高内聚</li></ol><p>指导类的设计，相近的功能放在一个类，不相近的功能放在另一个类，由此修改比较集中，符合高内聚的特点。</p><ol start="2"><li>低耦合</li></ol><p>指导类与类之间的依赖关系，即一个类的改动不会或者很少导致其他类的代码改动。</p><blockquote><p>迪米特法则减少类之间的耦合，让类更加的独立，很少去了解系统的其他部分，一旦需求变化，则需要了解这一变化的类就比较少。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;迪米特法则&quot;&gt;&lt;a href=&quot;#迪米特法则&quot; class=&quot;headerlink&quot; title=&quot;迪米特法则&quot;&gt;&lt;/a&gt;迪米特法则&lt;/h3&gt;&lt;p&gt;迪米特法则(LOD)–最小知识原则，即不该有直接依赖关系的类之间不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>21|DRY原则</title>
    <link href="https://shawnyou.tech/2020/05/24/design-pattern-notes/21%7CDRY%E5%8E%9F%E5%88%99/"/>
    <id>https://shawnyou.tech/2020/05/24/design-pattern-notes/21|DRY原则/</id>
    <published>2020-05-24T07:40:29.000Z</published>
    <updated>2020-05-24T07:57:20.184Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DRY原则"><a href="#DRY原则" class="headerlink" title="DRY原则"></a>DRY原则</h3><p>Don’t repeat yourself(避免重复代码)</p><ol><li>逻辑重复</li></ol><p>isValidUserName()与isValidPassword()验证逻辑一样，但是没有违背DRY原则，因为他们的语义不重复，是做的两个事情，有可能后期两者的验证逻辑会发生变化，所以不能融合在一起。应该尽量抽象出一些更细粒度的函数出来。</p><ol start="2"><li>语义重复</li></ol><p>isValidIp()与checkIfIpValid()虽然实现逻辑不一样，但是他们的语义都是一样的，都是验证IP的合法性，这种情况是违背DRY原则的，如果后期修改验证规则，只修改了其中一个会出现问题。</p><ol start="3"><li>执行重复</li></ol><p>有些逻辑被执行了多次，违背DRY原则</p><h3 id="如何提高代码复用性"><a href="#如何提高代码复用性" class="headerlink" title="如何提高代码复用性"></a>如何提高代码复用性</h3><ol><li>减少代码耦合</li></ol><p>高度耦合的代码，当需要复用某块代码的时候，难以抽取复用的代码，所以高度耦合的代码会影响代码复用性。</p><ol start="2"><li>满足单一职责原则</li></ol><p>如果设计的代码功能大而全，则依赖比较多，耦合比较严重，则影响代码复用性。</p><ol start="3"><li>模块化</li></ol><p>善于将功能独立的代码抽离成模块</p><ol start="4"><li><p>业务与非业务逻辑分离<br>与业务分离的代码更容易抽离出通用框架或者类库，易于复用。</p></li><li><p>应用模板等设计模式</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;DRY原则&quot;&gt;&lt;a href=&quot;#DRY原则&quot; class=&quot;headerlink&quot; title=&quot;DRY原则&quot;&gt;&lt;/a&gt;DRY原则&lt;/h3&gt;&lt;p&gt;Don’t repeat yourself(避免重复代码)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逻辑重复&lt;/li&gt;
&lt;/ol&gt;
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>20|KISS与YAGNI原则</title>
    <link href="https://shawnyou.tech/2020/05/24/design-pattern-notes/20%7CKISS%E4%B8%8EYAGNI/"/>
    <id>https://shawnyou.tech/2020/05/24/design-pattern-notes/20|KISS与YAGNI/</id>
    <published>2020-05-24T06:40:29.000Z</published>
    <updated>2020-05-24T07:03:03.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="KISS原则"><a href="#KISS原则" class="headerlink" title="KISS原则"></a>KISS原则</h3><p>Keep it short and simple(KISS)的意思即尽量保持简单。<br>如何才能写出满足KISS原则的代码</p><ol><li>不要使用同事不懂的技术来实现代码，如正则表达式(正则表达式荣易出错)</li><li>不要重复造轮子，要善于使用已有的工具类</li><li>不要过度优化，不要使用一些奇技淫巧来优化代码从而影响了代码的可读性。</li></ol><h3 id="YAGNI原则"><a href="#YAGNI原则" class="headerlink" title="YAGNI原则"></a>YAGNI原则</h3><p>You ain’t gonna need it – 不要去设计当前用不到的功能(不要过度设计)</p><ol><li>不要在项目提前引入不需要的依赖包。 </li></ol><h3 id="KISS与YAGNI原则"><a href="#KISS与YAGNI原则" class="headerlink" title="KISS与YAGNI原则"></a>KISS与YAGNI原则</h3><ol><li>KISS原则讲的是如何做的问题，如何做才能保持尽量简单。</li><li>YAGNI原则讲的是要不要做的问题，当前不需要做的就不要做，由此来保持简单。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;KISS原则&quot;&gt;&lt;a href=&quot;#KISS原则&quot; class=&quot;headerlink&quot; title=&quot;KISS原则&quot;&gt;&lt;/a&gt;KISS原则&lt;/h3&gt;&lt;p&gt;Keep it short and simple(KISS)的意思即尽量保持简单。&lt;br&gt;如何才能写出满足K
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>19|依赖注入</title>
    <link href="https://shawnyou.tech/2020/05/24/design-pattern-notes/19%7C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5(D)/"/>
    <id>https://shawnyou.tech/2020/05/24/design-pattern-notes/19|依赖注入(D)/</id>
    <published>2020-05-24T04:40:29.000Z</published>
    <updated>2020-05-24T06:49:45.147Z</updated>
    
    <content type="html"><![CDATA[<h3 id="控制反转、依赖反转、依赖注入"><a href="#控制反转、依赖反转、依赖注入" class="headerlink" title="控制反转、依赖反转、依赖注入"></a>控制反转、依赖反转、依赖注入</h3><h4 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h4><blockquote><p>控制反转不是具体的编程技巧而是比较笼统的设计思想，主要用于指导框架层面的设计。 </p></blockquote><p>以前由程序员来控制程序的执行转换为由框架来控制，程序的执行控制权由程序员变成了框架。</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><blockquote><p>依赖注入是具体的编程技巧<br>依赖注入不是通过new()的方式在类内部创建依赖的对象，而是预先在外部创建好对象，然后通过构造函数、函数参数的方式引入依赖对象。</p></blockquote><p>可以灵活替换依赖的类，具有比较好的扩展性。</p><h4 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h4><blockquote><p>高层模块不要依赖低层模块，他们之间应该通过抽象进行关联，另外抽象不要依赖具体实现细节，具体实现可以依赖抽象。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;控制反转、依赖反转、依赖注入&quot;&gt;&lt;a href=&quot;#控制反转、依赖反转、依赖注入&quot; class=&quot;headerlink&quot; title=&quot;控制反转、依赖反转、依赖注入&quot;&gt;&lt;/a&gt;控制反转、依赖反转、依赖注入&lt;/h3&gt;&lt;h4 id=&quot;控制反转&quot;&gt;&lt;a href=&quot;#控
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>18|接口隔离原则</title>
    <link href="https://shawnyou.tech/2020/05/24/design-pattern-notes/18%7C%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    <id>https://shawnyou.tech/2020/05/24/design-pattern-notes/18|接口隔离原则/</id>
    <published>2020-05-24T03:40:29.000Z</published>
    <updated>2020-05-24T03:49:26.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口隔离原则(ISP)指的是客户端不应该强迫依赖它不需要的接口。客户端指的是接口的调用者和使用者。</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>如何理解接口隔离原则中的接口的定义</p><ol><li><p>一组API接口集合。某些微服务接口或者类库的接口这样的API接口，客户端不应该强迫依赖它所不需要的API，这样的话容易暴露一些敏感方法出去，造成别人误用。</p></li><li><p>单个API接口或者函数。可以理解为某个函数的功能应该要职责单一，不要将多个功能逻辑放在一个函数中实现，应该把函数的功能粒度拆分更细一点，类似于单一职责原则。</p></li><li><p>OOP中的接口概念。<br>OOP中的接口概念就好比Java中的Interface,我们在设计Interface的时候要尽量保证接口隔离原则，因为具有良好接口隔离原则的接口更加灵活、易扩展、易复用，主要是接口的粒度比较小，在后期的需求变更的时候，改动的地方就比较少。</p></li></ol><h3 id="接口隔离原则与单一职责原则的区别"><a href="#接口隔离原则与单一职责原则的区别" class="headerlink" title="接口隔离原则与单一职责原则的区别"></a>接口隔离原则与单一职责原则的区别</h3><ol><li>单一职责原则针对的是模块、类、接口的设计；接口隔离原则更侧重于接口的设计，是一个用于检验接口职责是否单一的标准，如果调用者只使用部分接口或部分功能，则说明接口的设计不够职责单一。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;接口隔离原则&quot;&gt;&lt;a href=&quot;#接口隔离原则&quot; class=&quot;headerlink&quot; title=&quot;接口隔离原则&quot;&gt;&lt;/a&gt;接口隔离原则&lt;/h3&gt;&lt;p&gt;接口隔离原则(ISP)指的是客户端不应该强迫依赖它不需要的接口。客户端指的是接口的调用者和使用者。&lt;/p&gt;

      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>17|里式替换原则</title>
    <link href="https://shawnyou.tech/2020/05/23/design-pattern-notes/17%7C%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    <id>https://shawnyou.tech/2020/05/23/design-pattern-notes/17|里式替换原则/</id>
    <published>2020-05-23T12:40:29.000Z</published>
    <updated>2020-05-24T03:29:48.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="里式替换原则（LSP）"><a href="#里式替换原则（LSP）" class="headerlink" title="里式替换原则（LSP）"></a>里式替换原则（LSP）</h3><p>子类对象能够替换父类对象出现的任何地方，并且程序的逻辑性不变以及正确性不被破坏。</p><h3 id="里式替换原则与多态之间的关系"><a href="#里式替换原则与多态之间的关系" class="headerlink" title="里式替换原则与多态之间的关系"></a>里式替换原则与多态之间的关系</h3><p>晃眼一看，里式替换原则似乎说的就是多态这么一回事，多态可以替换父类出现的任何地方。但是多态和里式替换原则完全是两个事情，他们的区别与联系如下：</p><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ol><li>子类能够替换父类出现的任何地方(里式替换原则与多态)<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4></li><li>子类替换父类对象出现的地方之后，里式替换原则需要保证程序的逻辑不变以及正确性不被破坏。多态则有可能出现正确性被破坏的情况。</li><li>多态是一种代码实现思路，而里氏替换原则是一种设计原则，用于指导继承关系中子类如何去设计来保证逻辑性不变以及正确性。</li></ol><h3 id="哪些设计不满足里式替换原则"><a href="#哪些设计不满足里式替换原则" class="headerlink" title="哪些设计不满足里式替换原则"></a>哪些设计不满足里式替换原则</h3><ol><li>子类违背父类要实现的功能</li></ol><p>子类去覆盖重写父类原有的功能方法。</p><ol start="2"><li>子类违背了父类关于输入、输出、异常的约定。</li></ol><p>子类违背了父类的一些约定，导致子类替换的时候修改了以前的功能代码。</p><ol start="3"><li>如何父类的单元测试没法通过子类的单元测试，则说明子类的设计没有符合里式替换原则。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;里式替换原则（LSP）&quot;&gt;&lt;a href=&quot;#里式替换原则（LSP）&quot; class=&quot;headerlink&quot; title=&quot;里式替换原则（LSP）&quot;&gt;&lt;/a&gt;里式替换原则（LSP）&lt;/h3&gt;&lt;p&gt;子类对象能够替换父类对象出现的任何地方，并且程序的逻辑性不变以及正确
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>16|开闭原则</title>
    <link href="https://shawnyou.tech/2020/05/22/design-pattern-notes/16%7C%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <id>https://shawnyou.tech/2020/05/22/design-pattern-notes/16|开闭原则/</id>
    <published>2020-05-22T12:40:29.000Z</published>
    <updated>2020-05-22T11:41:36.241Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则（Open Close Principle）即对扩展开发，对修改关闭，指的是我们尽量新增功能代码（新增模块、类、方法），而不是去修改原有的功能代码（修改模块、功能、方法）。</p><h3 id="如何实现具有开闭原则的代码"><a href="#如何实现具有开闭原则的代码" class="headerlink" title="如何实现具有开闭原则的代码"></a>如何实现具有开闭原则的代码</h3><p>需求变更的时候通常是以新增功能代码的形式，而不是修改原有的功能代码，主要体现在以下几个方面</p><ol><li>尽量不会修改以前的单元测试</li><li>没有破坏以往代码的正常执行</li><li>新增功能时候通常以新增类、方法的形式，对应的单元测试也是新加的而不改变以前的单元测试。</li></ol><h3 id="扩展与修改没有明确的界限"><a href="#扩展与修改没有明确的界限" class="headerlink" title="扩展与修改没有明确的界限"></a>扩展与修改没有明确的界限</h3><ul><li>扩展与修改之间由于代码粒度的不同，他们之间的联系没有绝对的界限。同样的一个代码改动，在粗粒度的代码下被认为是修改，而在细粒度的代码下认为是扩展。只要能够保证系统功能的正常运行，没有破坏原有的单元测试，我们就认为是符合开闭原则的。</li><li><p>有些情况下，适当的代码修改是可以被接受的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</p><h3 id="如何做到开闭原则"><a href="#如何做到开闭原则" class="headerlink" title="如何做到开闭原则"></a>如何做到开闭原则</h3></li><li><p>时刻具备扩展意识、抽象意识、封装意识，在代码设计过程要训练向后思考的能力，为后面的需求变更留下扩展点。</p></li><li>识别代码的可变部分和不可变部分，对可变部分进行抽象封装，提供不可变的抽象接口，当以后出现其他的变化的时候，我们基于这个不可变的抽象接口，实现新的变化来替换以前的部分。</li></ul><h3 id="如何运用开闭原则"><a href="#如何运用开闭原则" class="headerlink" title="如何运用开闭原则"></a>如何运用开闭原则</h3><p>预留扩展点</p><ul><li>对于业务系统，需要对业务有足够的了解，需要掌握未来可能会有的需求变化，从而预留扩展点</li><li>对于底层技术系统，需要掌握系统如何使用，未来可能有哪些需求变化。</li><li>预留扩展点并不是需要识别出所有的扩展点，因为我们不可能在设计阶段就掌握的所有的需求变化，通常我们会针对一些短期的、成本不高的扩展点进行预留，对于复杂的、成本较高的可以等需求驱动的时候进行重构添加扩展点。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;开闭原则&quot;&gt;&lt;a href=&quot;#开闭原则&quot; class=&quot;headerlink&quot; title=&quot;开闭原则&quot;&gt;&lt;/a&gt;开闭原则&lt;/h3&gt;&lt;p&gt;开闭原则（Open Close Principle）即对扩展开发，对修改关闭，指的是我们尽量新增功能代码（新增模块、类、方法
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes,设计原则" scheme="https://shawnyou.tech/tags/Notes-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>08|事务到底是隔离的还是不隔离的</title>
    <link href="https://shawnyou.tech/2019/12/05/mysql-notes/08%7C%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/"/>
    <id>https://shawnyou.tech/2019/12/05/mysql-notes/08|事务到底是隔离的还是不隔离的/</id>
    <published>2019-12-05T07:40:29.000Z</published>
    <updated>2019-12-10T12:53:08.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO&quot;&gt;&lt;/a&gt;TODO&lt;/h3&gt;
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>15|单一职责原则</title>
    <link href="https://shawnyou.tech/2019/12/04/design-pattern-notes/15%7C%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>https://shawnyou.tech/2019/12/04/design-pattern-notes/15|单一职责原则/</id>
    <published>2019-12-04T12:40:29.000Z</published>
    <updated>2020-05-22T12:50:42.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则(SRP)"></a>单一职责原则(SRP)</h3><blockquote><p>Single Responsibility Principle（SRP）一个类或者模块只负责完成一个职责。</p></blockquote><p>模块：模块看做比类更加抽象的概念，模块可以看做比类更加粗粒度的代码块，其中包含多个类。</p><h4 id="设计准则"><a href="#设计准则" class="headerlink" title="设计准则"></a>设计准则</h4><ul><li>不要设计大而全的类</li><li>设计粒度小，功能单一的类</li><li>一个类包含两个以上业务不相干的功能，应该拆分成功能单一，粒度更细的类</li></ul><h3 id="单一职责的判断准则"><a href="#单一职责的判断准则" class="headerlink" title="单一职责的判断准则"></a>单一职责的判断准则</h3><blockquote><p>一个类是否职责单一的判断，是很难拿捏的。</p></blockquote><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> userId;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> String cityAddress;</span><br><span class="line">    <span class="keyword">private</span> regionOfAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UserInfo的设计是否满足单一职责原则？这个问题不能脱离实际的应用场景</p><ol><li>满足单一职责原则—用户的地址信息和其他信息一样都是用作展示。</li><li>不满足单一职责原则—如果用户的地址信息需要用其他用途，如电商物流中，则需要把用户的地址信息拆分出来。</li></ol></blockquote><blockquote><p>没有非常明确的、可以量化的标准来判定一个类是否足够单一。所以我们在开发工作中，没必要过度设计。我们可以先设计粗粒度的类，随着业务发展，可以将粗粒度的类拆分成几个细粒度的类。</p></blockquote><h4 id="判断准则"><a href="#判断准则" class="headerlink" title="判断准则"></a>判断准则</h4><ul><li>类中代码行数、函数或属性较多，影响了代码的可读性和可维护性。</li><li>类依赖的其他类过多，不符合高内聚、低耦合的设计思想</li><li>私有方法过多，考虑将私有方法独立到新的类，设置为public。</li><li>很难讲类起一个合适的名字，难以用一个业务名词来概括。</li></ul><blockquote><p>最终目的是提高代码的可读性、可扩展性、复用性、可维护性，所以无论是应用那种设计原则或者设计模式，都应该一次作为考量标准。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单一职责原则-SRP&quot;&gt;&lt;a href=&quot;#单一职责原则-SRP&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则(SRP)&quot;&gt;&lt;/a&gt;单一职责原则(SRP)&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Single Responsibility P
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>07|行级锁功过</title>
    <link href="https://shawnyou.tech/2019/12/04/mysql-notes/07%7C%E8%A1%8C%E7%BA%A7%E9%94%81%E5%8A%9F%E8%BF%87/"/>
    <id>https://shawnyou.tech/2019/12/04/mysql-notes/07|行级锁功过/</id>
    <published>2019-12-04T07:40:29.000Z</published>
    <updated>2019-12-08T10:31:26.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MySQL行级别由各个存储引擎实现，但是有些存储引擎不支持行级锁，例如MyISAM，所以只能使用表级锁。所以在并发控制的粒度上更粗一些。InnoDB是支持行级锁的，这也是InnoDB取代MyISAM的重要原因</p></blockquote><h3 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h3><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;update t set k=k+1 where id=1;update t set k= k+1 where id = 2</td><td>没有</td></tr><tr><td>没有</td><td>begin;update t set k=k+2 where id = 1</td></tr><tr><td>commit</td><td>没有</td></tr></tbody></table><ul><li>事务A未执行完毕之前，事务B的操作会被锁住，事务A持有了id=1和id=2的行级锁。所以尽量把持有多个行的锁的事务操作放在最后，使其影响最小。</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol><li>顾客A余额扣除电影票价</li><li>影院B余额增加电影票价</li><li>记录一条交易日志</li></ol><p>问题：如何调整顺序，使其影响最小</p><ul><li>三个操作都是原子性操作，放在一个事务里面</li><li>另一个顾客买票时，有事务冲突的就是2,需要修改同一条记录数据。</li><li>按照3、1、2的顺序，语句2的锁时间最小，减少了事务之间的锁等待，提高了并发度</li></ul><h3 id="死锁与死锁监测"><a href="#死锁与死锁监测" class="headerlink" title="死锁与死锁监测"></a>死锁与死锁监测</h3><blockquote><p>当并发系统中不同线程出现循环资源依赖。涉及的线程就回等待别的线程释放资源，就回导致几个线程进入无线等待的状态,从而导致死锁。</p></blockquote><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;update t set k=k+1 where id =1</td><td>begin;</td></tr><tr><td>没有</td><td>update t set k=k+1 where id = 2</td></tr><tr><td>update t set k = k+1 where id = 2</td><td>没有</td></tr><tr><td>没有</td><td>update t set k=k+1 where id = 1</td></tr></tbody></table><ul><li>事务A在等待事务B中id=2的行锁</li><li>事务B在等待事务A中id=1的行锁</li></ul><h4 id="如何解决死锁问题"><a href="#如何解决死锁问题" class="headerlink" title="如何解决死锁问题"></a>如何解决死锁问题</h4><ol><li>设置超时时间(innodb_lock_wait_timeout)</li></ol><ul><li>默认50s,第一个被锁住的线程在50s会超时退出。等待时间太长，对于在线服务不能容忍。</li><li>设置超时时间1s,如果只是简单的锁等待，容易造成误伤。</li></ul><ol start="2"><li>死锁检测<blockquote><p>每当一个事务被所得时候，就要看它所依赖的线程有没有被人锁住，最后判断你是否出现了循环等待。</p></blockquote></li></ol><p>死锁监测方案：</p><ul><li>如果所有事务都更新同一行记录，死锁监测的成本非常高，会导致性能问题。如1000个并发线程同时更新同一条记录，死锁监测的操作就是100万级别。这期间会消耗大量的CPU资源，效率很低。</li><li>关闭死锁监测，由业务上来保证不出现死锁。关掉死锁监测有一定的风险，当出现超时的时候，对业务是有损的。</li><li>控制并发度，使其死锁检测成本变低。当客户端很多的时候，及时每个客户端只有五个并发线程，峰值并发也可能达到3000</li><li>从设计上解决。将数据库的一行操作改成逻辑上的多行操作来减少锁冲突。如影院的余额设置在多条记录上，每次给应选加金额的时候，随机选一条来加，由此冲突概率将变成原来的1/10。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;MySQL行级别由各个存储引擎实现，但是有些存储引擎不支持行级锁，例如MyISAM，所以只能使用表级锁。所以在并发控制的粒度上更粗一些。InnoDB是支持行级锁的，这也是InnoDB取代MyISAM的重要原因&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>06|全局锁与表锁</title>
    <link href="https://shawnyou.tech/2019/12/04/mysql-notes/06%7C%E5%85%A8%E5%B1%80%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81/"/>
    <id>https://shawnyou.tech/2019/12/04/mysql-notes/06|全局锁与表锁/</id>
    <published>2019-12-04T04:40:29.000Z</published>
    <updated>2019-12-08T09:36:56.010Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据库的锁是用来解决并发问题。作为用户共享的资源，当出现并发访问的时候，数据库需要合理的控制资源的访问规则，而数据库锁就是来实现这些访问规则的重要数据结构。</p></blockquote><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><ul><li>全局锁</li><li>表级锁</li><li>行锁</li></ul><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><blockquote><p>对整个数据库加锁，数据库更新语句(更删改)，数据定义语句(建表，修改表结构)等操作都会被阻塞。</p></blockquote><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>全库逻辑备份(保证数据逻辑一致性)</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><ul><li>表锁</li></ul><p>加锁：lock tables … read/write</p><p>释放锁：手动unlock tabls，或者客户端断开的时候字段释放</p><p>影响：lock tables控制并发，锁住整张表，影响比较大。</p><ul><li>元数据锁(meta data lock,MDL)</li></ul><blockquote><p>Mysql 5.5 引入了MDL,当对一个表做增删改查的时候，加MDL读锁，当对标做结构变更操作的时候，加MDL写锁。</p></blockquote><ul><li>读锁之间不互斥。</li><li>读写锁与写锁之间互斥。保证表结构操作的安全性</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><blockquote><p>给表加字段导致系统，导致数据库挂了。</p></blockquote><ol><li>session A执行读取数据操作，这时会对表加一个MDL读锁</li><li>session B执行读取数据操作，这时会对表加一个MDL读锁，但是读锁之间不互斥，所以能够正常查询出数据。</li><li>session C这时候给表添加字段，由于session A还没有释放MDL读锁，所以session C拿不到写锁，因此会被阻塞</li><li>session D由于session C的写锁请求被阻塞，那么session D的读取请求也会被阻塞</li></ol><p>后果： 这个表的查询语句频繁，而且客户端还有重试机制，会导致整个库的线程很快爆满。MDL锁需要等到事务提交之后再释放。</p><h4 id="如何安全的给表加字段"><a href="#如何安全的给表加字段" class="headerlink" title="如何安全的给表加字段"></a>如何安全的给表加字段</h4><ol><li>查询当前执行的事务，如果有长事务在执行，则先暂停DDL,或者kill掉这个长事务。</li><li>alter table设置等待时间，在指定时间内能拿到MDL写锁最好，拿不到则退出，不阻塞后面的业务语句，后面再次重试。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;数据库的锁是用来解决并发问题。作为用户共享的资源，当出现并发访问的时候，数据库需要合理的控制资源的访问规则，而数据库锁就是来实现这些访问规则的重要数据结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;锁的分类&quot;&gt;&lt;a href=&quot;#锁的分
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>12|基于充血模型的DDD模式来开发虚拟钱包系统</title>
    <link href="https://shawnyou.tech/2019/12/02/design-pattern-notes/12%7C%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%BC%80%E5%8F%91%E8%99%9A%E6%8B%9F%E9%92%B1%E5%8C%85%E7%B3%BB%E7%BB%9F/"/>
    <id>https://shawnyou.tech/2019/12/02/design-pattern-notes/12|基于充血模型的DDD开发虚拟钱包系统/</id>
    <published>2019-12-02T12:40:29.000Z</published>
    <updated>2019-12-10T13:22:15.885Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>11|贫血模式与充血模式</title>
    <link href="https://shawnyou.tech/2019/12/02/design-pattern-notes/11%7C%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/12/02/design-pattern-notes/11|贫血模式与充血模式/</id>
    <published>2019-12-02T12:40:29.000Z</published>
    <updated>2019-12-04T14:31:25.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MVC是一种典型的贫血模型设计，违反了面向对象的设计原则，是一种面向过程的编程风格。</p></blockquote><h3 id="贫血模型与充血模式"><a href="#贫血模型与充血模式" class="headerlink" title="贫血模型与充血模式"></a>贫血模型与充血模式</h3><h4 id="什么是贫血模型的开发方式"><a href="#什么是贫血模型的开发方式" class="headerlink" title="什么是贫血模型的开发方式"></a>什么是贫血模型的开发方式</h4><p>传统的开发方式中，由于Entity和Repository组成数据访问层，Bo和Service组成业务逻辑层，Bo值包含数据，不包含业务逻辑，是典型的贫血模型设计，它将数据与操作分离，破坏了面向对象的封装特性，是典型的的面向过程的编程风格</p><h4 id="什么是充血模型的DDD开发模式"><a href="#什么是充血模型的DDD开发模式" class="headerlink" title="什么是充血模型的DDD开发模式"></a>什么是充血模型的DDD开发模式</h4><p>充血模型： 将数据和业务逻辑封装在一个类中，满足面向对象的封装特性。</p><p>领域驱动设计(DDD):领域驱动设计可以知道解耦业务系统，划分业务模块，定义业务领域模型及其交互。随着微服务的概念兴起，领域驱动设计可以可以指导服务的划分。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>基于贫血模型的传统开发模式中，Bo只包含数据，不包含业务逻辑(重service轻Bo)</li><li>基于充血模型的DDD开发模型中，Domain既包含数据，又包含业务逻辑(轻service重Domain)</li></ul><h3 id="基于贫血的传统开发模式为何如此流行"><a href="#基于贫血的传统开发模式为何如此流行" class="headerlink" title="基于贫血的传统开发模式为何如此流行"></a>基于贫血的传统开发模式为何如此流行</h3><ul><li>系统业务比较简单，不需要精心设计充血模型，设计的充血模型也比较单薄，意义不大。</li><li>相较于贫血模型，充血模型设计难度大，需要一开始设计出暴露哪些接口，定义哪些业务逻辑。</li><li>思维固化，不愿意转型。</li></ul><h3 id="哪些项目设计使用基于充血模型的DDD开发模式"><a href="#哪些项目设计使用基于充血模型的DDD开发模式" class="headerlink" title="哪些项目设计使用基于充血模型的DDD开发模式"></a>哪些项目设计使用基于充血模型的DDD开发模式</h3><ul><li>业务比较复杂的系统开发(如包含利息计算模型，还款模型的金融系统)，越复杂的系统对代码的复用性，易维护性要求就越高。DDD开发模式需要我们前期做大量的业务调研，领域驱动设计。</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;MVC是一种典型的贫血模型设计，违反了面向对象的设计原则，是一种面向过程的编程风格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;贫血模型与充血模式&quot;&gt;&lt;a href=&quot;#贫血模型与充血模式&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>如何决定用组合还是继承</title>
    <link href="https://shawnyou.tech/2019/12/01/design-pattern-notes/10%7C%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E7%94%A8%E7%BB%84%E5%90%88%E8%BF%98%E6%98%AF%E7%BB%A7%E6%89%BF/"/>
    <id>https://shawnyou.tech/2019/12/01/design-pattern-notes/10|如何决定用组合还是继承/</id>
    <published>2019-12-01T12:40:29.000Z</published>
    <updated>2019-12-04T14:25:26.131Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>组合优于继承，多用组合，少用继承</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>面向对象四个特性之一，用来表示is-a的关系，解决代码复用的问题</p></blockquote><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul><li>继承层次过深，过复杂。</li><li>不利于后期需求的变更，影响代码的可扩展性。</li><li>代码的可读性变差，需要弄清楚某个类需要哪些方法，必须阅读所有父类的代码。</li><li>破坏了类的封装性，将父类的实现细节暴露给子类，子类的实现依赖父类的子线，子类和父类高度耦合，一旦父类变化就会影响子类。</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><blockquote><p>鸟的继承体系</p></blockquote><ul><li>有会飞的鸟也有不会飞的鸟，，当父类定义一个fly()的方法，则子类都会拥有飞行的功能，对于鸵鸟，可以重写fly()方法，抛出异常即可，这样虽然可行，但是不够优美，违反最少知识原则，暴露了不该暴露的接口给外部。</li><li>后序考虑鸟会不会叫、鸟下不下单等属性，那么继承体系就非常庞大了。</li></ul><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><blockquote><p>有什么手段可以代替继承，并且避免继承的不足–组合+接口+委托</p></blockquote><ul><li><p>多态(接口)，运用接口可以实现继承体系中的多态的作用。接口表示某种行为特征，Flyable(可以飞的行为)，EggLayable(可下蛋的行为)</p></li><li><p>代码复用(组合+委托)，由于每一个会飞的鸟都要去实现Flyable，所有我们可以定义一个实现类，然后通过组合和委托的形式，将Flyable的实现类组合进去</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyAbility</span> <span class="title">implement</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrish</span> <span class="keyword">implements</span> <span class="title">Tweetable</span>,<span class="title">EggLayable</span></span>&#123;</span><br><span class="line">    <span class="comment">//组合</span></span><br><span class="line">    <span class="keyword">private</span> TweetAbility tweetAbility = <span class="keyword">new</span> TweetAbility();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tweet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//委托</span></span><br><span class="line">        tweetAbility.tweet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何决定选择组合还是继承"><a href="#如何决定选择组合还是继承" class="headerlink" title="如何决定选择组合还是继承"></a>如何决定选择组合还是继承</h3><h4 id="组合的不足"><a href="#组合的不足" class="headerlink" title="组合的不足"></a>组合的不足</h4><ul><li>更细粒度的类划分，更多的类和接口</li><li>增加代码的复杂程度和维护成本</li></ul><h4 id="继承的不足"><a href="#继承的不足" class="headerlink" title="继承的不足"></a>继承的不足</h4><ul><li>继承层次过深灰降低代码的扩展性</li><li>代码可读性差</li></ul><h4 id="继承的条件"><a href="#继承的条件" class="headerlink" title="继承的条件"></a>继承的条件</h4><ul><li>类之间的继承结构稳定(不会轻易改变)</li><li>继承层次浅(2-3层)</li><li>继承关系简单</li></ul><h3 id="继承和组合在设计模式中的应用"><a href="#继承和组合在设计模式中的应用" class="headerlink" title="继承和组合在设计模式中的应用"></a>继承和组合在设计模式中的应用</h3><ul><li>继承(模板模式)</li><li>组合(装饰器模式、策略模式、组合模式)</li></ul><blockquote><p>多用组合，少用继承并不是绝对的，需要具体情况具体分析，控制好他们的副作用，发挥他们各自的优势。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;组合优于继承，多用组合，少用继承&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;面向对象四个
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>05|深入浅出索引(下)</title>
    <link href="https://shawnyou.tech/2019/11/24/mysql-notes/05%7C%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95(%E4%B8%8B)/"/>
    <id>https://shawnyou.tech/2019/11/24/mysql-notes/05|深入浅出索引(下)/</id>
    <published>2019-11-24T04:40:29.000Z</published>
    <updated>2019-11-24T08:34:53.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h3><blockquote><p>select * from T where K betwwen 3 and 5 需要执行几次树的搜索操作？ ID为主键索引，K为普通索引</p></blockquote><ul><li>在K的普通索引树上找到K=3对应的记录，取得对应的主键ID=300值—普通索引</li><li>通过主键ID=300查到对应的记录—主键索引(回表)</li><li>在K索引树取下一个值K=5,取得主键ID=500—普通索引</li><li>根据ID=500取得对应的记录—主键索引(回表)</li><li>K索引树取下一个值k=6,不满足条件，循环结束—普通索引</li></ul><p>这个过程总共搜索了三次普通索引，二次主键索引(回表)。如何优化索引，避免回表过程？可以使用覆盖索引</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><blockquote><p>select ID from T where K betwwen 3 and 5. 由于查询的返回值通过普通索引就能够获取，所以就不用回表去查主键索引了。能够减少数的搜索次数，提高查询性能。</p></blockquote><h4 id="覆盖索引的使用场景"><a href="#覆盖索引的使用场景" class="headerlink" title="覆盖索引的使用场景"></a>覆盖索引的使用场景</h4><ul><li>联合索引</li></ul><p>身份证号是市民的唯一表示，而身份证号通常应该建立普通索引，如果有一个需求是通过身份证号查市民的真实姓名，可以建立身份证号和姓名的联合索引，由此可以通过直接在身份证的普通索引上直接搜索到姓名，由此可以避免回表的操作，减少语句执行时间。</p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><blockquote><p>B+树可以通过索引的最左前缀，来定位记录，由此可以避免为每一种查询都设计一个索引</p></blockquote><ol><li>最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符</li></ol><ul><li>联合索引(name,age), 如(“张三”，10)，通过张三可以通过索引检索到记录，通过”张”也可以通过索引检索到记录。</li></ul><ol start="2"><li>如果通过调配联合索引的字段顺序来减少索引的维护？</li></ol><ul><li>评估索引的复用能力，当已经有了(a,b)的联合索引，就不需要单独在a上面建立索引了。</li><li>空间的考虑。如果已经有了(age,name)的索引，因为name的字段比age大，所以我们可以调配字段顺序(name,age),就只需要再加一个age的单字段索引。</li></ul><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><blockquote><p>select * from tuser where name like “张%” and age = 10 and is ismale = 1 对于这样的查询语句，在老版本的mysql中，age和ismale没法通过最左前缀进行匹配。需要回表到主键索引进行过滤。</p></blockquote><ul><li>Mysql5.6之前，通过普通索引找到对应的主键，然后回到主键索引上找到对应的记录，最后去比对字段值去过滤。</li><li>Mysql5.6之后，Mysql进行索引下推优化，可以普通索引遍历过程中，对索引包含的字段(age)先作判断，由此在普通索引搜索过程过滤掉不满足条件的记录，减少了回表的次数。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;索引分析&quot;&gt;&lt;a href=&quot;#索引分析&quot; class=&quot;headerlink&quot; title=&quot;索引分析&quot;&gt;&lt;/a&gt;索引分析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;select * from T where K betwwen 3 and 5 需要执行几次树的搜
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>03|事务隔离</title>
    <link href="https://shawnyou.tech/2019/11/22/mysql-notes/03%7C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>https://shawnyou.tech/2019/11/22/mysql-notes/03|事务隔离/</id>
    <published>2019-11-22T14:47:29.000Z</published>
    <updated>2019-11-23T10:37:43.518Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>事务保证一组数据库操作，要么全部成功，要么全部失败。</p></blockquote><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ol><li>Atomicity(原子性)</li><li>Consistency(一致性)</li><li>Isolation(隔离性)</li><li>Durability(持久性)</li></ol><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><blockquote><p>为什么需要隔离性</p></blockquote><p>因为多个事务同时执行的时候，容易引发脏读、不可重复读、幻读等问题。</p><ol><li>脏读</li></ol><p>一个事务在处理过程中，读取了别的事务未提交的脏数据。如果别的事务回滚，那么我们拿到的数据是不准确的，由此会造成一定的问题。</p><ol start="2"><li><p>不可重复读<br>一个事务在处理过程，两次查询的数据不一样。这是因为第二次查询读取了别的事务已经提交的变更。那么我们在这个事务操作中就能看到别的事务提交的变更。</p></li><li><p>幻读<br>一个事务在处理过程中，两次查询的数据不一样，第二次查询读取了别的事务已经提交的变更。</p></li></ol><ul><li>不可重复读和幻读都在还未提交的事务过程中读取了另一个已经提交的事务变更。不可重读读针对的是同一个数据项，而幻读针对的是一批数据整体。例如小编去取钱，</li><li>不可重复读：重点在于修改，两次读取的数据不一样</li><li>幻读：重点在新增和删除，比如这里有一个事务1要查询公司里面工资1000元以上的职工有10人，这时另一个事务2里面，HR新增了一个新员工，工资也在1000元以上。这时候事务1在次查询，发现工资1000元以上的人员增加到了11个人。</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><blockquote><p>多个事务同时执行，引发的脏读、不可重复读、幻读等问题，就产生了‘隔离级别’的概念。隔离越严实，效率就越低，但数据一致性的程度越高。由此需要在隔离性和效率之间寻找一个平衡点。</p></blockquote><ol><li>读未提交(read uncommitted)</li></ol><blockquote><p>一个事务还未提交的时候，它的变更能被别的事务看到。</p></blockquote><ol start="2"><li>读提交(read committed)</li></ol><p>一个事务提交之后，它的改动才能被其他事务看到。事务A修改了一项数据，B事务读取不到变动，只有等事务A提交之后，B事务才能够读取。由此可以避免脏读，但是会造成不可重复读和幻读。</p><ol start="3"><li>可重复读(repeatable read)</li></ol><p>一个事务在执行过程中看到的数据和事务启动是看到的数据时一致的。当事务A开始读取一条记录的时候，事务B是不能够进行修改的。由此可以避免不可重复读，但是还是会造成幻读(事务A读取一些数据，事务B插入或者删除一些数据，这时候在此读取，会发现数据多了或者少了)。</p><ol start="4"><li>串行化(serializable)</li></ol><p>‘读’和‘写’会进行加锁，读写锁发生冲突时候，后访问的事务必须等前一个事务执行完成。</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><blockquote><p>事务的隔离级别往往和视图有关系，不同的隔离级别创建视图的顺序是不一样。视图可以理解为数据副本，每次创建视图，将当前已持久化的数据创建副本，后面直接从副本读取，从而达到数据隔离。</p></blockquote><ol><li>读未提交</li></ol><p>没有视图概念，不同事务在读未提交的隔离级别上直接读取记录的最新值，容易出现脏读的情况。</p><ol start="2"><li>读提交</li></ol><p>视图在每个SQL开始执行的时候创建的。所以第二次查询的时候，别的事务已经提交了数据，重新建立的视图里面包含已经变更的数据。因此能够读取别的事务修改的数据。</p><ol start="3"><li>可重复读</li></ol><p>视图是在事务启动的时候创建的。（TODO）</p><ol start="4"><li>串行化</li></ol><p>直接用加锁的方式避免并行访问</p><h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><h4 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h4><p>同一条记录在系统中可以存在多个版本。</p><h4 id="避免使用长事务"><a href="#避免使用长事务" class="headerlink" title="避免使用长事务"></a>避免使用长事务</h4><ul><li>长事务存在很老的事务视图，在未提交之前，所有的回滚记录都必须保留，会导致大量占用存储空间。</li><li>占用锁资源，拖垮数据库。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;事务保证一组数据库操作，要么全部成功，要么全部失败。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h3&gt;&lt;ol&gt;
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
</feed>

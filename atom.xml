<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>攻城虱</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shawnyou.tech/"/>
  <updated>2020-05-22T11:41:36.241Z</updated>
  <id>https://shawnyou.tech/</id>
  
  <author>
    <name>Shawn You</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>16|开闭原则</title>
    <link href="https://shawnyou.tech/2020/05/22/design-pattern-notes/16%7C%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <id>https://shawnyou.tech/2020/05/22/design-pattern-notes/16|开闭原则/</id>
    <published>2020-05-22T12:40:29.000Z</published>
    <updated>2020-05-22T11:41:36.241Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则（Open Close Principle）即对扩展开发，对修改关闭，指的是我们尽量新增功能代码（新增模块、类、方法），而不是去修改原有的功能代码（修改模块、功能、方法）。</p><h3 id="如何实现具有开闭原则的代码"><a href="#如何实现具有开闭原则的代码" class="headerlink" title="如何实现具有开闭原则的代码"></a>如何实现具有开闭原则的代码</h3><p>需求变更的时候通常是以新增功能代码的形式，而不是修改原有的功能代码，主要体现在以下几个方面</p><ol><li>尽量不会修改以前的单元测试</li><li>没有破坏以往代码的正常执行</li><li>新增功能时候通常以新增类、方法的形式，对应的单元测试也是新加的而不改变以前的单元测试。</li></ol><h3 id="扩展与修改没有明确的界限"><a href="#扩展与修改没有明确的界限" class="headerlink" title="扩展与修改没有明确的界限"></a>扩展与修改没有明确的界限</h3><ul><li>扩展与修改之间由于代码粒度的不同，他们之间的联系没有绝对的界限。同样的一个代码改动，在粗粒度的代码下被认为是修改，而在细粒度的代码下认为是扩展。只要能够保证系统功能的正常运行，没有破坏原有的单元测试，我们就认为是符合开闭原则的。</li><li><p>有些情况下，适当的代码修改是可以被接受的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</p><h3 id="如何做到开闭原则"><a href="#如何做到开闭原则" class="headerlink" title="如何做到开闭原则"></a>如何做到开闭原则</h3></li><li><p>时刻具备扩展意识、抽象意识、封装意识，在代码设计过程要训练向后思考的能力，为后面的需求变更留下扩展点。</p></li><li>识别代码的可变部分和不可变部分，对可变部分进行抽象封装，提供不可变的抽象接口，当以后出现其他的变化的时候，我们基于这个不可变的抽象接口，实现新的变化来替换以前的部分。</li></ul><h3 id="如何运用开闭原则"><a href="#如何运用开闭原则" class="headerlink" title="如何运用开闭原则"></a>如何运用开闭原则</h3><p>预留扩展点</p><ul><li>对于业务系统，需要对业务有足够的了解，需要掌握未来可能会有的需求变化，从而预留扩展点</li><li>对于底层技术系统，需要掌握系统如何使用，未来可能有哪些需求变化。</li><li>预留扩展点并不是需要识别出所有的扩展点，因为我们不可能在设计阶段就掌握的所有的需求变化，通常我们会针对一些短期的、成本不高的扩展点进行预留，对于复杂的、成本较高的可以等需求驱动的时候进行重构添加扩展点。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;开闭原则&quot;&gt;&lt;a href=&quot;#开闭原则&quot; class=&quot;headerlink&quot; title=&quot;开闭原则&quot;&gt;&lt;/a&gt;开闭原则&lt;/h3&gt;&lt;p&gt;开闭原则（Open Close Principle）即对扩展开发，对修改关闭，指的是我们尽量新增功能代码（新增模块、类、方法
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes,设计原则" scheme="https://shawnyou.tech/tags/Notes-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>08|事务到底是隔离的还是不隔离的</title>
    <link href="https://shawnyou.tech/2019/12/05/mysql-notes/08%7C%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84/"/>
    <id>https://shawnyou.tech/2019/12/05/mysql-notes/08|事务到底是隔离的还是不隔离的/</id>
    <published>2019-12-05T07:40:29.000Z</published>
    <updated>2019-12-10T12:53:08.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO&quot;&gt;&lt;/a&gt;TODO&lt;/h3&gt;
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>15|单一职责原则</title>
    <link href="https://shawnyou.tech/2019/12/04/design-pattern-notes/15%7C%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>https://shawnyou.tech/2019/12/04/design-pattern-notes/15|单一职责原则/</id>
    <published>2019-12-04T12:40:29.000Z</published>
    <updated>2019-12-10T13:20:21.565Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则(SRP)"></a>单一职责原则(SRP)</h3><blockquote><p>Single Responsibility Principle（SRP）一个类或者模块只负责完成一个职责。</p></blockquote><p>模块：模块看做比类更加抽象的概念，模块可以看做比类更加粗粒度的代码块，其中包含多个类。</p><h4 id="设计准则"><a href="#设计准则" class="headerlink" title="设计准则"></a>设计准则</h4><ul><li>不要设计大而全的类</li><li>设计粒度小，功能单一的类</li><li>一个类包含两个以上业务不相干的功能，应该拆分成功能单一，粒度更细的类</li></ul><h3 id="单一职责的判断准则"><a href="#单一职责的判断准则" class="headerlink" title="单一职责的判断准则"></a>单一职责的判断准则</h3><blockquote><p>一个类是否职责单一的判断，是很难拿捏的。</p></blockquote><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> userId;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> String cityAddress;</span><br><span class="line">    <span class="keyword">private</span> regionOfAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>UserInfo的设计是否满足单一职责原则？这个问题不能脱离实际的应用场景</p><ol><li>满足单一职责原则—用户的地址信息和其他信息一样都是用作展示。</li><li>不满足单一职责原则—如果用户的地址信息需要用其他用途，如电商物流中，则需要把用户的地址信息拆分出来。</li></ol></blockquote><blockquote><p>没有非常明确的、可以量化的标准来判定一个类是否足够单一。所以我们在开发工作中，没必要过度设计。我们可以先设计粗粒度的类，随着业务发展，可以将粗粒度的类拆分成几个细粒度的类。</p></blockquote><h4 id="判断准则"><a href="#判断准则" class="headerlink" title="判断准则"></a>判断准则</h4><ul><li>类中代码行数、函数或属性较多，影响了代码的可读性和可维护性。</li><li>类依赖的其他类过多，不符合高内聚、低耦合的设计思想</li><li>私有方法过多，考虑将私有方法独立到新的类，设置为public。</li><li>很难讲类起一个合适的名字，难以用一个业务名词来概括。</li></ul><blockquote><p>最终目的是提高代码的可读性、可扩展性、复用性、可维护性，所以无论是应用那种设计原则或者设计模式，都应该一次作为考量标准。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单一职责原则-SRP&quot;&gt;&lt;a href=&quot;#单一职责原则-SRP&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则(SRP)&quot;&gt;&lt;/a&gt;单一职责原则(SRP)&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Single Responsibility P
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>07|行级锁功过</title>
    <link href="https://shawnyou.tech/2019/12/04/mysql-notes/07%7C%E8%A1%8C%E7%BA%A7%E9%94%81%E5%8A%9F%E8%BF%87/"/>
    <id>https://shawnyou.tech/2019/12/04/mysql-notes/07|行级锁功过/</id>
    <published>2019-12-04T07:40:29.000Z</published>
    <updated>2019-12-08T10:31:26.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MySQL行级别由各个存储引擎实现，但是有些存储引擎不支持行级锁，例如MyISAM，所以只能使用表级锁。所以在并发控制的粒度上更粗一些。InnoDB是支持行级锁的，这也是InnoDB取代MyISAM的重要原因</p></blockquote><h3 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h3><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;update t set k=k+1 where id=1;update t set k= k+1 where id = 2</td><td>没有</td></tr><tr><td>没有</td><td>begin;update t set k=k+2 where id = 1</td></tr><tr><td>commit</td><td>没有</td></tr></tbody></table><ul><li>事务A未执行完毕之前，事务B的操作会被锁住，事务A持有了id=1和id=2的行级锁。所以尽量把持有多个行的锁的事务操作放在最后，使其影响最小。</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol><li>顾客A余额扣除电影票价</li><li>影院B余额增加电影票价</li><li>记录一条交易日志</li></ol><p>问题：如何调整顺序，使其影响最小</p><ul><li>三个操作都是原子性操作，放在一个事务里面</li><li>另一个顾客买票时，有事务冲突的就是2,需要修改同一条记录数据。</li><li>按照3、1、2的顺序，语句2的锁时间最小，减少了事务之间的锁等待，提高了并发度</li></ul><h3 id="死锁与死锁监测"><a href="#死锁与死锁监测" class="headerlink" title="死锁与死锁监测"></a>死锁与死锁监测</h3><blockquote><p>当并发系统中不同线程出现循环资源依赖。涉及的线程就回等待别的线程释放资源，就回导致几个线程进入无线等待的状态,从而导致死锁。</p></blockquote><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;update t set k=k+1 where id =1</td><td>begin;</td></tr><tr><td>没有</td><td>update t set k=k+1 where id = 2</td></tr><tr><td>update t set k = k+1 where id = 2</td><td>没有</td></tr><tr><td>没有</td><td>update t set k=k+1 where id = 1</td></tr></tbody></table><ul><li>事务A在等待事务B中id=2的行锁</li><li>事务B在等待事务A中id=1的行锁</li></ul><h4 id="如何解决死锁问题"><a href="#如何解决死锁问题" class="headerlink" title="如何解决死锁问题"></a>如何解决死锁问题</h4><ol><li>设置超时时间(innodb_lock_wait_timeout)</li></ol><ul><li>默认50s,第一个被锁住的线程在50s会超时退出。等待时间太长，对于在线服务不能容忍。</li><li>设置超时时间1s,如果只是简单的锁等待，容易造成误伤。</li></ul><ol start="2"><li>死锁检测<blockquote><p>每当一个事务被所得时候，就要看它所依赖的线程有没有被人锁住，最后判断你是否出现了循环等待。</p></blockquote></li></ol><p>死锁监测方案：</p><ul><li>如果所有事务都更新同一行记录，死锁监测的成本非常高，会导致性能问题。如1000个并发线程同时更新同一条记录，死锁监测的操作就是100万级别。这期间会消耗大量的CPU资源，效率很低。</li><li>关闭死锁监测，由业务上来保证不出现死锁。关掉死锁监测有一定的风险，当出现超时的时候，对业务是有损的。</li><li>控制并发度，使其死锁检测成本变低。当客户端很多的时候，及时每个客户端只有五个并发线程，峰值并发也可能达到3000</li><li>从设计上解决。将数据库的一行操作改成逻辑上的多行操作来减少锁冲突。如影院的余额设置在多条记录上，每次给应选加金额的时候，随机选一条来加，由此冲突概率将变成原来的1/10。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;MySQL行级别由各个存储引擎实现，但是有些存储引擎不支持行级锁，例如MyISAM，所以只能使用表级锁。所以在并发控制的粒度上更粗一些。InnoDB是支持行级锁的，这也是InnoDB取代MyISAM的重要原因&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>06|全局锁与表锁</title>
    <link href="https://shawnyou.tech/2019/12/04/mysql-notes/06%7C%E5%85%A8%E5%B1%80%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81/"/>
    <id>https://shawnyou.tech/2019/12/04/mysql-notes/06|全局锁与表锁/</id>
    <published>2019-12-04T04:40:29.000Z</published>
    <updated>2019-12-08T09:36:56.010Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据库的锁是用来解决并发问题。作为用户共享的资源，当出现并发访问的时候，数据库需要合理的控制资源的访问规则，而数据库锁就是来实现这些访问规则的重要数据结构。</p></blockquote><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><ul><li>全局锁</li><li>表级锁</li><li>行锁</li></ul><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><blockquote><p>对整个数据库加锁，数据库更新语句(更删改)，数据定义语句(建表，修改表结构)等操作都会被阻塞。</p></blockquote><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>全库逻辑备份(保证数据逻辑一致性)</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><ul><li>表锁</li></ul><p>加锁：lock tables … read/write</p><p>释放锁：手动unlock tabls，或者客户端断开的时候字段释放</p><p>影响：lock tables控制并发，锁住整张表，影响比较大。</p><ul><li>元数据锁(meta data lock,MDL)</li></ul><blockquote><p>Mysql 5.5 引入了MDL,当对一个表做增删改查的时候，加MDL读锁，当对标做结构变更操作的时候，加MDL写锁。</p></blockquote><ul><li>读锁之间不互斥。</li><li>读写锁与写锁之间互斥。保证表结构操作的安全性</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><blockquote><p>给表加字段导致系统，导致数据库挂了。</p></blockquote><ol><li>session A执行读取数据操作，这时会对表加一个MDL读锁</li><li>session B执行读取数据操作，这时会对表加一个MDL读锁，但是读锁之间不互斥，所以能够正常查询出数据。</li><li>session C这时候给表添加字段，由于session A还没有释放MDL读锁，所以session C拿不到写锁，因此会被阻塞</li><li>session D由于session C的写锁请求被阻塞，那么session D的读取请求也会被阻塞</li></ol><p>后果： 这个表的查询语句频繁，而且客户端还有重试机制，会导致整个库的线程很快爆满。MDL锁需要等到事务提交之后再释放。</p><h4 id="如何安全的给表加字段"><a href="#如何安全的给表加字段" class="headerlink" title="如何安全的给表加字段"></a>如何安全的给表加字段</h4><ol><li>查询当前执行的事务，如果有长事务在执行，则先暂停DDL,或者kill掉这个长事务。</li><li>alter table设置等待时间，在指定时间内能拿到MDL写锁最好，拿不到则退出，不阻塞后面的业务语句，后面再次重试。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;数据库的锁是用来解决并发问题。作为用户共享的资源，当出现并发访问的时候，数据库需要合理的控制资源的访问规则，而数据库锁就是来实现这些访问规则的重要数据结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;锁的分类&quot;&gt;&lt;a href=&quot;#锁的分
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>11|贫血模式与充血模式</title>
    <link href="https://shawnyou.tech/2019/12/02/design-pattern-notes/11%7C%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/12/02/design-pattern-notes/11|贫血模式与充血模式/</id>
    <published>2019-12-02T12:40:29.000Z</published>
    <updated>2019-12-04T14:31:25.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MVC是一种典型的贫血模型设计，违反了面向对象的设计原则，是一种面向过程的编程风格。</p></blockquote><h3 id="贫血模型与充血模式"><a href="#贫血模型与充血模式" class="headerlink" title="贫血模型与充血模式"></a>贫血模型与充血模式</h3><h4 id="什么是贫血模型的开发方式"><a href="#什么是贫血模型的开发方式" class="headerlink" title="什么是贫血模型的开发方式"></a>什么是贫血模型的开发方式</h4><p>传统的开发方式中，由于Entity和Repository组成数据访问层，Bo和Service组成业务逻辑层，Bo值包含数据，不包含业务逻辑，是典型的贫血模型设计，它将数据与操作分离，破坏了面向对象的封装特性，是典型的的面向过程的编程风格</p><h4 id="什么是充血模型的DDD开发模式"><a href="#什么是充血模型的DDD开发模式" class="headerlink" title="什么是充血模型的DDD开发模式"></a>什么是充血模型的DDD开发模式</h4><p>充血模型： 将数据和业务逻辑封装在一个类中，满足面向对象的封装特性。</p><p>领域驱动设计(DDD):领域驱动设计可以知道解耦业务系统，划分业务模块，定义业务领域模型及其交互。随着微服务的概念兴起，领域驱动设计可以可以指导服务的划分。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>基于贫血模型的传统开发模式中，Bo只包含数据，不包含业务逻辑(重service轻Bo)</li><li>基于充血模型的DDD开发模型中，Domain既包含数据，又包含业务逻辑(轻service重Domain)</li></ul><h3 id="基于贫血的传统开发模式为何如此流行"><a href="#基于贫血的传统开发模式为何如此流行" class="headerlink" title="基于贫血的传统开发模式为何如此流行"></a>基于贫血的传统开发模式为何如此流行</h3><ul><li>系统业务比较简单，不需要精心设计充血模型，设计的充血模型也比较单薄，意义不大。</li><li>相较于贫血模型，充血模型设计难度大，需要一开始设计出暴露哪些接口，定义哪些业务逻辑。</li><li>思维固化，不愿意转型。</li></ul><h3 id="哪些项目设计使用基于充血模型的DDD开发模式"><a href="#哪些项目设计使用基于充血模型的DDD开发模式" class="headerlink" title="哪些项目设计使用基于充血模型的DDD开发模式"></a>哪些项目设计使用基于充血模型的DDD开发模式</h3><ul><li>业务比较复杂的系统开发(如包含利息计算模型，还款模型的金融系统)，越复杂的系统对代码的复用性，易维护性要求就越高。DDD开发模式需要我们前期做大量的业务调研，领域驱动设计。</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;MVC是一种典型的贫血模型设计，违反了面向对象的设计原则，是一种面向过程的编程风格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;贫血模型与充血模式&quot;&gt;&lt;a href=&quot;#贫血模型与充血模式&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>12|基于充血模型的DDD模式来开发虚拟钱包系统</title>
    <link href="https://shawnyou.tech/2019/12/02/design-pattern-notes/12%7C%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84DDD%E5%BC%80%E5%8F%91%E8%99%9A%E6%8B%9F%E9%92%B1%E5%8C%85%E7%B3%BB%E7%BB%9F/"/>
    <id>https://shawnyou.tech/2019/12/02/design-pattern-notes/12|基于充血模型的DDD开发虚拟钱包系统/</id>
    <published>2019-12-02T12:40:29.000Z</published>
    <updated>2019-12-10T13:22:15.885Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>如何决定用组合还是继承</title>
    <link href="https://shawnyou.tech/2019/12/01/design-pattern-notes/10%7C%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E7%94%A8%E7%BB%84%E5%90%88%E8%BF%98%E6%98%AF%E7%BB%A7%E6%89%BF/"/>
    <id>https://shawnyou.tech/2019/12/01/design-pattern-notes/10|如何决定用组合还是继承/</id>
    <published>2019-12-01T12:40:29.000Z</published>
    <updated>2019-12-04T14:25:26.131Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>组合优于继承，多用组合，少用继承</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>面向对象四个特性之一，用来表示is-a的关系，解决代码复用的问题</p></blockquote><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul><li>继承层次过深，过复杂。</li><li>不利于后期需求的变更，影响代码的可扩展性。</li><li>代码的可读性变差，需要弄清楚某个类需要哪些方法，必须阅读所有父类的代码。</li><li>破坏了类的封装性，将父类的实现细节暴露给子类，子类的实现依赖父类的子线，子类和父类高度耦合，一旦父类变化就会影响子类。</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><blockquote><p>鸟的继承体系</p></blockquote><ul><li>有会飞的鸟也有不会飞的鸟，，当父类定义一个fly()的方法，则子类都会拥有飞行的功能，对于鸵鸟，可以重写fly()方法，抛出异常即可，这样虽然可行，但是不够优美，违反最少知识原则，暴露了不该暴露的接口给外部。</li><li>后序考虑鸟会不会叫、鸟下不下单等属性，那么继承体系就非常庞大了。</li></ul><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><blockquote><p>有什么手段可以代替继承，并且避免继承的不足–组合+接口+委托</p></blockquote><ul><li><p>多态(接口)，运用接口可以实现继承体系中的多态的作用。接口表示某种行为特征，Flyable(可以飞的行为)，EggLayable(可下蛋的行为)</p></li><li><p>代码复用(组合+委托)，由于每一个会飞的鸟都要去实现Flyable，所有我们可以定义一个实现类，然后通过组合和委托的形式，将Flyable的实现类组合进去</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyAbility</span> <span class="title">implement</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrish</span> <span class="keyword">implements</span> <span class="title">Tweetable</span>,<span class="title">EggLayable</span></span>&#123;</span><br><span class="line">    <span class="comment">//组合</span></span><br><span class="line">    <span class="keyword">private</span> TweetAbility tweetAbility = <span class="keyword">new</span> TweetAbility();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tweet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//委托</span></span><br><span class="line">        tweetAbility.tweet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何决定选择组合还是继承"><a href="#如何决定选择组合还是继承" class="headerlink" title="如何决定选择组合还是继承"></a>如何决定选择组合还是继承</h3><h4 id="组合的不足"><a href="#组合的不足" class="headerlink" title="组合的不足"></a>组合的不足</h4><ul><li>更细粒度的类划分，更多的类和接口</li><li>增加代码的复杂程度和维护成本</li></ul><h4 id="继承的不足"><a href="#继承的不足" class="headerlink" title="继承的不足"></a>继承的不足</h4><ul><li>继承层次过深灰降低代码的扩展性</li><li>代码可读性差</li></ul><h4 id="继承的条件"><a href="#继承的条件" class="headerlink" title="继承的条件"></a>继承的条件</h4><ul><li>类之间的继承结构稳定(不会轻易改变)</li><li>继承层次浅(2-3层)</li><li>继承关系简单</li></ul><h3 id="继承和组合在设计模式中的应用"><a href="#继承和组合在设计模式中的应用" class="headerlink" title="继承和组合在设计模式中的应用"></a>继承和组合在设计模式中的应用</h3><ul><li>继承(模板模式)</li><li>组合(装饰器模式、策略模式、组合模式)</li></ul><blockquote><p>多用组合，少用继承并不是绝对的，需要具体情况具体分析，控制好他们的副作用，发挥他们各自的优势。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;组合优于继承，多用组合，少用继承&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;面向对象四个
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>05|深入浅出索引(下)</title>
    <link href="https://shawnyou.tech/2019/11/24/mysql-notes/05%7C%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95(%E4%B8%8B)/"/>
    <id>https://shawnyou.tech/2019/11/24/mysql-notes/05|深入浅出索引(下)/</id>
    <published>2019-11-24T04:40:29.000Z</published>
    <updated>2019-11-24T08:34:53.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h3><blockquote><p>select * from T where K betwwen 3 and 5 需要执行几次树的搜索操作？ ID为主键索引，K为普通索引</p></blockquote><ul><li>在K的普通索引树上找到K=3对应的记录，取得对应的主键ID=300值—普通索引</li><li>通过主键ID=300查到对应的记录—主键索引(回表)</li><li>在K索引树取下一个值K=5,取得主键ID=500—普通索引</li><li>根据ID=500取得对应的记录—主键索引(回表)</li><li>K索引树取下一个值k=6,不满足条件，循环结束—普通索引</li></ul><p>这个过程总共搜索了三次普通索引，二次主键索引(回表)。如何优化索引，避免回表过程？可以使用覆盖索引</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><blockquote><p>select ID from T where K betwwen 3 and 5. 由于查询的返回值通过普通索引就能够获取，所以就不用回表去查主键索引了。能够减少数的搜索次数，提高查询性能。</p></blockquote><h4 id="覆盖索引的使用场景"><a href="#覆盖索引的使用场景" class="headerlink" title="覆盖索引的使用场景"></a>覆盖索引的使用场景</h4><ul><li>联合索引</li></ul><p>身份证号是市民的唯一表示，而身份证号通常应该建立普通索引，如果有一个需求是通过身份证号查市民的真实姓名，可以建立身份证号和姓名的联合索引，由此可以通过直接在身份证的普通索引上直接搜索到姓名，由此可以避免回表的操作，减少语句执行时间。</p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><blockquote><p>B+树可以通过索引的最左前缀，来定位记录，由此可以避免为每一种查询都设计一个索引</p></blockquote><ol><li>最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符</li></ol><ul><li>联合索引(name,age), 如(“张三”，10)，通过张三可以通过索引检索到记录，通过”张”也可以通过索引检索到记录。</li></ul><ol start="2"><li>如果通过调配联合索引的字段顺序来减少索引的维护？</li></ol><ul><li>评估索引的复用能力，当已经有了(a,b)的联合索引，就不需要单独在a上面建立索引了。</li><li>空间的考虑。如果已经有了(age,name)的索引，因为name的字段比age大，所以我们可以调配字段顺序(name,age),就只需要再加一个age的单字段索引。</li></ul><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><blockquote><p>select * from tuser where name like “张%” and age = 10 and is ismale = 1 对于这样的查询语句，在老版本的mysql中，age和ismale没法通过最左前缀进行匹配。需要回表到主键索引进行过滤。</p></blockquote><ul><li>Mysql5.6之前，通过普通索引找到对应的主键，然后回到主键索引上找到对应的记录，最后去比对字段值去过滤。</li><li>Mysql5.6之后，Mysql进行索引下推优化，可以普通索引遍历过程中，对索引包含的字段(age)先作判断，由此在普通索引搜索过程过滤掉不满足条件的记录，减少了回表的次数。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;索引分析&quot;&gt;&lt;a href=&quot;#索引分析&quot; class=&quot;headerlink&quot; title=&quot;索引分析&quot;&gt;&lt;/a&gt;索引分析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;select * from T where K betwwen 3 and 5 需要执行几次树的搜
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>04|深入浅出索引(上)</title>
    <link href="https://shawnyou.tech/2019/11/22/mysql-notes/04%7C%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95(%E4%B8%8A)/"/>
    <id>https://shawnyou.tech/2019/11/22/mysql-notes/04|深入浅出索引(上)/</id>
    <published>2019-11-22T14:47:29.000Z</published>
    <updated>2019-11-24T07:42:08.760Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>索引类似于书本的目录，能够提高数据查询效率。</p></blockquote><h3 id="常见的索引模型"><a href="#常见的索引模型" class="headerlink" title="常见的索引模型"></a>常见的索引模型</h3><ol><li>哈希表<blockquote><p>key-value的数据存储结构。通过哈希函数将key换算成一个具体的数组位置，将value放在对应的数组位置。多余哈希冲突，则使用拉链法进行解决。</p></blockquote></li></ol><ul><li>插入很快。因为可以直接往后追加</li><li>区间查询速度很慢。因为因为数据存储不是有序的。</li><li>哈希表适合等值查询的场景(Memcached和一些NoSQL引擎)</li></ul><ol start="2"><li>有序数组<blockquote><p>有序数组在等值查询和范围查询的场景中的性能都非常优秀。</p></blockquote></li></ol><ul><li>查询效率高，利用二分法进行查询。，同样也支持范围查询</li><li>新增记录成本太高，因为每增加一条新纪录，都要挪动后面所有的记录</li></ul><p>所以有序数组适合静态存储引擎，如2017年某个城市的所有人口信息。</p><ol start="3"><li>搜索树</li></ol><ul><li>二叉搜索树</li></ul><p>左子节点小于父节点，父节点小于右子节点。</p><p>查询复杂度：O(log(n))<br>更新时间复杂度：O(log(n))</p><ul><li>数据库为什么不使用二叉树而选择多叉树</li></ul><p>（1）二叉树虽然效率高，但是每一层存储的数据量比较少。假如在特别大的数据量的情况下，使用二叉树会导致树的层数非常高。层数越多，访问磁盘的次数越多，磁盘读取往往是性能的瓶颈，所以二叉树的读取性能就回很差。</p><p>（2）为了尽量的少读磁盘，让查询过程访问尽量少的数据块，应该使用多叉树。假如一个N=1200的多叉树，树高为4，可以存储1200的三次方的数据(17亿)。也就是在这17亿的数据中，查找一条记录，最多访问磁盘三次。</p><h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><blockquote><p>InnoDB的索引模型：B+树索引模型,每一个索引在InnoDB中就对应一棵B+树</p></blockquote><h4 id="B-树索引类型"><a href="#B-树索引类型" class="headerlink" title="B+树索引类型"></a>B+树索引类型</h4><ol><li>主键索引(聚簇索引)</li></ol><p>叶子节点存储整行数据</p><ol start="2"><li>普通索引(二级索引)</li></ol><p>叶子节点存储的是主键的值</p><h5 id="主键索引和非主键索引的区别"><a href="#主键索引和非主键索引的区别" class="headerlink" title="主键索引和非主键索引的区别"></a>主键索引和非主键索引的区别</h5><ol><li>通过主键查询的方式，就是直接搜索主键索引这棵B+树。</li><li>如果通过普通索引的方式，则是先通过普通索引B+树查询到主键值，再通过主键值去主键索引B+树里面所有(回表)</li></ol><blockquote><p>普通索引会多扫描一次索引，应该优先使用主键索引</p></blockquote><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><blockquote><p>B+树维护了索引的有效性，当插入新值的时候，就要做必要的维护</p></blockquote><ol><li>页分裂</li></ol><p>当插入数据所在页的数据页满了，就要重新申请一个新的数据页，让后再挪动部分数据过去。性能受影响。</p><ol start="2"><li>页合并</li></ol><p>相邻两个数据页因为删除了数据，利用率很低之后，会将数据页进行合并。</p><h4 id="自增字段的重要性"><a href="#自增字段的重要性" class="headerlink" title="自增字段的重要性"></a>自增字段的重要性</h4><blockquote><p>索引的维护过程中，会出现页分裂和页合并的现象，这些是比较耗费性能的。所以现在的建表规范里面都要求使用自增字段。那自增字段能够对索引维护起到什么作用吗？</p></blockquote><ul><li>自增逐渐的插入数据模式都是追加操作，不会涉及挪动其他记录，不会触发叶子节点的分裂。—-性能</li><li>如果使用业务字段做主键，不容易保证有序插入，写数据成本高。—-性能</li><li>自增逐渐相比业务字段作逐渐节省存储空间。如果使用身份证之类的作为主键，那么普通索引的叶子节点(主键)就会占用比较多的存储空间(字符串20个字节)，整型(4个字节)，长整型(8个字节)。—-存储空间</li></ul><blockquote><p>主键长度约小，普通索引的叶子节点就越小，普通索引占用的空间就越小</p></blockquote><p>业务字段作为主键的场景：</p><ol><li>只有一个索引</li><li>该索引是唯一索引</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;索引类似于书本的目录，能够提高数据查询效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常见的索引模型&quot;&gt;&lt;a href=&quot;#常见的索引模型&quot; class=&quot;headerlink&quot; title=&quot;常见的索引模型&quot;&gt;&lt;/a&gt;常见的索引模型&lt;
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>03|事务隔离</title>
    <link href="https://shawnyou.tech/2019/11/22/mysql-notes/03%7C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>https://shawnyou.tech/2019/11/22/mysql-notes/03|事务隔离/</id>
    <published>2019-11-22T14:47:29.000Z</published>
    <updated>2019-11-23T10:37:43.518Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>事务保证一组数据库操作，要么全部成功，要么全部失败。</p></blockquote><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ol><li>Atomicity(原子性)</li><li>Consistency(一致性)</li><li>Isolation(隔离性)</li><li>Durability(持久性)</li></ol><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><blockquote><p>为什么需要隔离性</p></blockquote><p>因为多个事务同时执行的时候，容易引发脏读、不可重复读、幻读等问题。</p><ol><li>脏读</li></ol><p>一个事务在处理过程中，读取了别的事务未提交的脏数据。如果别的事务回滚，那么我们拿到的数据是不准确的，由此会造成一定的问题。</p><ol start="2"><li><p>不可重复读<br>一个事务在处理过程，两次查询的数据不一样。这是因为第二次查询读取了别的事务已经提交的变更。那么我们在这个事务操作中就能看到别的事务提交的变更。</p></li><li><p>幻读<br>一个事务在处理过程中，两次查询的数据不一样，第二次查询读取了别的事务已经提交的变更。</p></li></ol><ul><li>不可重复读和幻读都在还未提交的事务过程中读取了另一个已经提交的事务变更。不可重读读针对的是同一个数据项，而幻读针对的是一批数据整体。例如小编去取钱，</li><li>不可重复读：重点在于修改，两次读取的数据不一样</li><li>幻读：重点在新增和删除，比如这里有一个事务1要查询公司里面工资1000元以上的职工有10人，这时另一个事务2里面，HR新增了一个新员工，工资也在1000元以上。这时候事务1在次查询，发现工资1000元以上的人员增加到了11个人。</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><blockquote><p>多个事务同时执行，引发的脏读、不可重复读、幻读等问题，就产生了‘隔离级别’的概念。隔离越严实，效率就越低，但数据一致性的程度越高。由此需要在隔离性和效率之间寻找一个平衡点。</p></blockquote><ol><li>读未提交(read uncommitted)</li></ol><blockquote><p>一个事务还未提交的时候，它的变更能被别的事务看到。</p></blockquote><ol start="2"><li>读提交(read committed)</li></ol><p>一个事务提交之后，它的改动才能被其他事务看到。事务A修改了一项数据，B事务读取不到变动，只有等事务A提交之后，B事务才能够读取。由此可以避免脏读，但是会造成不可重复读和幻读。</p><ol start="3"><li>可重复读(repeatable read)</li></ol><p>一个事务在执行过程中看到的数据和事务启动是看到的数据时一致的。当事务A开始读取一条记录的时候，事务B是不能够进行修改的。由此可以避免不可重复读，但是还是会造成幻读(事务A读取一些数据，事务B插入或者删除一些数据，这时候在此读取，会发现数据多了或者少了)。</p><ol start="4"><li>串行化(serializable)</li></ol><p>‘读’和‘写’会进行加锁，读写锁发生冲突时候，后访问的事务必须等前一个事务执行完成。</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><blockquote><p>事务的隔离级别往往和视图有关系，不同的隔离级别创建视图的顺序是不一样。视图可以理解为数据副本，每次创建视图，将当前已持久化的数据创建副本，后面直接从副本读取，从而达到数据隔离。</p></blockquote><ol><li>读未提交</li></ol><p>没有视图概念，不同事务在读未提交的隔离级别上直接读取记录的最新值，容易出现脏读的情况。</p><ol start="2"><li>读提交</li></ol><p>视图在每个SQL开始执行的时候创建的。所以第二次查询的时候，别的事务已经提交了数据，重新建立的视图里面包含已经变更的数据。因此能够读取别的事务修改的数据。</p><ol start="3"><li>可重复读</li></ol><p>视图是在事务启动的时候创建的。（TODO）</p><ol start="4"><li>串行化</li></ol><p>直接用加锁的方式避免并行访问</p><h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><h4 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h4><p>同一条记录在系统中可以存在多个版本。</p><h4 id="避免使用长事务"><a href="#避免使用长事务" class="headerlink" title="避免使用长事务"></a>避免使用长事务</h4><ul><li>长事务存在很老的事务视图，在未提交之前，所有的回滚记录都必须保留，会导致大量占用存储空间。</li><li>占用锁资源，拖垮数据库。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;事务保证一组数据库操作，要么全部成功，要么全部失败。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h3&gt;&lt;ol&gt;
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>02|一条SQL更新语句是如何执行的</title>
    <link href="https://shawnyou.tech/2019/11/21/mysql-notes/02%7C%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>https://shawnyou.tech/2019/11/21/mysql-notes/02|一条SQL更新语句是如何执行的/</id>
    <published>2019-11-21T14:47:29.000Z</published>
    <updated>2019-11-22T14:30:14.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="执行流程-和查询流程保持一致"><a href="#执行流程-和查询流程保持一致" class="headerlink" title="执行流程(和查询流程保持一致)"></a>执行流程(和查询流程保持一致)</h3><ul><li>连接器 –&gt; 连接数据库</li><li>分析器 –&gt; 词法和语法分析这是一条更新语句</li><li>优化器 –&gt; 决定使用哪个索引</li><li>执行器 –&gt; 找到具体的某一行，然后更新</li></ul><h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><blockquote><p>SQL更新过程中涉及两个重要的日志模块</p></blockquote><h4 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h4><ul><li>WHAT<br>redo log(重做日志)类似于掌柜账本记账的模式，先记账(先写日志)，后清账(再写磁盘)</li><li>WHY<br>mysql的每一次更新过程IO成本和查找成本很高。每一次更新操作都要在磁盘中找到对应的记录然后更新。当更新比较频繁的时候，性能就非常的不好。</li><li>HOW<br>当一条记录需要更新的时候：</li></ul><ol><li>InnoDB引擎先把记录写到redo log</li><li>更新内存</li><li>InnoDB引擎在系统空闲的时候，将操作记录更新到磁盘中</li></ol><p>PS：</p><ul><li>redo log是InnoDB特有的日志</li><li>如果更新特别频繁，redo log特别多，系统会放下工作，将一部分redo log的任务更新到磁盘中，为redo log腾出空间</li><li>redo log是固定大小的，可以配置一组四个文件，每个文件1GB, 从头开始写，写到末尾然后继续回到开头写</li><li>InnoDB 可以依靠redo log保证数据库发生异常重启的时候，之前的记录不会丢失(crash-safe)</li></ul><h4 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog(归档日志)"></a>binlog(归档日志)</h4><p>bin log是server层实现的日志，可以应用于所有存储引擎</p><h4 id="redolog与binlog的区别"><a href="#redolog与binlog的区别" class="headerlink" title="redolog与binlog的区别"></a>redolog与binlog的区别</h4><ul><li>redolog是InnoDB独有, binlog是Server层实现的，所有引擎都可以使用</li><li>redolog是物理日志，记录某个数据页做了什么改动，binlog是逻辑日志，记录语句的原始逻辑</li><li>redolog是循环写，空间固定会用完，binlog可以最佳写入，并不会覆盖以前的日志。</li></ul><h3 id="update语句执行的内部流程"><a href="#update语句执行的内部流程" class="headerlink" title="update语句执行的内部流程"></a>update语句执行的内部流程</h3><ol><li>执行器通过引擎找到对应的记录。如果这一行所在数据页在内存中，引擎就从内存中取，否则就从磁盘读入。</li><li>执行器拿到对应的数据，进行更新，然后调用引擎接口写入数据</li><li>引擎将数据更新到内存，同时将更新操作记录到redo日志，此时redo log处于prepare状态，告知执行器执行完成。</li><li>执行器生成binlog,并将binlog写入磁盘</li><li>执行器调用引擎的提交事务接口，引擎将写入的redo log改成提交状态</li></ol><blockquote><p>以上的流程包含了一个两阶段提交</p></blockquote><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><ul><li>what<br>保证redolog与binlog的数据逻辑一致性。</li></ul><ol><li>先写redolog后写binlog<br>redolog写完，binlog还没写完的时候，MySQL异常重启,可以通过redolog将记录恢复。但是当我们需要通过binlog恢复临时库的时候，由于binlog丢失，临时库的数据会少一次更新操作</li><li>先写binlog厚些redolog<br>binlog写完，redolog还没写，系统崩溃之后，由此数据没有被更新。但是binlog已经有了更新的日志，之后用binlog来恢复数据的时候就多了一条更新。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;执行流程-和查询流程保持一致&quot;&gt;&lt;a href=&quot;#执行流程-和查询流程保持一致&quot; class=&quot;headerlink&quot; title=&quot;执行流程(和查询流程保持一致)&quot;&gt;&lt;/a&gt;执行流程(和查询流程保持一致)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;连接器 –&amp;gt; 连接数据
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>为什么基于接口而非实现编程</title>
    <link href="https://shawnyou.tech/2019/11/21/design-pattern-notes/09%7C%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B/"/>
    <id>https://shawnyou.tech/2019/11/21/design-pattern-notes/09|基于接口而非实现编程/</id>
    <published>2019-11-21T14:47:29.000Z</published>
    <updated>2019-12-02T14:29:51.884Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于接口而非实现编程是一种非常高效且提高代码质量的手段。</p></blockquote><h3 id="接口的含义"><a href="#接口的含义" class="headerlink" title="接口的含义"></a>接口的含义</h3><ol><li>抽象层面的接口</li></ol><ul><li>服务端与客户端之间的“接口”</li><li>类库提供的“接口”</li><li>通信协议接口</li></ul><ol start="2"><li>代码接口</li></ol><ul><li>编程语言中的接口类或者抽象类</li></ul><h3 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h3><blockquote><p>“面向接口而非实现编程”也可以表述为”基于抽象而非实现编程”，抽象是提高代码扩展性、灵活性、可维护性的最优先手段之一。</p></blockquote><ul><li>将接口与实现相分离，封装不稳定的实现，暴露稳定的接口。</li><li>抽象、顶层、脱离具体实现的设计可以提高代码的灵活性，应对未来复杂的需求变化。</li></ul><h3 id="基于接口而非实现编程的要求"><a href="#基于接口而非实现编程的要求" class="headerlink" title="基于接口而非实现编程的要求"></a>基于接口而非实现编程的要求</h3><ol><li>函数命名不能暴露任何实现细节，适配未来的需求变化，应该取一个较为宽泛且概括中心概念的名字。</li><li>封装具体实现细节</li><li>为实现类定义抽象的接口。使用者依赖接口，而非具体的实现类编程。</li></ol><h3 id="接口实现的度"><a href="#接口实现的度" class="headerlink" title="接口实现的度"></a>接口实现的度</h3><blockquote><p>任何事情都要讲一个度,对于基于接口而非实现编程的‘度’应该如何把握呢？哪些可以直接使用实现类进行编程？</p></blockquote><ol><li>业务场景中，某个功能只有一种实现方式，我来也不可能会被其他方式替代，就没必要设计接口，直接使用实现类</li><li>系统特别稳定，基本不做维护，就没必要在扩展性投入不必要的开发时间。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于接口而非实现编程是一种非常高效且提高代码质量的手段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;接口的含义&quot;&gt;&lt;a href=&quot;#接口的含义&quot; class=&quot;headerlink&quot; title=&quot;接口的含义&quot;&gt;&lt;/a&gt;接口的含义&lt;/h
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>01|一条SQL查询语句是如何执行的</title>
    <link href="https://shawnyou.tech/2019/11/20/mysql-notes/01%7C%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>https://shawnyou.tech/2019/11/20/mysql-notes/01|一条SQL查询语句是如何执行的/</id>
    <published>2019-11-20T14:47:29.000Z</published>
    <updated>2019-12-08T08:51:42.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><blockquote><p>负责与客户端建立连接。<br>shou processlist (查看连接)<br>长连接内存占用过大OOM如何解决：</p><ul><li>定期断开长连接</li><li>MySQL5.7以及以上版本，可以在执行完比较大的操作后，通过mysql_reset_connection重新初始化连接资源，使连接恢复到刚刚创建完时的状态。</li></ul></blockquote><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><blockquote><p>建立连接后会优先查询缓存，查询缓存弊大于利，MySQL8.0将查询缓存删除。</p><ul><li>对于一张经常变更的表，缓存经常被清空，缓存的命中率非常低，对于静态表适合做查询缓存。</li><li>按需使用查询缓存。</li></ul></blockquote><h4 id="分析器-分析要做什么"><a href="#分析器-分析要做什么" class="headerlink" title="分析器(分析要做什么)"></a>分析器(分析要做什么)</h4><blockquote><p>如何没有命中查询缓存，就要开始执行SQl语句了。</p><ul><li>词法分析：识别关键词，如select, from ,table….</li><li>语法分析：根据语法规则判断SQL语句的正确性。</li></ul></blockquote><h4 id="优化器-确定执行方案"><a href="#优化器-确定执行方案" class="headerlink" title="优化器(确定执行方案)"></a>优化器(确定执行方案)</h4><ul><li>当存在多个索引的时候，决定索引的选择</li><li>多表关联的时候，决定多个表的连接顺序<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><blockquote><p>根据选择的存储引擎调用引擎接口从第一行开始比对，直到最后一行找出所有满足条件的记录返回结果集。</p></blockquote></li><li>慢查询日志：rows_examined(语句执行过程中的扫描行)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MySQL基础架构&quot;&gt;&lt;a href=&quot;#MySQL基础架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL基础架构&quot;&gt;&lt;/a&gt;MySQL基础架构&lt;/h3&gt;&lt;h4 id=&quot;连接器&quot;&gt;&lt;a href=&quot;#连接器&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>08|接口与抽象类</title>
    <link href="https://shawnyou.tech/2019/11/20/design-pattern-notes/08%7C%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://shawnyou.tech/2019/11/20/design-pattern-notes/08|接口与抽象类/</id>
    <published>2019-11-20T14:47:29.000Z</published>
    <updated>2019-12-05T13:19:36.573Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接口和抽象类是很多设计模式、设计思想、设计原则编程实现的基础。</p></blockquote><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>不允许被实例化</li><li>抽象类包含属性和方法。其中方法可以包含代码实现，也可以不包含代码实现(抽象方法)</li><li>子类集成抽象类。子类必须实现抽象类的抽象方法。</li></ul><h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><ul><li>接口不能包含属性(成员变量)</li><li>接口只能声明方法，方法不能包含方法实现</li><li>类实现接口的时候，必须实现接口的所有方法。</li></ul><h3 id="抽象类与接口类的区别"><a href="#抽象类与接口类的区别" class="headerlink" title="抽象类与接口类的区别"></a>抽象类与接口类的区别</h3><ul><li>抽象类的本质是类，主要只能被子类去继承，体现着is-a的继承关系</li><li>接口类表示一种has-a的关系，体现具有某些功能，表现为一种约定和协议。</li></ul><h3 id="抽象类和接口类能解决什么问题"><a href="#抽象类和接口类能解决什么问题" class="headerlink" title="抽象类和接口类能解决什么问题"></a>抽象类和接口类能解决什么问题</h3><h4 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h4><ul><li>代码复用，避免在子类中编写相同的代码</li></ul><blockquote><p>同样是代码复用，为什么不直接用继承，而要使用抽象类来实现？相比继承来说，抽象类的实现更加的优雅</p></blockquote><ul><li>父类中定义一个被子类继承的无意义的log()方法会使代码的可读性变差。</li><li>创建子类的时候，会忘记重写log()。然而抽象类会强制子类实现。</li><li>继承中，父类是可以被实例化的，我们可以调用空的log()方法，会增加类误用的风险。(可以通过设置私有构造函数解决)</li></ul><h4 id="接口类-1"><a href="#接口类-1" class="headerlink" title="接口类"></a>接口类</h4><blockquote><p>侧重于解耦。对行为进行抽象，之关系接口的协议，不关心具体实现，实现约定与实现相分离。</p></blockquote><h3 id="模拟接口类和抽象类"><a href="#模拟接口类和抽象类" class="headerlink" title="模拟接口类和抽象类"></a>模拟接口类和抽象类</h3><h4 id="模拟接口类"><a href="#模拟接口类" class="headerlink" title="模拟接口类"></a>模拟接口类</h4><blockquote><p>普通类模拟接口类</p></blockquote><ul><li>protect访问权限，避免类被实例化</li><li>不含具体实现的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockInteface</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MockInteface</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MethodUnSupportedException(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类和接口类的使用"><a href="#抽象类和接口类的使用" class="headerlink" title="抽象类和接口类的使用"></a>抽象类和接口类的使用</h3><ul><li>抽象类：is-a的关系，解决代码复用的问题</li><li>接口类：has-a的关系，解决耦合的问题，表示一组行为特征，隔离接口和具体实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;接口和抽象类是很多设计模式、设计思想、设计原则编程实现的基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h3&gt;&lt;ul
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式|手写一个迭代器</title>
    <link href="https://shawnyou.tech/2019/10/22/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/10/22/迭代器模式/</id>
    <published>2019-10-22T15:25:15.000Z</published>
    <updated>2019-11-04T14:54:52.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>我们在日常的开发中，特别是在使用集合的过程中都或多或少使用了迭代器来对集合进行遍历。这时候我们就会思考一个问题，明明简单的For循环就能解决的集合遍历问题，我们非得创造一个迭代器来进行集合的遍历，使用迭代器来遍历到底有什么不一样的地方吗？本着‘存在即合理’的原则，我们通过手写迭代器的方式来深入了解一下迭代器模式的实现和带来的编码好处。</p><h4 id="实现案例"><a href="#实现案例" class="headerlink" title="实现案例"></a>实现案例</h4><p>有一个书架，我们想要知道这个书架里面堆了哪些书籍，这时候我们就需要对书架里面的书一本一本的遍历，直到没有书本，我们就能清楚的知道数据上堆满了哪些书籍。</p><ul><li><p>可以被遍历的标记(生成迭代器的接口)<br>首先提供一个接口，来标明这个类是可以被遍历的集合。实现这个接口的类可以生成对应的迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代器接口<br>迭代器的抽象接口，定义了两个方法<br>（1）是否还有下一个元素<br>（2）返回下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>集合存储的元素（书本）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">book</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代器实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelfIterator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookShelf bookShelf;</span><br><span class="line">    <span class="comment">//指向当前遍历的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//将当前的index与集合的大小做比较，小于集合大小，说明还有元素。</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; bookShelf.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Book book = bookShelf.getBookAt(index);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>书架类<br>书架类用于存放书本，可以用来遍历，因此需要实现Aggregate接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span> <span class="keyword">implements</span> <span class="title">Aggregate</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//生成对应的迭代器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BookShelfIterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = bookShelf.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext)&#123;</span><br><span class="line">    Book book = (Book)it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>由此，我们就自定义实现了一个迭代器，可以满足集合遍历的基本需求</p></blockquote><h3 id="迭代器模式的几点思考"><a href="#迭代器模式的几点思考" class="headerlink" title="迭代器模式的几点思考"></a>迭代器模式的几点思考</h3><h4 id="为什么要使用迭代模式"><a href="#为什么要使用迭代模式" class="headerlink" title="为什么要使用迭代模式"></a>为什么要使用迭代模式</h4><p>遍历与实现分开，无论BookShelf是怎样的实现，只要能够获取到对应的迭代器，遍历方式都是不会变的，利于代码的扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = bookShelf.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext)&#123;</span><br><span class="line">    Book book = (Book)it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多种迭代器"><a href="#多种迭代器" class="headerlink" title="多种迭代器"></a>多种迭代器</h4><p>迭代器实现了遍历集合的方式，那么我们可以设计多种不一样的迭代器。</p><ul><li>从后向前遍历</li><li>跳跃性遍历</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a&gt;迭代器模式&lt;/h3&gt;&lt;p&gt;我们在日常的开发中，特别是在使用集合的过程中都或多或少使用了迭代器来对集合进行遍历。这时候我们就会思考一个问题，明明
      
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://shawnyou.tech/2019/07/03/%E9%87%8D%E6%9E%84/%E9%87%8D%E6%9E%84/"/>
    <id>https://shawnyou.tech/2019/07/03/重构/重构/</id>
    <published>2019-07-03T14:43:46.340Z</published>
    <updated>2019-07-08T13:50:08.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重构总结（TODO）"><a href="#重构总结（TODO）" class="headerlink" title="重构总结（TODO）"></a>重构总结（TODO）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="1-什么是重构"><a href="#1-什么是重构" class="headerlink" title="1.什么是重构"></a>1.什么是重构</h2><blockquote><p>重构是对软件的内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高代码可理解性，降低维护成本。</p></blockquote><p>关键：</p><ul><li>更好的可读性</li><li>更好的可扩展性</li><li>功能保持一致</li></ul><h2 id="为什么要重构"><a href="#为什么要重构" class="headerlink" title="为什么要重构"></a>为什么要重构</h2><ul><li>改进软件设计<br>整理代码，使代码结构回到最初设计，维持代码该有的形态，避免软件腐烂变质。</li><li>使软件更容易理解<br>代码是人与及其交互的语言。保持语言的简洁有助于：<br>（1）理解代码<br>（2）后来者维护代码</li><li>帮助找到Bug<br>重构过程可以重新梳理逻辑，找到潜在的Bug。</li><li>提高编程速度<br>良好的设计师快速开发的根本。</li></ul><h2 id="何时进行重构"><a href="#何时进行重构" class="headerlink" title="何时进行重构"></a>何时进行重构</h2><p>事不过三，三则重构</p><ul><li>添加功能时重构<br>添加功能时，理解需要修改的代码，使添加功能更加轻松。</li><li>修改错误时候重构<br>好的代码是足够清晰以至于能够肉眼观察bug，所以当遇到bug时，说明设计不够清晰，因而需要重构</li><li>复审代码时重构</li></ul><h3 id="重构的期望"><a href="#重构的期望" class="headerlink" title="重构的期望"></a>重构的期望</h3><ul><li>容易阅读</li><li>所有的逻辑都只在唯一地点指定</li><li>新的改动不会危及现有行为</li><li>尽可能简单的表达条件逻辑</li></ul><h2 id="代码的坏味道（什么样的代码需要重构）"><a href="#代码的坏味道（什么样的代码需要重构）" class="headerlink" title="代码的坏味道（什么样的代码需要重构）"></a>代码的坏味道（什么样的代码需要重构）</h2><ol><li>重复代码（Duplicated Code）</li></ol><ul><li>同一个类中的两个函数具有相同的代码，可以使用Extract Method提炼吃重复代码</li><li>两个兄弟子类具有相同的代码，则提炼相同代码（Extract Method）,再将提炼出来的函数推送给父类（Pull up method）</li><li>对于部分相同的情况，则分离出相似部分和差异部分，使用模板设计模式。</li><li>两个不相关类出现重复代码，则将重复代码提取到一个独立类。 </li></ul><ol start="2"><li>过长的函数（Long method）</li></ol><ul><li>小型函数作为“间接层”具有解释能力、共享能力、选择能力</li><li>当需要用注释来描述代码的时候，就应该对函数进行分解，把需要说明的部分放入独立的函数，以其用途来命名</li><li>函数传参里有过多的参数和临时变量，应该尽量消除临时变量，使参数列表更加简洁。</li></ul><ol start="3"><li>过大的类（Large Class）</li><li>过长的参数列（Long Paramenter List）</li><li>发散式变化（Divergent Change）</li><li>散弹式修改（Shotgun Surgery）</li><li>依恋情节（Feature Envy）</li><li>数据泥团（Data Clumps）</li><li>基本类型偏执（Primitive Obsession）</li><li>Switch现身（Switch Statement）</li><li>平行继承体系（Parallel Inheritance Hierarchies）</li><li>冗赘类（Lazy Class）</li><li>夸夸其谈未来性（Speculative Generality）</li><li>令人迷惑的临时字段（Temporary Field）</li><li>过度耦合的消息链（Message Chains）</li><li>中间人（Middle Man）</li><li>狎昵关系（Inappropriate Intimacy）</li><li>异曲同工的类（Alternative Classes with Different Interfaces）</li><li>不完美的库类（Incomplete Library Class）</li><li>纯稚的数据类（Data Class）</li><li>被拒绝的遗赠（Refused Bequest）</li><li>过多的注释（Comments）</li></ol><p>重构列表</p><p>重新组织函数</p><ol><li>提炼函数（Extract Method）<br>适用场景</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重构总结（TODO）&quot;&gt;&lt;a href=&quot;#重构总结（TODO）&quot; class=&quot;headerlink&quot; title=&quot;重构总结（TODO）&quot;&gt;&lt;/a&gt;重构总结（TODO）&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringCache源码| Spring Cache的AOP实现原理</title>
    <link href="https://shawnyou.tech/2019/06/27/Spring-boot/%E7%BC%93%E5%AD%98%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA/"/>
    <id>https://shawnyou.tech/2019/06/27/Spring-boot/缓存方法拦截/</id>
    <published>2019-06-27T14:51:50.000Z</published>
    <updated>2019-06-30T14:41:57.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h2><p>Spring Cache是通过AOP面向切面编程的思想来对缓存的操作进行封装，通过拦截器对实现了Spring Cache注解的方法进行拦截，可以根据注解信息去完成相应的缓存操作。</p><h2 id="2-CacheInterceptor拦截器"><a href="#2-CacheInterceptor拦截器" class="headerlink" title="2. CacheInterceptor拦截器"></a>2. CacheInterceptor拦截器</h2><p>Spring Cache提供了一个缓存拦截器，负责拦截方法调用执行缓存逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">extends</span> <span class="title">CacheAspectSupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被拦截的方法都会走invoke</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//invocation就是一个连接点(Joinpoint),其实就是对方调用方法的封装。</span></span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        CacheOperationInvoker aopAllianceInvoker = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ThrowableWrapper(var2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//核心的方法，来自于父类</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.execute(aopAllianceInvoker, invocation.getThis(), method, invocation.getArguments());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ThrowableWrapper var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5.getOriginal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheIntercepto实现了MethodInterceptor，MethodInterceptor主要对方法进行拦截，查看MethodInterceptor的继承图，发现MethodInterceptor就是一个Advice，在Spring AOP的概念里面，Advice就是一个通知，通知封装了AOP的横切逻辑。由此来说CacheInterceptor作为一个通知，他里面肯定包含缓存操作的横切逻辑，能够处理方法调用前后的缓存操作。</p><h3 id="2-1-查看父类的核心方法execute"><a href="#2-1-查看父类的核心方法execute" class="headerlink" title="2.1 查看父类的核心方法execute"></a>2.1 查看父类的核心方法execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">execute</span><span class="params">(CacheOperationInvoker invoker, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//是否初始化成功</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.initialized) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = <span class="keyword">this</span>.getTargetClass(target);</span><br><span class="line">            <span class="comment">//获取CacheOperation资源类，负责解析Spring Cache注解的类</span></span><br><span class="line">            CacheOperationSource cacheOperationSource = <span class="keyword">this</span>.getCacheOperationSource();</span><br><span class="line">            <span class="keyword">if</span>(cacheOperationSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//解析注解，得到CacheOperation的集合。</span></span><br><span class="line">                Collection&lt;CacheOperation&gt; operations = cacheOperationSource.getCacheOperations(method, targetClass);</span><br><span class="line">                <span class="keyword">if</span>(!CollectionUtils.isEmpty(operations)) &#123;</span><br><span class="line">                    <span class="comment">//调用内部方法execute，封装了一个缓存操作的上下文并传入</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.execute(invoker, method, <span class="keyword">new</span> CacheAspectSupport.CacheOperationContexts(operations, method, args, target, targetClass));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要作用：</p><ol><li>获取缓存操作集合CacheOperation</li><li>封装缓存操作上下文，并调用内部的execute方法</li></ol><h3 id="2-2-核心内部方法execute"><a href="#2-2-核心内部方法execute" class="headerlink" title="2.2 核心内部方法execute"></a>2.2 核心内部方法execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">execute</span><span class="params">(CacheOperationInvoker invoker, Method method, CacheAspectSupport.CacheOperationContexts contexts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(contexts.isSynchronized()) &#123;</span><br><span class="line">            <span class="comment">//获取CacheableOperation对应的缓存操作上下文。</span></span><br><span class="line">            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)contexts.get(CacheableOperation.class).iterator().next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) &#123;</span><br><span class="line">                Object key = <span class="keyword">this</span>.generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class="line">                <span class="comment">//获取缓存对象</span></span><br><span class="line">                Cache cache = (Cache)context.getCaches().iterator().next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.wrapCacheValue(method, cache.get(key, () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.unwrapReturnValue(<span class="keyword">this</span>.invokeOperation(invoker));</span><br><span class="line">                    &#125;));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ValueRetrievalException var10) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (ThrowableWrapper)var10.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.invokeOperation(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1. 处理BeforeInvocation = true的缓存删除操作</span></span><br><span class="line">            <span class="keyword">this</span>.processCacheEvicts(contexts.get(CacheEvictOperation.class), <span class="keyword">true</span>, CacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class="line">            <span class="comment">//2. 查找是否有@Cacheable的缓存数据</span></span><br><span class="line">            ValueWrapper cacheHit = <span class="keyword">this</span>.findCachedItem(contexts.get(CacheableOperation.class));</span><br><span class="line">            List&lt;CacheAspectSupport.CachePutRequest&gt; cachePutRequests = <span class="keyword">new</span> LinkedList();</span><br><span class="line">            <span class="keyword">if</span>(cacheHit == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果没有缓存数据，则封装成CachePutRequest</span></span><br><span class="line">                <span class="keyword">this</span>.collectPutRequests(contexts.get(CacheableOperation.class), CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object cacheValue;</span><br><span class="line">            Object returnValue;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cacheHit != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.hasCachePut(contexts)) &#123;</span><br><span class="line">                <span class="comment">//获取缓存数据里面的值</span></span><br><span class="line">                cacheValue = cacheHit.get();</span><br><span class="line">                returnValue = <span class="keyword">this</span>.wrapCacheValue(method, cacheValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有找到Cacheable的缓存数据，或者缓存注解是CachePut则调用方法，获取方法返回值</span></span><br><span class="line">                returnValue = <span class="keyword">this</span>.invokeOperation(invoker);</span><br><span class="line">                cacheValue = <span class="keyword">this</span>.unwrapReturnValue(returnValue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 将CachePut注解封装成CachePutRequest</span></span><br><span class="line">            <span class="keyword">this</span>.collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);</span><br><span class="line">            Iterator var8 = cachePutRequests.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//遍历cachePutRequest，将方法调用的返回值置入缓存中。</span></span><br><span class="line">                CacheAspectSupport.CachePutRequest cachePutRequest = (CacheAspectSupport.CachePutRequest)var8.next();</span><br><span class="line">                cachePutRequest.apply(cacheValue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理BeforeInvocation = false的缓存删除操作</span></span><br><span class="line">            <span class="keyword">this</span>.processCacheEvicts(contexts.get(CacheEvictOperation.class), <span class="keyword">false</span>, cacheValue);</span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果不需要同步，该方法主要完成了以下的逻辑</p><ol><li>处理BeforeInvocation = true的缓存删除操作 </li><li>通过@Cacheable注解找到对应的缓存值。</li><li>如果没有找到对应的缓存数据，则将@Cacheable封装成CachePutRequest，标记为一个插入缓存的请求。</li><li>进行方法调用</li><li>将CachePut注解封装成CachePutRequest</li><li>遍历CachePutReqeust集合，将方法调用的返回值置入缓存中。</li><li>处理BeforeInvocation = false的缓存删除操作  </li></ol><p>梳理一下，这个方法里面包括三个注解的逻辑</p><ol><li><p>@Cacheable<br>(1) 首先从缓存中找@Cacheable对应的缓存<br>(2) 如果缓存存在，则取出缓存值作为返回值<br>(3) 如果缓存不存在，则进行方法调用，获取返回值，并将返回值置入缓存</p></li><li><p>@CachePut<br>(1) 如果包含cachePut注解，则进行方法调用。<br>(2) 获取方法返回值，并置入缓存之中。</p></li><li><p>@CacheEvic<br>(1) 在方法调用签执行缓存删除操作。<br>(2) 在方法调用后执行缓存删除操作。</p></li></ol><h4 id="2-2-1-processCacheEvicts"><a href="#2-2-1-processCacheEvicts" class="headerlink" title="2.2.1 processCacheEvicts"></a>2.2.1 processCacheEvicts</h4><p>我们来看看缓存删除的具体逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//beforeInvocation指的是方法调用前还是调用后，@CacheEvict可以进行设置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCacheEvicts</span><span class="params">(Collection&lt;CacheAspectSupport.CacheOperationContext&gt; contexts, <span class="keyword">boolean</span> beforeInvocation, @Nullable Object result)</span> </span>&#123;</span><br><span class="line">        Iterator var4 = contexts.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)var4.next();</span><br><span class="line">            CacheEvictOperation operation = (CacheEvictOperation)context.metadata.operation;</span><br><span class="line">            <span class="keyword">if</span>(beforeInvocation == operation.isBeforeInvocation() &amp;&amp; <span class="keyword">this</span>.isConditionPassing(context, result)) &#123;</span><br><span class="line">                <span class="comment">//处理缓存删除操作</span></span><br><span class="line">                <span class="keyword">this</span>.performCacheEvict(context, operation, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performCacheEvict</span><span class="params">(CacheAspectSupport.CacheOperationContext context, CacheEvictOperation operation, @Nullable Object result)</span> </span>&#123;</span><br><span class="line">        Object key = <span class="keyword">null</span>;</span><br><span class="line">        Iterator var5 = context.getCaches().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//遍历获取Cache对象</span></span><br><span class="line">            Cache cache = (Cache)var5.next();</span><br><span class="line">            <span class="keyword">if</span>(operation.isCacheWide()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logInvalidating(context, operation, (Object)<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//删除全部缓存</span></span><br><span class="line">                <span class="keyword">this</span>.doClear(cache);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    key = <span class="keyword">this</span>.generateKey(context, result);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.logInvalidating(context, operation, key);</span><br><span class="line">                <span class="comment">//删除指定key的缓存</span></span><br><span class="line">                <span class="keyword">this</span>.doEvict(cache, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-2-findCachedItem-获取缓存数据"><a href="#2-2-2-findCachedItem-获取缓存数据" class="headerlink" title="2.2.2 findCachedItem(获取缓存数据)"></a>2.2.2 findCachedItem(获取缓存数据)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ValueWrapper <span class="title">findCachedItem</span><span class="params">(Collection&lt;CacheAspectSupport.CacheOperationContext&gt; contexts)</span> </span>&#123;</span><br><span class="line">        Object result = CacheOperationExpressionEvaluator.NO_RESULT;</span><br><span class="line">        Iterator var3 = contexts.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)var3.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isConditionPassing(context, result)) &#123;</span><br><span class="line">                <span class="comment">//生成相应的Cache key</span></span><br><span class="line">                Object key = <span class="keyword">this</span>.generateKey(context, result);</span><br><span class="line">                <span class="comment">//通过缓存上下文和key找寻相应的缓存包装对象</span></span><br><span class="line">                ValueWrapper cached = <span class="keyword">this</span>.findInCaches(context, key);</span><br><span class="line">                <span class="keyword">if</span>(cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cached;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.trace(<span class="string">"No cache entry for key '"</span> + key + <span class="string">"' in cache(s) "</span> + context.getCacheNames());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ValueWrapper <span class="title">findInCaches</span><span class="params">(CacheAspectSupport.CacheOperationContext context, Object key)</span> </span>&#123;</span><br><span class="line">        Iterator var3 = context.getCaches().iterator();</span><br><span class="line"></span><br><span class="line">        Cache cache;</span><br><span class="line">        ValueWrapper wrapper;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!var3.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取缓存对象，并通过key去查找缓存值</span></span><br><span class="line">            cache = (Cache)var3.next();</span><br><span class="line">            wrapper = <span class="keyword">this</span>.doGet(cache, key);</span><br><span class="line">        &#125; <span class="keyword">while</span>(wrapper == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"Cache entry for key '"</span> + key + <span class="string">"' found in cache '"</span> + cache.getName() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3collectPutRequests-封装存储缓存的请求"><a href="#2-2-3collectPutRequests-封装存储缓存的请求" class="headerlink" title="2.2.3collectPutRequests(封装存储缓存的请求)"></a>2.2.3collectPutRequests(封装存储缓存的请求)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectPutRequests</span><span class="params">(Collection&lt;CacheAspectSupport.CacheOperationContext&gt; contexts, @Nullable Object result, Collection&lt;CacheAspectSupport.CachePutRequest&gt; putRequests)</span> </span>&#123;</span><br><span class="line">        Iterator var4 = contexts.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)var4.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isConditionPassing(context, result)) &#123;</span><br><span class="line">                Object key = <span class="keyword">this</span>.generateKey(context, result);</span><br><span class="line">                <span class="comment">//通过key和缓存上下文封装一个插入缓存的请求。</span></span><br><span class="line">                putRequests.add(<span class="keyword">new</span> CacheAspectSupport.CachePutRequest(context, key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>目前，关于Spring Cache的源码分析就告一段落了，总的来说，SpringCache的分析文章主要对缓存注解实现的源码做了一个简要的分析，目的是能够对缓存操作的AOP实现原理有一个清晰的认识。能够搞清楚Spring Cache是如何借助AOP的思想来实现如何简单、快捷且代码侵入低的缓存组件。由此我们可以借鉴这些思想和案例来丰富我们的阅历，以助于提高我们的技术水平，帮助我们能够实现类似的开源组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-简述&quot;&gt;&lt;a href=&quot;#1-简述&quot; class=&quot;headerlink&quot; title=&quot;1. 简述&quot;&gt;&lt;/a&gt;1. 简述&lt;/h2&gt;&lt;p&gt;Spring Cache是通过AOP面向切面编程的思想来对缓存的操作进行封装，通过拦截器对实现了Spring Cache
      
    
    </summary>
    
      <category term="Spring" scheme="https://shawnyou.tech/categories/Spring/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringCache源码| SpringCache缓存注解解析</title>
    <link href="https://shawnyou.tech/2019/06/26/Spring-boot/%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://shawnyou.tech/2019/06/26/Spring-boot/缓存注解解析与应用/</id>
    <published>2019-06-26T14:51:50.000Z</published>
    <updated>2019-06-30T14:53:36.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-缓存的解析"><a href="#1-缓存的解析" class="headerlink" title="1.缓存的解析"></a>1.缓存的解析</h2><p>Spring Cache提供了缓存解析器，负责为缓存注解抽象成一个缓存信息对象。我们通过面向对象的编程方式就能够轻松的获取缓存操作信息</p><h3 id="1-1CacheAnnotationParser缓存注解解析器"><a href="#1-1CacheAnnotationParser缓存注解解析器" class="headerlink" title="1.1CacheAnnotationParser缓存注解解析器"></a>1.1CacheAnnotationParser缓存注解解析器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheAnnotationParser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对类上面的缓存注解进行解析</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line">    <span class="comment">//对方法上面的注解进行解析</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Method var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheAnnotationParser有一个实现类SpringCacheAnnotationParser,两个方法的实现是一样的，最终method也会转换成Class。所以这里针对parseCacheAnnotations(Class&lt;?&gt; var1)做解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取</span></span><br><span class="line">    SpringCacheAnnotationParser.DefaultCacheConfig defaultConfig = <span class="keyword">this</span>.getDefaultCacheConfig(type);</span><br><span class="line">    <span class="comment">//2. 通过DefaultCacheConfig信息和class去解析缓存注解</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parseCacheAnnotations(defaultConfig, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    SpringCacheAnnotationParser.DefaultCacheConfig defaultConfig = <span class="keyword">this</span>.getDefaultCacheConfig(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parseCacheAnnotations(defaultConfig, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-2getDefaultCacheConfig"><a href="#1-2getDefaultCacheConfig" class="headerlink" title="1.2getDefaultCacheConfig"></a>1.2getDefaultCacheConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpringCacheAnnotationParser.<span class="function">DefaultCacheConfig <span class="title">getDefaultCacheConfig</span><span class="params">(Class&lt;?&gt; target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取类上面的@CacheConfig注解信息</span></span><br><span class="line">        CacheConfig annotation = (CacheConfig)AnnotatedElementUtils.findMergedAnnotation(target, CacheConfig.class);</span><br><span class="line">        <span class="comment">//如果@CacheConfig不存在，则构建一个默认的DefaultCacheConfig</span></span><br><span class="line">        <span class="keyword">return</span> annotation != <span class="keyword">null</span> ? <span class="keyword">new</span> SpringCacheAnnotationParser.DefaultCacheConfig(annotation.cacheNames(), annotation.keyGenerator(), annotation.cacheManager(), annotation.cacheResolver()) : <span class="keyword">new</span> SpringCacheAnnotationParser.DefaultCacheConfig();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-parseCacheAnnotations"><a href="#1-3-parseCacheAnnotations" class="headerlink" title="1.3. parseCacheAnnotations"></a>1.3. parseCacheAnnotations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(SpringCacheAnnotationParser.DefaultCacheConfig cachingConfig, AnnotatedElement ae)</span> </span>&#123;</span><br><span class="line">        Collection&lt;CacheOperation&gt; ops = <span class="keyword">this</span>.parseCacheAnnotations(cachingConfig, ae, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (ops != <span class="keyword">null</span> &amp;&amp; ops.size() &gt; <span class="number">1</span> &amp;&amp; ae.getAnnotations().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Collection&lt;CacheOperation&gt; localOps = <span class="keyword">this</span>.parseCacheAnnotations(cachingConfig, ae, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (localOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> localOps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ops;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法只是一个空壳，真正的逻辑在this.parseCacheAnnotations(cachingConfig, ae, false)这里面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(SpringCacheAnnotationParser.DefaultCacheConfig cachingConfig, AnnotatedElement ae, <span class="keyword">boolean</span> localOnly)</span> </span>&#123;</span><br><span class="line">        Collection&lt;CacheOperation&gt; ops = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//解析@Cacheable</span></span><br><span class="line">        Collection&lt;Cacheable&gt; cacheables = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, Cacheable.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, Cacheable.class);</span><br><span class="line">        <span class="keyword">if</span> (!cacheables.isEmpty()) &#123;</span><br><span class="line">            ops = <span class="keyword">this</span>.lazyInit((Collection)<span class="keyword">null</span>);</span><br><span class="line">            Iterator var6 = cacheables.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                Cacheable cacheable = (Cacheable)var6.next();</span><br><span class="line">                ops.add(<span class="keyword">this</span>.parseCacheableAnnotation(ae, cachingConfig, cacheable));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析@cacheEvict</span></span><br><span class="line">        Collection&lt;CacheEvict&gt; evicts = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, CacheEvict.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, CacheEvict.class);</span><br><span class="line">        <span class="keyword">if</span> (!evicts.isEmpty()) &#123;</span><br><span class="line">            ops = <span class="keyword">this</span>.lazyInit(ops);</span><br><span class="line">            Iterator var13 = evicts.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var13.hasNext()) &#123;</span><br><span class="line">                CacheEvict evict = (CacheEvict)var13.next();</span><br><span class="line">                ops.add(<span class="keyword">this</span>.parseEvictAnnotation(ae, cachingConfig, evict));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析@CachePut</span></span><br><span class="line">        Collection&lt;CachePut&gt; puts = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, CachePut.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, CachePut.class);</span><br><span class="line">        <span class="keyword">if</span> (!puts.isEmpty()) &#123;</span><br><span class="line">            ops = <span class="keyword">this</span>.lazyInit(ops);</span><br><span class="line">            Iterator var15 = puts.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                CachePut put = (CachePut)var15.next();</span><br><span class="line">                ops.add(<span class="keyword">this</span>.parsePutAnnotation(ae, cachingConfig, put));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析Cache</span></span><br><span class="line">        Collection&lt;Caching&gt; cachings = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, Caching.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, Caching.class);</span><br><span class="line">        <span class="keyword">if</span> (!cachings.isEmpty()) &#123;</span><br><span class="line">            ops = <span class="keyword">this</span>.lazyInit(ops);</span><br><span class="line">            Iterator var17 = cachings.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var17.hasNext()) &#123;</span><br><span class="line">                Caching caching = (Caching)var17.next();</span><br><span class="line">                Collection&lt;CacheOperation&gt; cachingOps = <span class="keyword">this</span>.parseCachingAnnotation(ae, cachingConfig, caching);</span><br><span class="line">                <span class="keyword">if</span> (cachingOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ops.addAll(cachingOps);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ops;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>由上可知，代码分别对@Cacheable,@CachePut,@CacheEvict进行解析，一旦发现相应的注解，就对注解信息封装成对应的CacheOperation(缓存操作信息对象)。封装过程的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CacheableOperation <span class="title">parseCacheableAnnotation</span><span class="params">(AnnotatedElement ae, SpringCacheAnnotationParser.DefaultCacheConfig defaultConfig, Cacheable cacheable)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> Builder();</span><br><span class="line">        builder.setName(ae.toString());</span><br><span class="line">        builder.setCacheNames(cacheable.cacheNames());</span><br><span class="line">        builder.setCondition(cacheable.condition());</span><br><span class="line">        builder.setUnless(cacheable.unless());</span><br><span class="line">        builder.setKey(cacheable.key());</span><br><span class="line">        builder.setKeyGenerator(cacheable.keyGenerator());</span><br><span class="line">        builder.setCacheManager(cacheable.cacheManager());</span><br><span class="line">        builder.setCacheResolver(cacheable.cacheResolver());</span><br><span class="line">        builder.setSync(cacheable.sync());</span><br><span class="line">        defaultConfig.applyDefault(builder);</span><br><span class="line">        CacheableOperation op = builder.build();</span><br><span class="line">        <span class="comment">//验证key()与keyGenerator()  以及CacheManager与CacheResolver之间的排他性。代码逻辑如下。</span></span><br><span class="line">        <span class="keyword">this</span>.validateCacheOperation(ae, op);</span><br><span class="line">        <span class="keyword">return</span> op;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateCacheOperation</span><span class="params">(AnnotatedElement ae, CacheOperation operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(operation.getKey()) &amp;&amp; StringUtils.hasText(operation.getKeyGenerator())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid cache annotation configuration on '"</span> + ae.toString() + <span class="string">"'. Both 'key' and 'keyGenerator' attributes have been set. These attributes are mutually exclusive: either set the SpEL expression used tocompute the key at runtime or set the name of the KeyGenerator bean to use."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(operation.getCacheManager()) &amp;&amp; StringUtils.hasText(operation.getCacheResolver())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid cache annotation configuration on '"</span> + ae.toString() + <span class="string">"'. Both 'cacheManager' and 'cacheResolver' attributes have been set. These attributes are mutually exclusive: the cache manager is used to configure adefault cache resolver if none is set. If a cache resolver is set, the cache managerwon't be used."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-4小结"><a href="#1-4小结" class="headerlink" title="1.4小结"></a>1.4小结</h3><p>由此Spring Cache通过缓存注解解析器，将对应的缓存注解解析成了CacheOperation对象，CacheOperation对象封装了缓存注解信息的细节，可以指导相应的缓存操作。</p><h2 id="2-谈谈CacheOperation缓存封装类"><a href="#2-谈谈CacheOperation缓存封装类" class="headerlink" title="2.谈谈CacheOperation缓存封装类"></a>2.谈谈CacheOperation缓存封装类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheOperation</span> <span class="keyword">implements</span> <span class="title">BasicOperation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; cacheNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String keyGenerator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cacheManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cacheResolver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String condition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String toString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheOperation是一个抽象的缓存操作类，它封装了Cache操作的基本属性，是对缓存信息的抽象</p><ol><li>CacheableOperation(@Cacheable)</li><li>CachePutOperation(@CachePut)</li><li>CacheEvictOperation(@CacheEvict)</li></ol><h2 id="3-缓存操作资源类"><a href="#3-缓存操作资源类" class="headerlink" title="3.缓存操作资源类"></a>3.缓存操作资源类</h2><p>Spring Cache提供了一个缓存操作资源接口(CacheOperationSource)来调用缓存注解的解析工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheOperationSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为一个执行方法返回所有的缓存操作集合</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Collection&lt;CacheOperation&gt; <span class="title">getCacheOperations</span><span class="params">(Method var1, @Nullable Class&lt;?&gt; var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCachingConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractCachingConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyCachingConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(</span><br><span class="line">        name = &#123;<span class="string">"org.springframework.cache.config.internalCacheAdvisor"</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanFactoryCacheOperationSourceAdvisor <span class="title">cacheAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanFactoryCacheOperationSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryCacheOperationSourceAdvisor();</span><br><span class="line">        advisor.setCacheOperationSource(<span class="keyword">this</span>.cacheOperationSource());</span><br><span class="line">        advisor.setAdvice(<span class="keyword">this</span>.cacheInterceptor());</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.enableCaching != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisor.setOrder(((Integer)<span class="keyword">this</span>.enableCaching.getNumber(<span class="string">"order"</span>)).intValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheOperationSource <span class="title">cacheOperationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationCacheOperationSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheInterceptor <span class="title">cacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CacheInterceptor interceptor = <span class="keyword">new</span> CacheInterceptor();</span><br><span class="line">        interceptor.configure(<span class="keyword">this</span>.errorHandler, <span class="keyword">this</span>.keyGenerator, <span class="keyword">this</span>.cacheResolver, <span class="keyword">this</span>.cacheManager);</span><br><span class="line">        interceptor.setCacheOperationSource(<span class="keyword">this</span>.cacheOperationSource());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在@Enable文章的代码解析中，在创建Advisor的时候将CacheOperationSource作为属性传递进去了。那么在方法调用时，AOP会通过CacheInterceptor拦截方法，调用CacheOperationSource获取解析方法上面的缓存注解。</p><p>CacheOperationSource有三个实现类，Spring Cache采用AnnotationCacheOperationSource来处理缓存注解的解析工作。</p><p>查看AnnotationCacheOperationSource的继承体系。</p><p>CacheOperationSource的设计采用的是模板模式的方式,获取CacheOperation的主要的通用逻辑在父类AbstractFallbackCacheOperationSource中,子类AnnotationCacheOperationSource主要实现差异化的功能，接下来看一下他们的实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationCacheOperationSource</span> <span class="keyword">extends</span> <span class="title">AbstractFallbackCacheOperationSource</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略了部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只允许public方法 执行缓存操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> publicMethodsOnly;</span><br><span class="line">    <span class="comment">//缓存注解解析器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;CacheAnnotationParser&gt; annotationParsers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Class上面对应的缓存操作(实现父类的方法，方法的调用的父类中)</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.determineCacheOperations((parser) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> parser.parseCacheAnnotations(clazz);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Method上面对应的缓存操作(实现父类的方法，方法的调用的父类中)</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.determineCacheOperations((parser) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> parser.parseCacheAnnotations(method);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历解析器集合，获取所有的CacheOperation</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;CacheOperation&gt; <span class="title">determineCacheOperations</span><span class="params">(AnnotationCacheOperationSource.CacheOperationProvider provider)</span> </span>&#123;</span><br><span class="line">        Collection&lt;CacheOperation&gt; ops = <span class="keyword">null</span>;</span><br><span class="line">        Iterator var3 = <span class="keyword">this</span>.annotationParsers.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">            CacheAnnotationParser annotationParser = (CacheAnnotationParser)var3.next();</span><br><span class="line">            Collection&lt;CacheOperation&gt; annOps = provider.getCacheOperations(annotationParser);</span><br><span class="line">            <span class="keyword">if</span> (annOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ops == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ops = annOps;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Collection&lt;CacheOperation&gt; combined = <span class="keyword">new</span> ArrayList(((Collection)ops).size() + annOps.size());</span><br><span class="line">                    combined.addAll((Collection)ops);</span><br><span class="line">                    combined.addAll(annOps);</span><br><span class="line">                    ops = combined;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Collection)ops;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用CacheAnnotationParser进行注解解析的函数式接口</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheOperationProvider</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function">Collection&lt;CacheOperation&gt; <span class="title">getCacheOperations</span><span class="params">(CacheAnnotationParser var1)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1查看AbstractFallbackCacheOperationSource源码"><a href="#3-1查看AbstractFallbackCacheOperationSource源码" class="headerlink" title="3.1查看AbstractFallbackCacheOperationSource源码"></a>3.1查看AbstractFallbackCacheOperationSource源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFallbackCacheOperationSource</span> <span class="keyword">implements</span> <span class="title">CacheOperationSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Collection&lt;CacheOperation&gt; NULL_CACHING_ATTRIBUTE = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护了一个缓存操作类的map, key为method和class的包装，可以确保唯一性。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Collection&lt;CacheOperation&gt;&gt; attributeCache = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行缓存注解解析工作的主要逻辑</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;CacheOperation&gt; <span class="title">getCacheOperations</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取method和class组成的唯一key</span></span><br><span class="line">            Object cacheKey = <span class="keyword">this</span>.getCacheKey(method, targetClass);</span><br><span class="line">            <span class="comment">//从缓存中去查找CacheOperation.</span></span><br><span class="line">            Collection&lt;CacheOperation&gt; cached = (Collection)<span class="keyword">this</span>.attributeCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cached != NULL_CACHING_ATTRIBUTE ? cached : <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果attributeCache没有发现，则进行缓存操作的解析</span></span><br><span class="line">                Collection&lt;CacheOperation&gt; cacheOps = <span class="keyword">this</span>.computeCacheOperations(method, targetClass);</span><br><span class="line">                <span class="keyword">if</span> (cacheOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.logger.trace(<span class="string">"Adding cacheable method '"</span> + method.getName() + <span class="string">"' with attribute: "</span> + cacheOps);</span><br><span class="line">                    &#125;</span><br><span class="line">                    将解析结构存入attributeCache,供下次使用</span><br><span class="line">                    <span class="keyword">this</span>.attributeCache.put(cacheKey, cacheOps);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.attributeCache.put(cacheKey, NULL_CACHING_ATTRIBUTE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> cacheOps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取由Method和Class产生的唯一key</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getCacheKey</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodClassKey(method, targetClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始解析缓存注解</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;CacheOperation&gt; <span class="title">computeCacheOperations</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断非pulic方法 是否可以获取缓存注解信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找到特定的方法</span></span><br><span class="line">            Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用子类实现 从方法上找缓存注解</span></span><br><span class="line">            Collection&lt;CacheOperation&gt; opDef = <span class="keyword">this</span>.findCacheOperations(specificMethod);</span><br><span class="line">            <span class="keyword">if</span> (opDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> opDef;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//调用子类实现，试着从Class上获取缓存注解</span></span><br><span class="line">                opDef = <span class="keyword">this</span>.findCacheOperations(specificMethod.getDeclaringClass());</span><br><span class="line">                <span class="keyword">if</span> (opDef != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> opDef;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//前面没有找到的话，则从原始执行方法上去找</span></span><br><span class="line">                    <span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">                        opDef = <span class="keyword">this</span>.findCacheOperations(method);</span><br><span class="line">                        <span class="keyword">if</span> (opDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> opDef;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//从原始执行方法的类上去找</span></span><br><span class="line">                        opDef = <span class="keyword">this</span>.findCacheOperations(method.getDeclaringClass());</span><br><span class="line">                        <span class="keyword">if</span> (opDef != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> opDef;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由子类实现逻辑</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line">    <span class="comment">//由子类实现逻辑</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(Method var1)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>本章本章主要从SpringCache 缓存注解的解析工作入手分析，主要的关键点如下：<br>（1）Spring cache提供了一个缓存注解解析类，专门负责解析类或者方法层次上面注解<br>（2）解析的过程将注解信息封装成CacheOperation的对象中，由此方面操作。<br>（3）提供了一个缓存操作资源类(CacheOperationSource)负责管控缓存注解的解析过程。只需将这个缓存操作资源置入想要的地方，就能在需要的地方完成缓存注解解析，提供了一个缓存信息的操作对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-缓存的解析&quot;&gt;&lt;a href=&quot;#1-缓存的解析&quot; class=&quot;headerlink&quot; title=&quot;1.缓存的解析&quot;&gt;&lt;/a&gt;1.缓存的解析&lt;/h2&gt;&lt;p&gt;Spring Cache提供了缓存解析器，负责为缓存注解抽象成一个缓存信息对象。我们通过面向对象的编
      
    
    </summary>
    
      <category term="Spring" scheme="https://shawnyou.tech/categories/Spring/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码|初识AutoProxyRegistrar</title>
    <link href="https://shawnyou.tech/2019/06/24/Spring-boot/%E5%88%9D%E8%AF%86AutoProxyRegistrar/"/>
    <id>https://shawnyou.tech/2019/06/24/Spring-boot/初识AutoProxyRegistrar/</id>
    <published>2019-06-24T14:51:50.000Z</published>
    <updated>2019-06-27T13:37:13.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AutoProxyRegistrar源码分析"><a href="#AutoProxyRegistrar源码分析" class="headerlink" title="AutoProxyRegistrar源码分析"></a>AutoProxyRegistrar源码分析</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;AutoProxyRegistrar源码分析&quot;&gt;&lt;a href=&quot;#AutoProxyRegistrar源码分析&quot; class=&quot;headerlink&quot; title=&quot;AutoProxyRegistrar源码分析&quot;&gt;&lt;/a&gt;AutoProxyRegistrar源码
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://shawnyou.tech/categories/SpringBoot/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>

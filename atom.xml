<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>攻城虱</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-23T02:48:06.062Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Shawn You</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>strategy</title>
    <link href="http://yoursite.com/2019/03/23/strategy/"/>
    <id>http://yoursite.com/2019/03/23/strategy/</id>
    <published>2019-03-23T02:48:06.000Z</published>
    <updated>2019-03-23T02:48:06.062Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于单利模式的几种变体</title>
    <link href="http://yoursite.com/2019/03/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/22/单例模式/</id>
    <published>2019-03-22T13:14:01.000Z</published>
    <updated>2019-03-22T13:16:31.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于单例模式的一点思考"><a href="#关于单例模式的一点思考" class="headerlink" title="关于单例模式的一点思考"></a>关于单例模式的一点思考</h2><p>单例模式是一种简单的的设计模式。虽然简单，但是应用却是十分的广泛。所有有必要针对单例模式的知识点进行梳理。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p>确保类只有一个实例，并自动实例化向整个系统提供全局的访问点。从定义上可以推断出单例模式更倾向于节约资源，利于资源的重用从而节约时间。所以应用单例模式的对象应该具有以下特点：</p></blockquote><ul><li>频繁地创建、销毁且性能无法优化</li><li>消耗大量资源（读取配置、产生依赖对象），可以在应用启动时直接产生一个单例对象</li><li>避免资源的多重占用 </li><li>设置全局的访问点，优化和共享资源访问</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h3 id="单例模式设计的几点考虑"><a href="#单例模式设计的几点考虑" class="headerlink" title="单例模式设计的几点考虑"></a>单例模式设计的几点考虑</h3><ul><li>延迟加载</li><li>线程安全</li><li>并发性能</li><li>序列化/反序列化安全</li></ul><table><thead><tr><th>name</th><th>延迟加载</th><th>线程安全</th><th>并发性能</th><th>序列化/反序列化安全</th></tr></thead><tbody><tr><td>饿汉式</td><td>N</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>懒汉式(不加锁)</td><td>Y</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>懒汉式(加锁)</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>DCL</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>静态内部类</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>枚举</td><td>N</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table><h3 id="单例模式实现"><a href="#单例模式实现" class="headerlink" title="单例模式实现"></a>单例模式实现</h3><ol><li>饿汉式</li></ol><p>类加载时完成初始化</p><ul><li><p>类加载慢</p></li><li><p>获取对象速度快</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton singleton = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>懒汉式</li></ol><p>获取对象的时候完成初始化，实现懒加载。但是线程不安全，高并发下会出现多个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if( instance == null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>懒汉式（加锁）</li></ol><p>线程安全的懒汉式单例模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SafeSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static SafeSingleton instance = null;</span><br><span class="line"></span><br><span class="line">    private SafeSingleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized SafeSingleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new SafeSingleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>双重检查DCL</li></ol><ul><li><p>synchronized同步代码块保证只创建一个对象。</p></li><li><p>条件判断使对象创建过后，不在进入同步块，减少锁的粒度。</p></li><li><p>volatitle防止指令重排序(否则出现一个线程创建一般的对象呗另一个线程访问，造成空指针)。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                if(instance == null)&#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>静态内部类</li></ol><ul><li><p>利用ClassLoader的机制保证了线程安全</p></li><li><p>相比饿汉式单例模式，实现懒加载，只有显示调用SingleHolder才会触发初始化。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder&#123;</span><br><span class="line"></span><br><span class="line">        private static final Singleton instance = new Singleton();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static final Singleton getInstance()&#123;</span><br><span class="line">        return SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>枚举</li></ol><ul><li>线程安全（虚拟机加载枚举的时候，会使用ClassLoader的loadClass方法，这个方法使用同步代码块保证线程安全）</li></ul><ul><li>解决反序列化破坏单例的问题:<ul><li>普通序列化过程中，通过反射调用默认构造函数来初始化对象，反序列化的对象是新建的</li><li>枚举的反序列化不是通过构造函数实现，因此不会发生于由于反序列化导致的单例破坏问题</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    public void getInstance()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何设计优秀的单例模式"><a href="#如何设计优秀的单例模式" class="headerlink" title="如何设计优秀的单例模式"></a>如何设计优秀的单例模式</h3><h3 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h3><ol><li>双重校验DCL为什么使用volatile</li><li>synchronized与volatile的区别</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于单例模式的一点思考&quot;&gt;&lt;a href=&quot;#关于单例模式的一点思考&quot; class=&quot;headerlink&quot; title=&quot;关于单例模式的一点思考&quot;&gt;&lt;/a&gt;关于单例模式的一点思考&lt;/h2&gt;&lt;p&gt;单例模式是一种简单的的设计模式。虽然简单，但是应用却是十分的广泛。所
      
    
    </summary>
    
    
      <category term="design pattern" scheme="http://yoursite.com/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="http://yoursite.com/2019/03/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/22/工厂模式/</id>
    <published>2019-03-22T13:14:01.000Z</published>
    <updated>2019-03-22T13:14:50.286Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>

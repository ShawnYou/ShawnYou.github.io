<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>攻城虱</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shawnyou.tech/"/>
  <updated>2019-11-24T08:34:53.223Z</updated>
  <id>https://shawnyou.tech/</id>
  
  <author>
    <name>Shawn You</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>05|深入浅出索引(下)</title>
    <link href="https://shawnyou.tech/2019/11/24/mysql-notes/05%7C%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95(%E4%B8%8B)/"/>
    <id>https://shawnyou.tech/2019/11/24/mysql-notes/05|深入浅出索引(下)/</id>
    <published>2019-11-24T04:40:29.000Z</published>
    <updated>2019-11-24T08:34:53.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h3><blockquote><p>select * from T where K betwwen 3 and 5 需要执行几次树的搜索操作？ ID为主键索引，K为普通索引</p></blockquote><ul><li>在K的普通索引树上找到K=3对应的记录，取得对应的主键ID=300值—普通索引</li><li>通过主键ID=300查到对应的记录—主键索引(回表)</li><li>在K索引树取下一个值K=5,取得主键ID=500—普通索引</li><li>根据ID=500取得对应的记录—主键索引(回表)</li><li>K索引树取下一个值k=6,不满足条件，循环结束—普通索引</li></ul><p>这个过程总共搜索了三次普通索引，二次主键索引(回表)。如何优化索引，避免回表过程？可以使用覆盖索引</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><blockquote><p>select ID from T where K betwwen 3 and 5. 由于查询的返回值通过普通索引就能够获取，所以就不用回表去查主键索引了。能够减少数的搜索次数，提高查询性能。</p></blockquote><h4 id="覆盖索引的使用场景"><a href="#覆盖索引的使用场景" class="headerlink" title="覆盖索引的使用场景"></a>覆盖索引的使用场景</h4><ul><li>联合索引</li></ul><p>身份证号是市民的唯一表示，而身份证号通常应该建立普通索引，如果有一个需求是通过身份证号查市民的真实姓名，可以建立身份证号和姓名的联合索引，由此可以通过直接在身份证的普通索引上直接搜索到姓名，由此可以避免回表的操作，减少语句执行时间。</p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><blockquote><p>B+树可以通过索引的最左前缀，来定位记录，由此可以避免为每一种查询都设计一个索引</p></blockquote><ol><li>最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符</li></ol><ul><li>联合索引(name,age), 如(“张三”，10)，通过张三可以通过索引检索到记录，通过”张”也可以通过索引检索到记录。</li></ul><ol start="2"><li>如果通过调配联合索引的字段顺序来减少索引的维护？</li></ol><ul><li>评估索引的复用能力，当已经有了(a,b)的联合索引，就不需要单独在a上面建立索引了。</li><li>空间的考虑。如果已经有了(age,name)的索引，因为name的字段比age大，所以我们可以调配字段顺序(name,age),就只需要再加一个age的单字段索引。</li></ul><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><blockquote><p>select * from tuser where name like “张%” and age = 10 and is ismale = 1 对于这样的查询语句，在老版本的mysql中，age和ismale没法通过最左前缀进行匹配。需要回表到主键索引进行过滤。</p></blockquote><ul><li>Mysql5.6之前，通过普通索引找到对应的主键，然后回到主键索引上找到对应的记录，最后去比对字段值去过滤。</li><li>Mysql5.6之后，Mysql进行索引下推优化，可以普通索引遍历过程中，对索引包含的字段(age)先作判断，由此在普通索引搜索过程过滤掉不满足条件的记录，减少了回表的次数。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;索引分析&quot;&gt;&lt;a href=&quot;#索引分析&quot; class=&quot;headerlink&quot; title=&quot;索引分析&quot;&gt;&lt;/a&gt;索引分析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;select * from T where K betwwen 3 and 5 需要执行几次树的搜
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>04|深入浅出索引(上)</title>
    <link href="https://shawnyou.tech/2019/11/22/mysql-notes/04%7C%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95(%E4%B8%8A)/"/>
    <id>https://shawnyou.tech/2019/11/22/mysql-notes/04|深入浅出索引(上)/</id>
    <published>2019-11-22T14:47:29.000Z</published>
    <updated>2019-11-24T07:42:08.760Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>索引类似于书本的目录，能够提高数据查询效率。</p></blockquote><h3 id="常见的索引模型"><a href="#常见的索引模型" class="headerlink" title="常见的索引模型"></a>常见的索引模型</h3><ol><li>哈希表<blockquote><p>key-value的数据存储结构。通过哈希函数将key换算成一个具体的数组位置，将value放在对应的数组位置。多余哈希冲突，则使用拉链法进行解决。</p></blockquote></li></ol><ul><li>插入很快。因为可以直接往后追加</li><li>区间查询速度很慢。因为因为数据存储不是有序的。</li><li>哈希表适合等值查询的场景(Memcached和一些NoSQL引擎)</li></ul><ol start="2"><li>有序数组<blockquote><p>有序数组在等值查询和范围查询的场景中的性能都非常优秀。</p></blockquote></li></ol><ul><li>查询效率高，利用二分法进行查询。，同样也支持范围查询</li><li>新增记录成本太高，因为每增加一条新纪录，都要挪动后面所有的记录</li></ul><p>所以有序数组适合静态存储引擎，如2017年某个城市的所有人口信息。</p><ol start="3"><li>搜索树</li></ol><ul><li>二叉搜索树</li></ul><p>左子节点小于父节点，父节点小于右子节点。</p><p>查询复杂度：O(log(n))<br>更新时间复杂度：O(log(n))</p><ul><li>数据库为什么不使用二叉树而选择多叉树</li></ul><p>（1）二叉树虽然效率高，但是每一层存储的数据量比较少。假如在特别大的数据量的情况下，使用二叉树会导致树的层数非常高。层数越多，访问磁盘的次数越多，磁盘读取往往是性能的瓶颈，所以二叉树的读取性能就回很差。</p><p>（2）为了尽量的少读磁盘，让查询过程访问尽量少的数据块，应该使用多叉树。假如一个N=1200的多叉树，树高为4，可以存储1200的三次方的数据(17亿)。也就是在这17亿的数据中，查找一条记录，最多访问磁盘三次。</p><h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><blockquote><p>InnoDB的索引模型：B+树索引模型,每一个索引在InnoDB中就对应一棵B+树</p></blockquote><h4 id="B-树索引类型"><a href="#B-树索引类型" class="headerlink" title="B+树索引类型"></a>B+树索引类型</h4><ol><li>主键索引(聚簇索引)</li></ol><p>叶子节点存储整行数据</p><ol start="2"><li>普通索引(二级索引)</li></ol><p>叶子节点存储的是主键的值</p><h5 id="主键索引和非主键索引的区别"><a href="#主键索引和非主键索引的区别" class="headerlink" title="主键索引和非主键索引的区别"></a>主键索引和非主键索引的区别</h5><ol><li>通过主键查询的方式，就是直接搜索主键索引这棵B+树。</li><li>如果通过普通索引的方式，则是先通过普通索引B+树查询到主键值，再通过主键值去主键索引B+树里面所有(回表)</li></ol><blockquote><p>普通索引会多扫描一次索引，应该优先使用主键索引</p></blockquote><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><blockquote><p>B+树维护了索引的有效性，当插入新值的时候，就要做必要的维护</p></blockquote><ol><li>页分裂</li></ol><p>当插入数据所在页的数据页满了，就要重新申请一个新的数据页，让后再挪动部分数据过去。性能受影响。</p><ol start="2"><li>页合并</li></ol><p>相邻两个数据页因为删除了数据，利用率很低之后，会将数据页进行合并。</p><h4 id="自增字段的重要性"><a href="#自增字段的重要性" class="headerlink" title="自增字段的重要性"></a>自增字段的重要性</h4><blockquote><p>索引的维护过程中，会出现页分裂和页合并的现象，这些是比较耗费性能的。所以现在的建表规范里面都要求使用自增字段。那自增字段能够对索引维护起到什么作用吗？</p></blockquote><ul><li>自增逐渐的插入数据模式都是追加操作，不会涉及挪动其他记录，不会触发叶子节点的分裂。—-性能</li><li>如果使用业务字段做主键，不容易保证有序插入，写数据成本高。—-性能</li><li>自增逐渐相比业务字段作逐渐节省存储空间。如果使用身份证之类的作为主键，那么普通索引的叶子节点(主键)就会占用比较多的存储空间(字符串20个字节)，整型(4个字节)，长整型(8个字节)。—-存储空间</li></ul><blockquote><p>主键长度约小，普通索引的叶子节点就越小，普通索引占用的空间就越小</p></blockquote><p>业务字段作为主键的场景：</p><ol><li>只有一个索引</li><li>该索引是唯一索引</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;索引类似于书本的目录，能够提高数据查询效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常见的索引模型&quot;&gt;&lt;a href=&quot;#常见的索引模型&quot; class=&quot;headerlink&quot; title=&quot;常见的索引模型&quot;&gt;&lt;/a&gt;常见的索引模型&lt;
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>03|事务隔离</title>
    <link href="https://shawnyou.tech/2019/11/22/mysql-notes/03%7C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <id>https://shawnyou.tech/2019/11/22/mysql-notes/03|事务隔离/</id>
    <published>2019-11-22T14:47:29.000Z</published>
    <updated>2019-11-23T10:37:43.518Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>事务保证一组数据库操作，要么全部成功，要么全部失败。</p></blockquote><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><ol><li>Atomicity(原子性)</li><li>Consistency(一致性)</li><li>Isolation(隔离性)</li><li>Durability(持久性)</li></ol><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><blockquote><p>为什么需要隔离性</p></blockquote><p>因为多个事务同时执行的时候，容易引发脏读、不可重复读、幻读等问题。</p><ol><li>脏读</li></ol><p>一个事务在处理过程中，读取了别的事务未提交的脏数据。如果别的事务回滚，那么我们拿到的数据是不准确的，由此会造成一定的问题。</p><ol start="2"><li><p>不可重复读<br>一个事务在处理过程，两次查询的数据不一样。这是因为第二次查询读取了别的事务已经提交的变更。那么我们在这个事务操作中就能看到别的事务提交的变更。</p></li><li><p>幻读<br>一个事务在处理过程中，两次查询的数据不一样，第二次查询读取了别的事务已经提交的变更。</p></li></ol><ul><li>不可重复读和幻读都在还未提交的事务过程中读取了另一个已经提交的事务变更。不可重读读针对的是同一个数据项，而幻读针对的是一批数据整体。例如小编去取钱，</li><li>不可重复读：重点在于修改，两次读取的数据不一样</li><li>幻读：重点在新增和删除，比如这里有一个事务1要查询公司里面工资1000元以上的职工有10人，这时另一个事务2里面，HR新增了一个新员工，工资也在1000元以上。这时候事务1在次查询，发现工资1000元以上的人员增加到了11个人。</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><blockquote><p>多个事务同时执行，引发的脏读、不可重复读、幻读等问题，就产生了‘隔离级别’的概念。隔离越严实，效率就越低，但数据一致性的程度越高。由此需要在隔离性和效率之间寻找一个平衡点。</p></blockquote><ol><li>读未提交(read uncommitted)</li></ol><blockquote><p>一个事务还未提交的时候，它的变更能被别的事务看到。</p></blockquote><ol start="2"><li>读提交(read committed)</li></ol><p>一个事务提交之后，它的改动才能被其他事务看到。事务A修改了一项数据，B事务读取不到变动，只有等事务A提交之后，B事务才能够读取。由此可以避免脏读，但是会造成不可重复读和幻读。</p><ol start="3"><li>可重复读(repeatable read)</li></ol><p>一个事务在执行过程中看到的数据和事务启动是看到的数据时一致的。当事务A开始读取一条记录的时候，事务B是不能够进行修改的。由此可以避免不可重复读，但是还是会造成幻读(事务A读取一些数据，事务B插入或者删除一些数据，这时候在此读取，会发现数据多了或者少了)。</p><ol start="4"><li>串行化(serializable)</li></ol><p>‘读’和‘写’会进行加锁，读写锁发生冲突时候，后访问的事务必须等前一个事务执行完成。</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><blockquote><p>事务的隔离级别往往和视图有关系，不同的隔离级别创建视图的顺序是不一样。视图可以理解为数据副本，每次创建视图，将当前已持久化的数据创建副本，后面直接从副本读取，从而达到数据隔离。</p></blockquote><ol><li>读未提交</li></ol><p>没有视图概念，不同事务在读未提交的隔离级别上直接读取记录的最新值，容易出现脏读的情况。</p><ol start="2"><li>读提交</li></ol><p>视图在每个SQL开始执行的时候创建的。所以第二次查询的时候，别的事务已经提交了数据，重新建立的视图里面包含已经变更的数据。因此能够读取别的事务修改的数据。</p><ol start="3"><li>可重复读</li></ol><p>视图是在事务启动的时候创建的。（TODO）</p><ol start="4"><li>串行化</li></ol><p>直接用加锁的方式避免并行访问</p><h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><h4 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h4><p>同一条记录在系统中可以存在多个版本。</p><h4 id="避免使用长事务"><a href="#避免使用长事务" class="headerlink" title="避免使用长事务"></a>避免使用长事务</h4><ul><li>长事务存在很老的事务视图，在未提交之前，所有的回滚记录都必须保留，会导致大量占用存储空间。</li><li>占用锁资源，拖垮数据库。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;事务保证一组数据库操作，要么全部成功，要么全部失败。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h3&gt;&lt;ol&gt;
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>02|一条SQL更新语句是如何执行的</title>
    <link href="https://shawnyou.tech/2019/11/21/mysql-notes/02%7C%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>https://shawnyou.tech/2019/11/21/mysql-notes/02|一条SQL更新语句是如何执行的/</id>
    <published>2019-11-21T14:47:29.000Z</published>
    <updated>2019-11-22T14:30:14.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="执行流程-和查询流程保持一致"><a href="#执行流程-和查询流程保持一致" class="headerlink" title="执行流程(和查询流程保持一致)"></a>执行流程(和查询流程保持一致)</h3><ul><li>连接器 –&gt; 连接数据库</li><li>分析器 –&gt; 词法和语法分析这是一条更新语句</li><li>优化器 –&gt; 决定使用哪个索引</li><li>执行器 –&gt; 找到具体的某一行，然后更新</li></ul><h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><blockquote><p>SQL更新过程中涉及两个重要的日志模块</p></blockquote><h4 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h4><ul><li>WHAT<br>redo log(重做日志)类似于掌柜账本记账的模式，先记账(先写日志)，后清账(再写磁盘)</li><li>WHY<br>mysql的每一次更新过程IO成本和查找成本很高。每一次更新操作都要在磁盘中找到对应的记录然后更新。当更新比较频繁的时候，性能就非常的不好。</li><li>HOW<br>当一条记录需要更新的时候：</li></ul><ol><li>InnoDB引擎先把记录写到redo log</li><li>更新内存</li><li>InnoDB引擎在系统空闲的时候，将操作记录更新到磁盘中</li></ol><p>PS：</p><ul><li>redo log是InnoDB特有的日志</li><li>如果更新特别频繁，redo log特别多，系统会放下工作，将一部分redo log的任务更新到磁盘中，为redo log腾出空间</li><li>redo log是固定大小的，可以配置一组四个文件，每个文件1GB, 从头开始写，写到末尾然后继续回到开头写</li><li>InnoDB 可以依靠redo log保证数据库发生异常重启的时候，之前的记录不会丢失(crash-safe)</li></ul><h4 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog(归档日志)"></a>binlog(归档日志)</h4><p>bin log是server层实现的日志，可以应用于所有存储引擎</p><h4 id="redolog与binlog的区别"><a href="#redolog与binlog的区别" class="headerlink" title="redolog与binlog的区别"></a>redolog与binlog的区别</h4><ul><li>redolog是InnoDB独有, binlog是Server层实现的，所有引擎都可以使用</li><li>redolog是物理日志，记录某个数据页做了什么改动，binlog是逻辑日志，记录语句的原始逻辑</li><li>redolog是循环写，空间固定会用完，binlog可以最佳写入，并不会覆盖以前的日志。</li></ul><h3 id="update语句执行的内部流程"><a href="#update语句执行的内部流程" class="headerlink" title="update语句执行的内部流程"></a>update语句执行的内部流程</h3><ol><li>执行器通过引擎找到对应的记录。如果这一行所在数据页在内存中，引擎就从内存中取，否则就从磁盘读入。</li><li>执行器拿到对应的数据，进行更新，然后调用引擎接口写入数据</li><li>引擎将数据更新到内存，同时将更新操作记录到redo日志，此时redo log处于prepare状态，告知执行器执行完成。</li><li>执行器生成binlog,并将binlog写入磁盘</li><li>执行器调用引擎的提交事务接口，引擎将写入的redo log改成提交状态</li></ol><blockquote><p>以上的流程包含了一个两阶段提交</p></blockquote><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><ul><li>what<br>保证redolog与binlog的数据逻辑一致性。</li></ul><ol><li>先写redolog后写binlog<br>redolog写完，binlog还没写完的时候，MySQL异常重启,可以通过redolog将记录恢复。但是当我们需要通过binlog恢复临时库的时候，由于binlog丢失，临时库的数据会少一次更新操作</li><li>先写binlog厚些redolog<br>binlog写完，redolog还没写，系统崩溃之后，由此数据没有被更新。但是binlog已经有了更新的日志，之后用binlog来恢复数据的时候就多了一条更新。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;执行流程-和查询流程保持一致&quot;&gt;&lt;a href=&quot;#执行流程-和查询流程保持一致&quot; class=&quot;headerlink&quot; title=&quot;执行流程(和查询流程保持一致)&quot;&gt;&lt;/a&gt;执行流程(和查询流程保持一致)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;连接器 –&amp;gt; 连接数据
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>为什么基于接口而非实现编程</title>
    <link href="https://shawnyou.tech/2019/11/21/design-pattern-notes/09%7C%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B/"/>
    <id>https://shawnyou.tech/2019/11/21/design-pattern-notes/09|基于接口而非实现编程/</id>
    <published>2019-11-21T14:47:29.000Z</published>
    <updated>2019-11-23T08:55:31.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于接口而非实现编程是一种非常高效且提高代码质量的手段。</p></blockquote><h3 id="接口的含义"><a href="#接口的含义" class="headerlink" title="接口的含义"></a>接口的含义</h3><ol><li>抽象层面的接口</li></ol><ul><li>服务端与客户端之间的“接口”</li><li>类库提供的“接口”</li><li>通信协议接口</li></ul><ol start="2"><li>代码接口</li></ol><ul><li>编程语言中的接口类或者抽象类</li></ul><h3 id="接口的意义"><a href="#接口的意义" class="headerlink" title="接口的意义"></a>接口的意义</h3><blockquote><p>“面向接口而非实现编程”也可以表述为”基于抽象而非实现编程”，抽象是提高代码扩展性、灵活性、可维护性的最优先手段之一。</p></blockquote><ul><li>将接口与实现相分离，封装不稳定的实现，暴露稳定的接口。</li><li>抽象、顶层、脱离具体实现的设计可以提高代码的灵活性，应对未来复杂的需求变化。</li></ul><h3 id="基于接口而非实现编程的要求"><a href="#基于接口而非实现编程的要求" class="headerlink" title="基于接口而非实现编程的要求"></a>基于接口而非实现编程的要求</h3><ol><li>函数命名不能暴露任何实现细节，适配未来的需求变化，应该取一个较为宽泛且概括中心概念的名字。</li><li>封装具体实现细节</li><li>为实现类定义抽象的接口。使用者依赖接口，而非具体的实现类编程。</li></ol><h3 id="接口实现的度"><a href="#接口实现的度" class="headerlink" title="接口实现的度"></a>接口实现的度</h3><blockquote><p>任何事情都要讲一个度,对于基于接口而非实现编程的‘度’应该如何把握呢？哪些可以直接使用实现类进行编程？</p></blockquote><ol><li>业务场景中，某个功能只有一种实现方式，我来也不可能会被其他方式替代，就没必要设计接口，直接使用实现类</li><li>系统特别稳定，基本不做维护，就没必要在扩展性投入不必要的开发时间。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于接口而非实现编程是一种非常高效且提高代码质量的手段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;接口的含义&quot;&gt;&lt;a href=&quot;#接口的含义&quot; class=&quot;headerlink&quot; title=&quot;接口的含义&quot;&gt;&lt;/a&gt;接口的含义&lt;/h
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>01|一条SQL查询语句是如何执行的</title>
    <link href="https://shawnyou.tech/2019/11/20/mysql-notes/01%7C%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>https://shawnyou.tech/2019/11/20/mysql-notes/01|一条SQL查询语句是如何执行的/</id>
    <published>2019-11-20T14:47:29.000Z</published>
    <updated>2019-11-21T12:57:59.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><blockquote><p>负责与客户端建立连接。<br>shou processlist (查看连接)<br>长连接内存占用过大OOM如何解决：</p><ul><li>定期断开长连接</li><li>MySQL5.7以及以上版本，可以在执行完比较大的操作后，通过mysql_reset_connection重新初始化连接资源，使连接恢复到刚刚创建完时的状态。</li></ul></blockquote><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><blockquote><p>建立连接后会优先查询缓存，查询缓存弊大于利，MySQL8.0将查询缓存删除。</p><ul><li>对于一张经常变更的表，缓存经常被清空，缓存的命中率非常低，对于静态表适合做查询缓存。</li><li>按需使用查询缓存。</li></ul></blockquote><h4 id="分析器-分析要做什么"><a href="#分析器-分析要做什么" class="headerlink" title="分析器(分析要做什么)"></a>分析器(分析要做什么)</h4><blockquote><p>如何没有命中查询缓存，就要开始执行SQl语句了。</p><ul><li>词法分析：识别关键词，如select, from ,table….</li><li>语法分析：根据语法规则判断SQL语句的正确性。</li></ul></blockquote><h4 id="优化器-确定执行方案"><a href="#优化器-确定执行方案" class="headerlink" title="优化器(确定执行方案)"></a>优化器(确定执行方案)</h4><ul><li>当存在多个索引的时候，决定索引的选择</li><li>多表关联的时候，决定多个表的连接顺序<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><blockquote><p>根据选择的存储引擎调用引擎接口从第一行开始比对，直到最后一行找出所有满足条件的记录返回结果集。</p></blockquote></li><li>慢查询日志：rows_examined(语句执行过程中的扫描行)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MySQL基础架构&quot;&gt;&lt;a href=&quot;#MySQL基础架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL基础架构&quot;&gt;&lt;/a&gt;MySQL基础架构&lt;/h3&gt;&lt;h4 id=&quot;连接器&quot;&gt;&lt;a href=&quot;#连接器&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="mysql-notes" scheme="https://shawnyou.tech/categories/mysql-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>01|接口与抽象类</title>
    <link href="https://shawnyou.tech/2019/11/20/design-pattern-notes/08%7C%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>https://shawnyou.tech/2019/11/20/design-pattern-notes/08|接口与抽象类/</id>
    <published>2019-11-20T14:47:29.000Z</published>
    <updated>2019-11-23T08:55:49.397Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接口和抽象类是很多设计模式、设计思想、设计原则编程实现的基础。</p></blockquote><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>不允许被实例化</li><li>抽象类包含属性和方法。其中方法可以包含代码实现，也可以不包含代码实现(抽象方法)</li><li>子类集成抽象类。子类必须实现抽象类的抽象方法。</li></ul><h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><ul><li>接口不能包含属性(成员变量)</li><li>接口只能声明方法，方法不能包含方法实现</li><li>类实现接口的时候，必须实现接口的所有方法。</li></ul><h3 id="抽象类与接口类的区别"><a href="#抽象类与接口类的区别" class="headerlink" title="抽象类与接口类的区别"></a>抽象类与接口类的区别</h3><ul><li>抽象类的本质是类，主要只能被子类去继承，体现着is-a的继承关系</li><li>接口类表示一种has-a的关系，体现具有某些功能，表现为一种约定和协议。</li></ul><h3 id="抽象类和接口类能解决什么问题"><a href="#抽象类和接口类能解决什么问题" class="headerlink" title="抽象类和接口类能解决什么问题"></a>抽象类和接口类能解决什么问题</h3><h4 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h4><ul><li>代码复用，避免在子类中编写相同的代码</li></ul><blockquote><p>同样是代码复用，为什么不直接用继承，而要使用抽象类来实现？相比继承来说，抽象类的实现更加的优雅</p></blockquote><ul><li>父类中定义一个被子类继承的无意义的log()方法会使代码的可读性变差。</li><li>创建子类的时候，会忘记重写log()。然而抽象类会强制子类实现。</li><li>继承中，父类是可以被实例化的，我们可以调用空的log()方法，会增加类误用的风险。(可以通过设置私有构造函数解决)</li></ul><h4 id="接口类-1"><a href="#接口类-1" class="headerlink" title="接口类"></a>接口类</h4><blockquote><p>侧重于解耦。对行为进行抽象，之关系接口的协议，不关心具体实现，实现约定与实现相分离。</p></blockquote><h3 id="模拟接口类和抽象类"><a href="#模拟接口类和抽象类" class="headerlink" title="模拟接口类和抽象类"></a>模拟接口类和抽象类</h3><h4 id="模拟接口类"><a href="#模拟接口类" class="headerlink" title="模拟接口类"></a>模拟接口类</h4><blockquote><p>普通类模拟接口类</p></blockquote><ul><li>protect访问权限，避免类被实例化</li><li>不含具体实现的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockInteface</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MockInteface</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MethodUnSupportedException(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类和接口类的使用"><a href="#抽象类和接口类的使用" class="headerlink" title="抽象类和接口类的使用"></a>抽象类和接口类的使用</h3><ul><li>抽象类：is-a的关系，解决代码复用的问题</li><li>接口类：has-a的关系，解决耦合的问题，表示一组行为特征，隔离接口和具体实现</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;接口和抽象类是很多设计模式、设计思想、设计原则编程实现的基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h3&gt;&lt;ul
      
    
    </summary>
    
      <category term="design-notes" scheme="https://shawnyou.tech/categories/design-notes/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式|手写一个迭代器</title>
    <link href="https://shawnyou.tech/2019/10/22/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/10/22/迭代器模式/</id>
    <published>2019-10-22T15:25:15.000Z</published>
    <updated>2019-11-04T14:54:52.428Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>我们在日常的开发中，特别是在使用集合的过程中都或多或少使用了迭代器来对集合进行遍历。这时候我们就会思考一个问题，明明简单的For循环就能解决的集合遍历问题，我们非得创造一个迭代器来进行集合的遍历，使用迭代器来遍历到底有什么不一样的地方吗？本着‘存在即合理’的原则，我们通过手写迭代器的方式来深入了解一下迭代器模式的实现和带来的编码好处。</p><h4 id="实现案例"><a href="#实现案例" class="headerlink" title="实现案例"></a>实现案例</h4><p>有一个书架，我们想要知道这个书架里面堆了哪些书籍，这时候我们就需要对书架里面的书一本一本的遍历，直到没有书本，我们就能清楚的知道数据上堆满了哪些书籍。</p><ul><li><p>可以被遍历的标记(生成迭代器的接口)<br>首先提供一个接口，来标明这个类是可以被遍历的集合。实现这个接口的类可以生成对应的迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代器接口<br>迭代器的抽象接口，定义了两个方法<br>（1）是否还有下一个元素<br>（2）返回下一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>集合存储的元素（书本）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">book</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代器实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelfIterator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookShelf bookShelf;</span><br><span class="line">    <span class="comment">//指向当前遍历的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//将当前的index与集合的大小做比较，小于集合大小，说明还有元素。</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; bookShelf.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Book book = bookShelf.getBookAt(index);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>书架类<br>书架类用于存放书本，可以用来遍历，因此需要实现Aggregate接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span> <span class="keyword">implements</span> <span class="title">Aggregate</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//生成对应的迭代器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BookShelfIterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = bookShelf.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext)&#123;</span><br><span class="line">    Book book = (Book)it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>由此，我们就自定义实现了一个迭代器，可以满足集合遍历的基本需求</p></blockquote><h3 id="迭代器模式的几点思考"><a href="#迭代器模式的几点思考" class="headerlink" title="迭代器模式的几点思考"></a>迭代器模式的几点思考</h3><h4 id="为什么要使用迭代模式"><a href="#为什么要使用迭代模式" class="headerlink" title="为什么要使用迭代模式"></a>为什么要使用迭代模式</h4><p>遍历与实现分开，无论BookShelf是怎样的实现，只要能够获取到对应的迭代器，遍历方式都是不会变的，利于代码的扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = bookShelf.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext)&#123;</span><br><span class="line">    Book book = (Book)it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多种迭代器"><a href="#多种迭代器" class="headerlink" title="多种迭代器"></a>多种迭代器</h4><p>迭代器实现了遍历集合的方式，那么我们可以设计多种不一样的迭代器。</p><ul><li>从后向前遍历</li><li>跳跃性遍历</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a&gt;迭代器模式&lt;/h3&gt;&lt;p&gt;我们在日常的开发中，特别是在使用集合的过程中都或多或少使用了迭代器来对集合进行遍历。这时候我们就会思考一个问题，明明
      
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://shawnyou.tech/2019/07/03/%E9%87%8D%E6%9E%84/%E9%87%8D%E6%9E%84/"/>
    <id>https://shawnyou.tech/2019/07/03/重构/重构/</id>
    <published>2019-07-03T14:43:46.340Z</published>
    <updated>2019-07-08T13:50:08.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重构总结（TODO）"><a href="#重构总结（TODO）" class="headerlink" title="重构总结（TODO）"></a>重构总结（TODO）</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="1-什么是重构"><a href="#1-什么是重构" class="headerlink" title="1.什么是重构"></a>1.什么是重构</h2><blockquote><p>重构是对软件的内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高代码可理解性，降低维护成本。</p></blockquote><p>关键：</p><ul><li>更好的可读性</li><li>更好的可扩展性</li><li>功能保持一致</li></ul><h2 id="为什么要重构"><a href="#为什么要重构" class="headerlink" title="为什么要重构"></a>为什么要重构</h2><ul><li>改进软件设计<br>整理代码，使代码结构回到最初设计，维持代码该有的形态，避免软件腐烂变质。</li><li>使软件更容易理解<br>代码是人与及其交互的语言。保持语言的简洁有助于：<br>（1）理解代码<br>（2）后来者维护代码</li><li>帮助找到Bug<br>重构过程可以重新梳理逻辑，找到潜在的Bug。</li><li>提高编程速度<br>良好的设计师快速开发的根本。</li></ul><h2 id="何时进行重构"><a href="#何时进行重构" class="headerlink" title="何时进行重构"></a>何时进行重构</h2><p>事不过三，三则重构</p><ul><li>添加功能时重构<br>添加功能时，理解需要修改的代码，使添加功能更加轻松。</li><li>修改错误时候重构<br>好的代码是足够清晰以至于能够肉眼观察bug，所以当遇到bug时，说明设计不够清晰，因而需要重构</li><li>复审代码时重构</li></ul><h3 id="重构的期望"><a href="#重构的期望" class="headerlink" title="重构的期望"></a>重构的期望</h3><ul><li>容易阅读</li><li>所有的逻辑都只在唯一地点指定</li><li>新的改动不会危及现有行为</li><li>尽可能简单的表达条件逻辑</li></ul><h2 id="代码的坏味道（什么样的代码需要重构）"><a href="#代码的坏味道（什么样的代码需要重构）" class="headerlink" title="代码的坏味道（什么样的代码需要重构）"></a>代码的坏味道（什么样的代码需要重构）</h2><ol><li>重复代码（Duplicated Code）</li></ol><ul><li>同一个类中的两个函数具有相同的代码，可以使用Extract Method提炼吃重复代码</li><li>两个兄弟子类具有相同的代码，则提炼相同代码（Extract Method）,再将提炼出来的函数推送给父类（Pull up method）</li><li>对于部分相同的情况，则分离出相似部分和差异部分，使用模板设计模式。</li><li>两个不相关类出现重复代码，则将重复代码提取到一个独立类。 </li></ul><ol start="2"><li>过长的函数（Long method）</li></ol><ul><li>小型函数作为“间接层”具有解释能力、共享能力、选择能力</li><li>当需要用注释来描述代码的时候，就应该对函数进行分解，把需要说明的部分放入独立的函数，以其用途来命名</li><li>函数传参里有过多的参数和临时变量，应该尽量消除临时变量，使参数列表更加简洁。</li></ul><ol start="3"><li>过大的类（Large Class）</li><li>过长的参数列（Long Paramenter List）</li><li>发散式变化（Divergent Change）</li><li>散弹式修改（Shotgun Surgery）</li><li>依恋情节（Feature Envy）</li><li>数据泥团（Data Clumps）</li><li>基本类型偏执（Primitive Obsession）</li><li>Switch现身（Switch Statement）</li><li>平行继承体系（Parallel Inheritance Hierarchies）</li><li>冗赘类（Lazy Class）</li><li>夸夸其谈未来性（Speculative Generality）</li><li>令人迷惑的临时字段（Temporary Field）</li><li>过度耦合的消息链（Message Chains）</li><li>中间人（Middle Man）</li><li>狎昵关系（Inappropriate Intimacy）</li><li>异曲同工的类（Alternative Classes with Different Interfaces）</li><li>不完美的库类（Incomplete Library Class）</li><li>纯稚的数据类（Data Class）</li><li>被拒绝的遗赠（Refused Bequest）</li><li>过多的注释（Comments）</li></ol><p>重构列表</p><p>重新组织函数</p><ol><li>提炼函数（Extract Method）<br>适用场景</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重构总结（TODO）&quot;&gt;&lt;a href=&quot;#重构总结（TODO）&quot; class=&quot;headerlink&quot; title=&quot;重构总结（TODO）&quot;&gt;&lt;/a&gt;重构总结（TODO）&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringCache源码| Spring Cache的AOP实现原理</title>
    <link href="https://shawnyou.tech/2019/06/27/Spring-boot/%E7%BC%93%E5%AD%98%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA/"/>
    <id>https://shawnyou.tech/2019/06/27/Spring-boot/缓存方法拦截/</id>
    <published>2019-06-27T14:51:50.000Z</published>
    <updated>2019-06-30T14:41:57.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h2><p>Spring Cache是通过AOP面向切面编程的思想来对缓存的操作进行封装，通过拦截器对实现了Spring Cache注解的方法进行拦截，可以根据注解信息去完成相应的缓存操作。</p><h2 id="2-CacheInterceptor拦截器"><a href="#2-CacheInterceptor拦截器" class="headerlink" title="2. CacheInterceptor拦截器"></a>2. CacheInterceptor拦截器</h2><p>Spring Cache提供了一个缓存拦截器，负责拦截方法调用执行缓存逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">extends</span> <span class="title">CacheAspectSupport</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被拦截的方法都会走invoke</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//invocation就是一个连接点(Joinpoint),其实就是对方调用方法的封装。</span></span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        CacheOperationInvoker aopAllianceInvoker = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ThrowableWrapper(var2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//核心的方法，来自于父类</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.execute(aopAllianceInvoker, invocation.getThis(), method, invocation.getArguments());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ThrowableWrapper var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5.getOriginal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheIntercepto实现了MethodInterceptor，MethodInterceptor主要对方法进行拦截，查看MethodInterceptor的继承图，发现MethodInterceptor就是一个Advice，在Spring AOP的概念里面，Advice就是一个通知，通知封装了AOP的横切逻辑。由此来说CacheInterceptor作为一个通知，他里面肯定包含缓存操作的横切逻辑，能够处理方法调用前后的缓存操作。</p><h3 id="2-1-查看父类的核心方法execute"><a href="#2-1-查看父类的核心方法execute" class="headerlink" title="2.1 查看父类的核心方法execute"></a>2.1 查看父类的核心方法execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">execute</span><span class="params">(CacheOperationInvoker invoker, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//是否初始化成功</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.initialized) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = <span class="keyword">this</span>.getTargetClass(target);</span><br><span class="line">            <span class="comment">//获取CacheOperation资源类，负责解析Spring Cache注解的类</span></span><br><span class="line">            CacheOperationSource cacheOperationSource = <span class="keyword">this</span>.getCacheOperationSource();</span><br><span class="line">            <span class="keyword">if</span>(cacheOperationSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//解析注解，得到CacheOperation的集合。</span></span><br><span class="line">                Collection&lt;CacheOperation&gt; operations = cacheOperationSource.getCacheOperations(method, targetClass);</span><br><span class="line">                <span class="keyword">if</span>(!CollectionUtils.isEmpty(operations)) &#123;</span><br><span class="line">                    <span class="comment">//调用内部方法execute，封装了一个缓存操作的上下文并传入</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.execute(invoker, method, <span class="keyword">new</span> CacheAspectSupport.CacheOperationContexts(operations, method, args, target, targetClass));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要作用：</p><ol><li>获取缓存操作集合CacheOperation</li><li>封装缓存操作上下文，并调用内部的execute方法</li></ol><h3 id="2-2-核心内部方法execute"><a href="#2-2-核心内部方法execute" class="headerlink" title="2.2 核心内部方法execute"></a>2.2 核心内部方法execute</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">execute</span><span class="params">(CacheOperationInvoker invoker, Method method, CacheAspectSupport.CacheOperationContexts contexts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(contexts.isSynchronized()) &#123;</span><br><span class="line">            <span class="comment">//获取CacheableOperation对应的缓存操作上下文。</span></span><br><span class="line">            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)contexts.get(CacheableOperation.class).iterator().next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) &#123;</span><br><span class="line">                Object key = <span class="keyword">this</span>.generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class="line">                <span class="comment">//获取缓存对象</span></span><br><span class="line">                Cache cache = (Cache)context.getCaches().iterator().next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.wrapCacheValue(method, cache.get(key, () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.unwrapReturnValue(<span class="keyword">this</span>.invokeOperation(invoker));</span><br><span class="line">                    &#125;));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ValueRetrievalException var10) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (ThrowableWrapper)var10.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.invokeOperation(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1. 处理BeforeInvocation = true的缓存删除操作</span></span><br><span class="line">            <span class="keyword">this</span>.processCacheEvicts(contexts.get(CacheEvictOperation.class), <span class="keyword">true</span>, CacheOperationExpressionEvaluator.NO_RESULT);</span><br><span class="line">            <span class="comment">//2. 查找是否有@Cacheable的缓存数据</span></span><br><span class="line">            ValueWrapper cacheHit = <span class="keyword">this</span>.findCachedItem(contexts.get(CacheableOperation.class));</span><br><span class="line">            List&lt;CacheAspectSupport.CachePutRequest&gt; cachePutRequests = <span class="keyword">new</span> LinkedList();</span><br><span class="line">            <span class="keyword">if</span>(cacheHit == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果没有缓存数据，则封装成CachePutRequest</span></span><br><span class="line">                <span class="keyword">this</span>.collectPutRequests(contexts.get(CacheableOperation.class), CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object cacheValue;</span><br><span class="line">            Object returnValue;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cacheHit != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.hasCachePut(contexts)) &#123;</span><br><span class="line">                <span class="comment">//获取缓存数据里面的值</span></span><br><span class="line">                cacheValue = cacheHit.get();</span><br><span class="line">                returnValue = <span class="keyword">this</span>.wrapCacheValue(method, cacheValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有找到Cacheable的缓存数据，或者缓存注解是CachePut则调用方法，获取方法返回值</span></span><br><span class="line">                returnValue = <span class="keyword">this</span>.invokeOperation(invoker);</span><br><span class="line">                cacheValue = <span class="keyword">this</span>.unwrapReturnValue(returnValue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 将CachePut注解封装成CachePutRequest</span></span><br><span class="line">            <span class="keyword">this</span>.collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests);</span><br><span class="line">            Iterator var8 = cachePutRequests.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//遍历cachePutRequest，将方法调用的返回值置入缓存中。</span></span><br><span class="line">                CacheAspectSupport.CachePutRequest cachePutRequest = (CacheAspectSupport.CachePutRequest)var8.next();</span><br><span class="line">                cachePutRequest.apply(cacheValue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理BeforeInvocation = false的缓存删除操作</span></span><br><span class="line">            <span class="keyword">this</span>.processCacheEvicts(contexts.get(CacheEvictOperation.class), <span class="keyword">false</span>, cacheValue);</span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果不需要同步，该方法主要完成了以下的逻辑</p><ol><li>处理BeforeInvocation = true的缓存删除操作 </li><li>通过@Cacheable注解找到对应的缓存值。</li><li>如果没有找到对应的缓存数据，则将@Cacheable封装成CachePutRequest，标记为一个插入缓存的请求。</li><li>进行方法调用</li><li>将CachePut注解封装成CachePutRequest</li><li>遍历CachePutReqeust集合，将方法调用的返回值置入缓存中。</li><li>处理BeforeInvocation = false的缓存删除操作  </li></ol><p>梳理一下，这个方法里面包括三个注解的逻辑</p><ol><li><p>@Cacheable<br>(1) 首先从缓存中找@Cacheable对应的缓存<br>(2) 如果缓存存在，则取出缓存值作为返回值<br>(3) 如果缓存不存在，则进行方法调用，获取返回值，并将返回值置入缓存</p></li><li><p>@CachePut<br>(1) 如果包含cachePut注解，则进行方法调用。<br>(2) 获取方法返回值，并置入缓存之中。</p></li><li><p>@CacheEvic<br>(1) 在方法调用签执行缓存删除操作。<br>(2) 在方法调用后执行缓存删除操作。</p></li></ol><h4 id="2-2-1-processCacheEvicts"><a href="#2-2-1-processCacheEvicts" class="headerlink" title="2.2.1 processCacheEvicts"></a>2.2.1 processCacheEvicts</h4><p>我们来看看缓存删除的具体逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//beforeInvocation指的是方法调用前还是调用后，@CacheEvict可以进行设置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCacheEvicts</span><span class="params">(Collection&lt;CacheAspectSupport.CacheOperationContext&gt; contexts, <span class="keyword">boolean</span> beforeInvocation, @Nullable Object result)</span> </span>&#123;</span><br><span class="line">        Iterator var4 = contexts.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)var4.next();</span><br><span class="line">            CacheEvictOperation operation = (CacheEvictOperation)context.metadata.operation;</span><br><span class="line">            <span class="keyword">if</span>(beforeInvocation == operation.isBeforeInvocation() &amp;&amp; <span class="keyword">this</span>.isConditionPassing(context, result)) &#123;</span><br><span class="line">                <span class="comment">//处理缓存删除操作</span></span><br><span class="line">                <span class="keyword">this</span>.performCacheEvict(context, operation, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performCacheEvict</span><span class="params">(CacheAspectSupport.CacheOperationContext context, CacheEvictOperation operation, @Nullable Object result)</span> </span>&#123;</span><br><span class="line">        Object key = <span class="keyword">null</span>;</span><br><span class="line">        Iterator var5 = context.getCaches().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//遍历获取Cache对象</span></span><br><span class="line">            Cache cache = (Cache)var5.next();</span><br><span class="line">            <span class="keyword">if</span>(operation.isCacheWide()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logInvalidating(context, operation, (Object)<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//删除全部缓存</span></span><br><span class="line">                <span class="keyword">this</span>.doClear(cache);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    key = <span class="keyword">this</span>.generateKey(context, result);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.logInvalidating(context, operation, key);</span><br><span class="line">                <span class="comment">//删除指定key的缓存</span></span><br><span class="line">                <span class="keyword">this</span>.doEvict(cache, key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-2-2-findCachedItem-获取缓存数据"><a href="#2-2-2-findCachedItem-获取缓存数据" class="headerlink" title="2.2.2 findCachedItem(获取缓存数据)"></a>2.2.2 findCachedItem(获取缓存数据)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ValueWrapper <span class="title">findCachedItem</span><span class="params">(Collection&lt;CacheAspectSupport.CacheOperationContext&gt; contexts)</span> </span>&#123;</span><br><span class="line">        Object result = CacheOperationExpressionEvaluator.NO_RESULT;</span><br><span class="line">        Iterator var3 = contexts.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)var3.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isConditionPassing(context, result)) &#123;</span><br><span class="line">                <span class="comment">//生成相应的Cache key</span></span><br><span class="line">                Object key = <span class="keyword">this</span>.generateKey(context, result);</span><br><span class="line">                <span class="comment">//通过缓存上下文和key找寻相应的缓存包装对象</span></span><br><span class="line">                ValueWrapper cached = <span class="keyword">this</span>.findInCaches(context, key);</span><br><span class="line">                <span class="keyword">if</span>(cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cached;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.trace(<span class="string">"No cache entry for key '"</span> + key + <span class="string">"' in cache(s) "</span> + context.getCacheNames());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ValueWrapper <span class="title">findInCaches</span><span class="params">(CacheAspectSupport.CacheOperationContext context, Object key)</span> </span>&#123;</span><br><span class="line">        Iterator var3 = context.getCaches().iterator();</span><br><span class="line"></span><br><span class="line">        Cache cache;</span><br><span class="line">        ValueWrapper wrapper;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!var3.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取缓存对象，并通过key去查找缓存值</span></span><br><span class="line">            cache = (Cache)var3.next();</span><br><span class="line">            wrapper = <span class="keyword">this</span>.doGet(cache, key);</span><br><span class="line">        &#125; <span class="keyword">while</span>(wrapper == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">"Cache entry for key '"</span> + key + <span class="string">"' found in cache '"</span> + cache.getName() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3collectPutRequests-封装存储缓存的请求"><a href="#2-2-3collectPutRequests-封装存储缓存的请求" class="headerlink" title="2.2.3collectPutRequests(封装存储缓存的请求)"></a>2.2.3collectPutRequests(封装存储缓存的请求)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectPutRequests</span><span class="params">(Collection&lt;CacheAspectSupport.CacheOperationContext&gt; contexts, @Nullable Object result, Collection&lt;CacheAspectSupport.CachePutRequest&gt; putRequests)</span> </span>&#123;</span><br><span class="line">        Iterator var4 = contexts.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)var4.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isConditionPassing(context, result)) &#123;</span><br><span class="line">                Object key = <span class="keyword">this</span>.generateKey(context, result);</span><br><span class="line">                <span class="comment">//通过key和缓存上下文封装一个插入缓存的请求。</span></span><br><span class="line">                putRequests.add(<span class="keyword">new</span> CacheAspectSupport.CachePutRequest(context, key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>目前，关于Spring Cache的源码分析就告一段落了，总的来说，SpringCache的分析文章主要对缓存注解实现的源码做了一个简要的分析，目的是能够对缓存操作的AOP实现原理有一个清晰的认识。能够搞清楚Spring Cache是如何借助AOP的思想来实现如何简单、快捷且代码侵入低的缓存组件。由此我们可以借鉴这些思想和案例来丰富我们的阅历，以助于提高我们的技术水平，帮助我们能够实现类似的开源组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-简述&quot;&gt;&lt;a href=&quot;#1-简述&quot; class=&quot;headerlink&quot; title=&quot;1. 简述&quot;&gt;&lt;/a&gt;1. 简述&lt;/h2&gt;&lt;p&gt;Spring Cache是通过AOP面向切面编程的思想来对缓存的操作进行封装，通过拦截器对实现了Spring Cache
      
    
    </summary>
    
      <category term="Spring" scheme="https://shawnyou.tech/categories/Spring/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringCache源码| SpringCache缓存注解解析</title>
    <link href="https://shawnyou.tech/2019/06/26/Spring-boot/%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://shawnyou.tech/2019/06/26/Spring-boot/缓存注解解析与应用/</id>
    <published>2019-06-26T14:51:50.000Z</published>
    <updated>2019-06-30T14:53:36.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-缓存的解析"><a href="#1-缓存的解析" class="headerlink" title="1.缓存的解析"></a>1.缓存的解析</h2><p>Spring Cache提供了缓存解析器，负责为缓存注解抽象成一个缓存信息对象。我们通过面向对象的编程方式就能够轻松的获取缓存操作信息</p><h3 id="1-1CacheAnnotationParser缓存注解解析器"><a href="#1-1CacheAnnotationParser缓存注解解析器" class="headerlink" title="1.1CacheAnnotationParser缓存注解解析器"></a>1.1CacheAnnotationParser缓存注解解析器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheAnnotationParser</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对类上面的缓存注解进行解析</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line">    <span class="comment">//对方法上面的注解进行解析</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Method var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheAnnotationParser有一个实现类SpringCacheAnnotationParser,两个方法的实现是一样的，最终method也会转换成Class。所以这里针对parseCacheAnnotations(Class&lt;?&gt; var1)做解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取</span></span><br><span class="line">    SpringCacheAnnotationParser.DefaultCacheConfig defaultConfig = <span class="keyword">this</span>.getDefaultCacheConfig(type);</span><br><span class="line">    <span class="comment">//2. 通过DefaultCacheConfig信息和class去解析缓存注解</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parseCacheAnnotations(defaultConfig, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    SpringCacheAnnotationParser.DefaultCacheConfig defaultConfig = <span class="keyword">this</span>.getDefaultCacheConfig(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parseCacheAnnotations(defaultConfig, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-2getDefaultCacheConfig"><a href="#1-2getDefaultCacheConfig" class="headerlink" title="1.2getDefaultCacheConfig"></a>1.2getDefaultCacheConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpringCacheAnnotationParser.<span class="function">DefaultCacheConfig <span class="title">getDefaultCacheConfig</span><span class="params">(Class&lt;?&gt; target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取类上面的@CacheConfig注解信息</span></span><br><span class="line">        CacheConfig annotation = (CacheConfig)AnnotatedElementUtils.findMergedAnnotation(target, CacheConfig.class);</span><br><span class="line">        <span class="comment">//如果@CacheConfig不存在，则构建一个默认的DefaultCacheConfig</span></span><br><span class="line">        <span class="keyword">return</span> annotation != <span class="keyword">null</span> ? <span class="keyword">new</span> SpringCacheAnnotationParser.DefaultCacheConfig(annotation.cacheNames(), annotation.keyGenerator(), annotation.cacheManager(), annotation.cacheResolver()) : <span class="keyword">new</span> SpringCacheAnnotationParser.DefaultCacheConfig();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-parseCacheAnnotations"><a href="#1-3-parseCacheAnnotations" class="headerlink" title="1.3. parseCacheAnnotations"></a>1.3. parseCacheAnnotations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(SpringCacheAnnotationParser.DefaultCacheConfig cachingConfig, AnnotatedElement ae)</span> </span>&#123;</span><br><span class="line">        Collection&lt;CacheOperation&gt; ops = <span class="keyword">this</span>.parseCacheAnnotations(cachingConfig, ae, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (ops != <span class="keyword">null</span> &amp;&amp; ops.size() &gt; <span class="number">1</span> &amp;&amp; ae.getAnnotations().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Collection&lt;CacheOperation&gt; localOps = <span class="keyword">this</span>.parseCacheAnnotations(cachingConfig, ae, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (localOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> localOps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ops;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法只是一个空壳，真正的逻辑在this.parseCacheAnnotations(cachingConfig, ae, false)这里面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;CacheOperation&gt; <span class="title">parseCacheAnnotations</span><span class="params">(SpringCacheAnnotationParser.DefaultCacheConfig cachingConfig, AnnotatedElement ae, <span class="keyword">boolean</span> localOnly)</span> </span>&#123;</span><br><span class="line">        Collection&lt;CacheOperation&gt; ops = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//解析@Cacheable</span></span><br><span class="line">        Collection&lt;Cacheable&gt; cacheables = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, Cacheable.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, Cacheable.class);</span><br><span class="line">        <span class="keyword">if</span> (!cacheables.isEmpty()) &#123;</span><br><span class="line">            ops = <span class="keyword">this</span>.lazyInit((Collection)<span class="keyword">null</span>);</span><br><span class="line">            Iterator var6 = cacheables.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                Cacheable cacheable = (Cacheable)var6.next();</span><br><span class="line">                ops.add(<span class="keyword">this</span>.parseCacheableAnnotation(ae, cachingConfig, cacheable));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析@cacheEvict</span></span><br><span class="line">        Collection&lt;CacheEvict&gt; evicts = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, CacheEvict.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, CacheEvict.class);</span><br><span class="line">        <span class="keyword">if</span> (!evicts.isEmpty()) &#123;</span><br><span class="line">            ops = <span class="keyword">this</span>.lazyInit(ops);</span><br><span class="line">            Iterator var13 = evicts.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var13.hasNext()) &#123;</span><br><span class="line">                CacheEvict evict = (CacheEvict)var13.next();</span><br><span class="line">                ops.add(<span class="keyword">this</span>.parseEvictAnnotation(ae, cachingConfig, evict));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析@CachePut</span></span><br><span class="line">        Collection&lt;CachePut&gt; puts = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, CachePut.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, CachePut.class);</span><br><span class="line">        <span class="keyword">if</span> (!puts.isEmpty()) &#123;</span><br><span class="line">            ops = <span class="keyword">this</span>.lazyInit(ops);</span><br><span class="line">            Iterator var15 = puts.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                CachePut put = (CachePut)var15.next();</span><br><span class="line">                ops.add(<span class="keyword">this</span>.parsePutAnnotation(ae, cachingConfig, put));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析Cache</span></span><br><span class="line">        Collection&lt;Caching&gt; cachings = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, Caching.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, Caching.class);</span><br><span class="line">        <span class="keyword">if</span> (!cachings.isEmpty()) &#123;</span><br><span class="line">            ops = <span class="keyword">this</span>.lazyInit(ops);</span><br><span class="line">            Iterator var17 = cachings.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var17.hasNext()) &#123;</span><br><span class="line">                Caching caching = (Caching)var17.next();</span><br><span class="line">                Collection&lt;CacheOperation&gt; cachingOps = <span class="keyword">this</span>.parseCachingAnnotation(ae, cachingConfig, caching);</span><br><span class="line">                <span class="keyword">if</span> (cachingOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ops.addAll(cachingOps);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ops;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>由上可知，代码分别对@Cacheable,@CachePut,@CacheEvict进行解析，一旦发现相应的注解，就对注解信息封装成对应的CacheOperation(缓存操作信息对象)。封装过程的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CacheableOperation <span class="title">parseCacheableAnnotation</span><span class="params">(AnnotatedElement ae, SpringCacheAnnotationParser.DefaultCacheConfig defaultConfig, Cacheable cacheable)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> Builder();</span><br><span class="line">        builder.setName(ae.toString());</span><br><span class="line">        builder.setCacheNames(cacheable.cacheNames());</span><br><span class="line">        builder.setCondition(cacheable.condition());</span><br><span class="line">        builder.setUnless(cacheable.unless());</span><br><span class="line">        builder.setKey(cacheable.key());</span><br><span class="line">        builder.setKeyGenerator(cacheable.keyGenerator());</span><br><span class="line">        builder.setCacheManager(cacheable.cacheManager());</span><br><span class="line">        builder.setCacheResolver(cacheable.cacheResolver());</span><br><span class="line">        builder.setSync(cacheable.sync());</span><br><span class="line">        defaultConfig.applyDefault(builder);</span><br><span class="line">        CacheableOperation op = builder.build();</span><br><span class="line">        <span class="comment">//验证key()与keyGenerator()  以及CacheManager与CacheResolver之间的排他性。代码逻辑如下。</span></span><br><span class="line">        <span class="keyword">this</span>.validateCacheOperation(ae, op);</span><br><span class="line">        <span class="keyword">return</span> op;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateCacheOperation</span><span class="params">(AnnotatedElement ae, CacheOperation operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(operation.getKey()) &amp;&amp; StringUtils.hasText(operation.getKeyGenerator())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid cache annotation configuration on '"</span> + ae.toString() + <span class="string">"'. Both 'key' and 'keyGenerator' attributes have been set. These attributes are mutually exclusive: either set the SpEL expression used tocompute the key at runtime or set the name of the KeyGenerator bean to use."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(operation.getCacheManager()) &amp;&amp; StringUtils.hasText(operation.getCacheResolver())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid cache annotation configuration on '"</span> + ae.toString() + <span class="string">"'. Both 'cacheManager' and 'cacheResolver' attributes have been set. These attributes are mutually exclusive: the cache manager is used to configure adefault cache resolver if none is set. If a cache resolver is set, the cache managerwon't be used."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-4小结"><a href="#1-4小结" class="headerlink" title="1.4小结"></a>1.4小结</h3><p>由此Spring Cache通过缓存注解解析器，将对应的缓存注解解析成了CacheOperation对象，CacheOperation对象封装了缓存注解信息的细节，可以指导相应的缓存操作。</p><h2 id="2-谈谈CacheOperation缓存封装类"><a href="#2-谈谈CacheOperation缓存封装类" class="headerlink" title="2.谈谈CacheOperation缓存封装类"></a>2.谈谈CacheOperation缓存封装类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheOperation</span> <span class="keyword">implements</span> <span class="title">BasicOperation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; cacheNames;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String keyGenerator;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cacheManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cacheResolver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String condition;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String toString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheOperation是一个抽象的缓存操作类，它封装了Cache操作的基本属性，是对缓存信息的抽象</p><ol><li>CacheableOperation(@Cacheable)</li><li>CachePutOperation(@CachePut)</li><li>CacheEvictOperation(@CacheEvict)</li></ol><h2 id="3-缓存操作资源类"><a href="#3-缓存操作资源类" class="headerlink" title="3.缓存操作资源类"></a>3.缓存操作资源类</h2><p>Spring Cache提供了一个缓存操作资源接口(CacheOperationSource)来调用缓存注解的解析工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheOperationSource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为一个执行方法返回所有的缓存操作集合</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Collection&lt;CacheOperation&gt; <span class="title">getCacheOperations</span><span class="params">(Method var1, @Nullable Class&lt;?&gt; var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCachingConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractCachingConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyCachingConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(</span><br><span class="line">        name = &#123;<span class="string">"org.springframework.cache.config.internalCacheAdvisor"</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanFactoryCacheOperationSourceAdvisor <span class="title">cacheAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanFactoryCacheOperationSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryCacheOperationSourceAdvisor();</span><br><span class="line">        advisor.setCacheOperationSource(<span class="keyword">this</span>.cacheOperationSource());</span><br><span class="line">        advisor.setAdvice(<span class="keyword">this</span>.cacheInterceptor());</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.enableCaching != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisor.setOrder(((Integer)<span class="keyword">this</span>.enableCaching.getNumber(<span class="string">"order"</span>)).intValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheOperationSource <span class="title">cacheOperationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationCacheOperationSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheInterceptor <span class="title">cacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CacheInterceptor interceptor = <span class="keyword">new</span> CacheInterceptor();</span><br><span class="line">        interceptor.configure(<span class="keyword">this</span>.errorHandler, <span class="keyword">this</span>.keyGenerator, <span class="keyword">this</span>.cacheResolver, <span class="keyword">this</span>.cacheManager);</span><br><span class="line">        interceptor.setCacheOperationSource(<span class="keyword">this</span>.cacheOperationSource());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在@Enable文章的代码解析中，在创建Advisor的时候将CacheOperationSource作为属性传递进去了。那么在方法调用时，AOP会通过CacheInterceptor拦截方法，调用CacheOperationSource获取解析方法上面的缓存注解。</p><p>CacheOperationSource有三个实现类，Spring Cache采用AnnotationCacheOperationSource来处理缓存注解的解析工作。</p><p>查看AnnotationCacheOperationSource的继承体系。</p><p>CacheOperationSource的设计采用的是模板模式的方式,获取CacheOperation的主要的通用逻辑在父类AbstractFallbackCacheOperationSource中,子类AnnotationCacheOperationSource主要实现差异化的功能，接下来看一下他们的实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationCacheOperationSource</span> <span class="keyword">extends</span> <span class="title">AbstractFallbackCacheOperationSource</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略了部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只允许public方法 执行缓存操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> publicMethodsOnly;</span><br><span class="line">    <span class="comment">//缓存注解解析器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;CacheAnnotationParser&gt; annotationParsers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Class上面对应的缓存操作(实现父类的方法，方法的调用的父类中)</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.determineCacheOperations((parser) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> parser.parseCacheAnnotations(clazz);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Method上面对应的缓存操作(实现父类的方法，方法的调用的父类中)</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.determineCacheOperations((parser) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> parser.parseCacheAnnotations(method);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历解析器集合，获取所有的CacheOperation</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;CacheOperation&gt; <span class="title">determineCacheOperations</span><span class="params">(AnnotationCacheOperationSource.CacheOperationProvider provider)</span> </span>&#123;</span><br><span class="line">        Collection&lt;CacheOperation&gt; ops = <span class="keyword">null</span>;</span><br><span class="line">        Iterator var3 = <span class="keyword">this</span>.annotationParsers.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">            CacheAnnotationParser annotationParser = (CacheAnnotationParser)var3.next();</span><br><span class="line">            Collection&lt;CacheOperation&gt; annOps = provider.getCacheOperations(annotationParser);</span><br><span class="line">            <span class="keyword">if</span> (annOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ops == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ops = annOps;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Collection&lt;CacheOperation&gt; combined = <span class="keyword">new</span> ArrayList(((Collection)ops).size() + annOps.size());</span><br><span class="line">                    combined.addAll((Collection)ops);</span><br><span class="line">                    combined.addAll(annOps);</span><br><span class="line">                    ops = combined;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Collection)ops;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用CacheAnnotationParser进行注解解析的函数式接口</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheOperationProvider</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function">Collection&lt;CacheOperation&gt; <span class="title">getCacheOperations</span><span class="params">(CacheAnnotationParser var1)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1查看AbstractFallbackCacheOperationSource源码"><a href="#3-1查看AbstractFallbackCacheOperationSource源码" class="headerlink" title="3.1查看AbstractFallbackCacheOperationSource源码"></a>3.1查看AbstractFallbackCacheOperationSource源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFallbackCacheOperationSource</span> <span class="keyword">implements</span> <span class="title">CacheOperationSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Collection&lt;CacheOperation&gt; NULL_CACHING_ATTRIBUTE = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护了一个缓存操作类的map, key为method和class的包装，可以确保唯一性。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Collection&lt;CacheOperation&gt;&gt; attributeCache = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行缓存注解解析工作的主要逻辑</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;CacheOperation&gt; <span class="title">getCacheOperations</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取method和class组成的唯一key</span></span><br><span class="line">            Object cacheKey = <span class="keyword">this</span>.getCacheKey(method, targetClass);</span><br><span class="line">            <span class="comment">//从缓存中去查找CacheOperation.</span></span><br><span class="line">            Collection&lt;CacheOperation&gt; cached = (Collection)<span class="keyword">this</span>.attributeCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cached != NULL_CACHING_ATTRIBUTE ? cached : <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果attributeCache没有发现，则进行缓存操作的解析</span></span><br><span class="line">                Collection&lt;CacheOperation&gt; cacheOps = <span class="keyword">this</span>.computeCacheOperations(method, targetClass);</span><br><span class="line">                <span class="keyword">if</span> (cacheOps != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.logger.trace(<span class="string">"Adding cacheable method '"</span> + method.getName() + <span class="string">"' with attribute: "</span> + cacheOps);</span><br><span class="line">                    &#125;</span><br><span class="line">                    将解析结构存入attributeCache,供下次使用</span><br><span class="line">                    <span class="keyword">this</span>.attributeCache.put(cacheKey, cacheOps);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.attributeCache.put(cacheKey, NULL_CACHING_ATTRIBUTE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> cacheOps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取由Method和Class产生的唯一key</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getCacheKey</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodClassKey(method, targetClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始解析缓存注解</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;CacheOperation&gt; <span class="title">computeCacheOperations</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断非pulic方法 是否可以获取缓存注解信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找到特定的方法</span></span><br><span class="line">            Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用子类实现 从方法上找缓存注解</span></span><br><span class="line">            Collection&lt;CacheOperation&gt; opDef = <span class="keyword">this</span>.findCacheOperations(specificMethod);</span><br><span class="line">            <span class="keyword">if</span> (opDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> opDef;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//调用子类实现，试着从Class上获取缓存注解</span></span><br><span class="line">                opDef = <span class="keyword">this</span>.findCacheOperations(specificMethod.getDeclaringClass());</span><br><span class="line">                <span class="keyword">if</span> (opDef != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> opDef;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//前面没有找到的话，则从原始执行方法上去找</span></span><br><span class="line">                    <span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">                        opDef = <span class="keyword">this</span>.findCacheOperations(method);</span><br><span class="line">                        <span class="keyword">if</span> (opDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> opDef;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//从原始执行方法的类上去找</span></span><br><span class="line">                        opDef = <span class="keyword">this</span>.findCacheOperations(method.getDeclaringClass());</span><br><span class="line">                        <span class="keyword">if</span> (opDef != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> opDef;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由子类实现逻辑</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(Class&lt;?&gt; var1)</span></span>;</span><br><span class="line">    <span class="comment">//由子类实现逻辑</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Collection&lt;CacheOperation&gt; <span class="title">findCacheOperations</span><span class="params">(Method var1)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>本章本章主要从SpringCache 缓存注解的解析工作入手分析，主要的关键点如下：<br>（1）Spring cache提供了一个缓存注解解析类，专门负责解析类或者方法层次上面注解<br>（2）解析的过程将注解信息封装成CacheOperation的对象中，由此方面操作。<br>（3）提供了一个缓存操作资源类(CacheOperationSource)负责管控缓存注解的解析过程。只需将这个缓存操作资源置入想要的地方，就能在需要的地方完成缓存注解解析，提供了一个缓存信息的操作对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-缓存的解析&quot;&gt;&lt;a href=&quot;#1-缓存的解析&quot; class=&quot;headerlink&quot; title=&quot;1.缓存的解析&quot;&gt;&lt;/a&gt;1.缓存的解析&lt;/h2&gt;&lt;p&gt;Spring Cache提供了缓存解析器，负责为缓存注解抽象成一个缓存信息对象。我们通过面向对象的编
      
    
    </summary>
    
      <category term="Spring" scheme="https://shawnyou.tech/categories/Spring/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringCache源码| SpringCache源码总览</title>
    <link href="https://shawnyou.tech/2019/06/24/Spring-boot/SpringCache%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://shawnyou.tech/2019/06/24/Spring-boot/SpringCache源码解析/</id>
    <published>2019-06-24T14:51:50.000Z</published>
    <updated>2019-06-30T15:07:07.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Spring提供了一种基于注解（annotation）的缓存技术，他并不是具体的缓存使用方案，而是一个对缓存使用的抽象方案。只要代码使用相应的缓存注解，就能使用各种定义的缓存操作。由此一来缓存的操作非常的便捷，对代码的侵入比较少，让开发者更关注于业务逻辑的实现。</p><h3 id="1-1-如何使用Spring-Cache"><a href="#1-1-如何使用Spring-Cache" class="headerlink" title="1.1 如何使用Spring Cache"></a>1.1 如何使用Spring Cache</h3><h2 id="2-SpringCache的原理"><a href="#2-SpringCache的原理" class="headerlink" title="2. SpringCache的原理"></a>2. SpringCache的原理</h2><p>缓存的操作相对固定，可以借助AOP面向切面编程的思想将缓存操作作为通用的逻辑封装起来。SpringCache借助AOP的思想将缓存操作封装成了通用的模块。接下来通过一个流程图来了解一下Spring Cache缓存模块的原理。</p><h3 id="2-1-SpringCache的基本接口和注解"><a href="#2-1-SpringCache的基本接口和注解" class="headerlink" title="2.1 SpringCache的基本接口和注解"></a>2.1 SpringCache的基本接口和注解</h3><h4 id="2-1-1-Cache和CacheManager"><a href="#2-1-1-Cache和CacheManager" class="headerlink" title="2.1.1 Cache和CacheManager"></a>2.1.1 Cache和CacheManager</h4><ol><li>Cache<br>Cache接口是缓存操作的基础接口，它提供了关于缓存的增、删、改、查的相关操作。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回原始的缓存对象</span></span><br><span class="line">    <span class="function">Object <span class="title">getNativeCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回包装值</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Cache.<span class="function">ValueWrapper <span class="title">get</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">    <span class="comment">//获取指定类型的缓存</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Object var1, @Nullable Class&lt;T&gt; var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Object var1, Callable&lt;T&gt; var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Object var1, @Nullable Object var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入缓存</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Cache.<span class="function">ValueWrapper <span class="title">putIfAbsent</span><span class="params">(Object var1, @Nullable Object var2)</span></span>;</span><br><span class="line">    <span class="comment">//删除指定key的缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">evict</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">    <span class="comment">//清空缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Cache有两个实现类ConcurrentMapCache和NoOpCache</p><p>（1）ConcurrentMapCache<br>Cache接口的默认实现<br>（2）NoOpCache<br>测试用</p><ol start="2"><li>CacheManager<br>CacheManager是一个用于管理Cache对象的集合。SpringCache提供了四种CacheManager的实现。<br><img src="/.tech//cacheManager.jpg" alt="CacheManager继承图"><br>(1)SimpleCacheManager<br>简单的CacheManager实现。主要用于测试<br>(2)NoOpCacheManager<br>测试用的CacherManager<br>(3)CompositeCacheManager<br>组合CacheManager, 可以集成多种CacheManager实例，支持多种缓存容器<br>(4)ConcurentMapCacheManager<br>SpringCache默认的CacheManager实现。使用ConcurrentMap作为缓存技术。</li></ol><p>这里就SpringCache提供了默认的缓存容器实现方案(ConcurentMapCacheManager)做一个源码分析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentMapCacheManager</span> <span class="keyword">implements</span> <span class="title">CacheManager</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认创建大小为16的ConcurrentMap来存储Cache对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Cache&gt; cacheMap = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//是否可以动态创建缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> dynamic = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//是否允许存null值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> allowNullValues = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> storeByValue = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> SerializationDelegate serialization;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentMapCacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentMapCacheManager</span><span class="params">(String... cacheNames)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setCacheNames(Arrays.asList(cacheNames));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化Cache,初始化过后，dynamic设置为false,不会再动态创建Cache.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCacheNames</span><span class="params">(@Nullable Collection&lt;String&gt; cacheNames)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var2 = cacheNames.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                String name = (String)var2.next();</span><br><span class="line">                <span class="keyword">this</span>.cacheMap.put(name, <span class="keyword">this</span>.createConcurrentMapCache(name));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.dynamic = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.dynamic = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowNullValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.allowNullValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据name获取Cache实例，如果Cache实例不存在，则动态创建一个缓存Cache实例。</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cache <span class="title">getCache</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Cache cache = (Cache)<span class="keyword">this</span>.cacheMap.get(name);</span><br><span class="line">        <span class="comment">//如果初始化过Cache,则getCache的时候不会动态创建Cache.</span></span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.dynamic) &#123;</span><br><span class="line">            ConcurrentMap var3 = <span class="keyword">this</span>.cacheMap;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.cacheMap) &#123;</span><br><span class="line">                cache = (Cache)<span class="keyword">this</span>.cacheMap.get(name);</span><br><span class="line">                <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cache = <span class="keyword">this</span>.createConcurrentMapCache(name);</span><br><span class="line">                    <span class="keyword">this</span>.cacheMap.put(name, cache);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建ConcurrentMapCache对象</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Cache <span class="title">createConcurrentMapCache</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        SerializationDelegate actualSerialization = <span class="keyword">this</span>.isStoreByValue() ? <span class="keyword">this</span>.serialization : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentMapCache(name, <span class="keyword">new</span> ConcurrentHashMap(<span class="number">256</span>), <span class="keyword">this</span>.isAllowNullValues(), actualSerialization);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Cache接口提供了缓存操作的基础操作(增、删、改、查),CacheManager提供了集中管理Cache对象的功能。两个接口一起提供了缓存操作的基本功能。同时这两个接口也是SpringCache对外提供的扩展点。可以根据需要去扩展想要的缓存对象(Cache)和缓存管理器(CacheManager),假如想用Redis作为缓存容器，则可以自定义RedisCache和RedisCacheManager。</p><h3 id="SpringCache核心注解"><a href="#SpringCache核心注解" class="headerlink" title="SpringCache核心注解"></a>SpringCache核心注解</h3><p>SpringCache提供了几个缓存操作的核心注解</p><ol><li>@Cacheable<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可作用于类和方法</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Cacheable &#123;</span><br><span class="line">    <span class="comment">//cache的名称</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"cacheNames"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//cache的名称</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] cacheNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//缓存值的key,使用SPEL手动指定缓存键的组合方式，默认情况是使用所有参数来组合缓存键</span></span><br><span class="line">    <span class="comment">// #root.method：用于获取当前方法的Method实例</span></span><br><span class="line">    <span class="comment">// #root.target：用于获取当前方法的target实例</span></span><br><span class="line">    <span class="comment">// #root.caches：用于获取当前方法关联的缓存</span></span><br><span class="line">    <span class="comment">// #root.methodName：用于获取当前方法的名称</span></span><br><span class="line">    <span class="comment">// #root.targetClass：用于获取目标类类型</span></span><br><span class="line">    <span class="comment">// #root.args[1]：获取当前方法的第二个参数，等同于：#p1和#a1和#argumentName</span></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//缓存键生成器,功能与key()具有排他性。keyGenerator是一个函数接口，可以通过自定义逻辑来实现key的生成策略</span></span><br><span class="line">    <span class="function">String <span class="title">keyGenerator</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//设置自定义的缓存管理器，与缓存解析器具有排他性</span></span><br><span class="line">    <span class="function">String <span class="title">cacheManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//设置自定义的缓存解析器</span></span><br><span class="line">    <span class="function">String <span class="title">cacheResolver</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//执行缓存的条件，条件不满足就不会执行缓存操作</span></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//禁止缓存功能，设置的条件满足的话</span></span><br><span class="line">    <span class="function">String <span class="title">unless</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//设置是否对多个针对同一key执行缓存加载的操作的线程进行同步</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sync</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>作用：</p><ul><li>直接从缓存中拿数据，如果缓存未命中，则执行方法，将方法返回的结果存入缓存。</li><li>@Cacheable可以作用在类上，表示类中的所有方法都使用了@Cacheable。</li></ul><ol start="2"><li>@CachePut<br>@CachePut参数含义与@Cacheable一样<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CachePut &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"cacheNames"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] cacheNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">keyGenerator</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">cacheManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">cacheResolver</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">unless</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>作用：<br>作用与@Cacheable保持一致</p><ol start="3"><li>@CacheEvict<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheEvict &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"cacheNames"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] cacheNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">keyGenerator</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">cacheManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">cacheResolver</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//指定当前缓存名称下的所有缓存是否全部删除。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allEntries</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="comment">//指定删除缓存的操作在方法调用前还是调用后执行，默认False,先用调用方法，后执行缓存删除。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">beforeInvocation</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>作用</p><ul><li>从缓存中删除数据</li><li>allEntries来指定是否删除CacheName中的所有缓存数据</li><li>beforeInvocation表示缓存操作的执行顺序</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring Cache提供了基础且核心的接口和注解，使我们能够更加便捷的操作缓存<br>但是我们不禁有个疑问?这些缓存接口和注解是如何作用到我们的方法上的。我们是如何获取到注解信息并通过这些信息指导缓存操作的？下一篇就聊一聊缓存注解的解析和应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Spring提供了一种基于注解（annotation）的缓存技术，他并不是具体的缓存使用方案，而是一个对缓存使用的抽象方
      
    
    </summary>
    
      <category term="Spring" scheme="https://shawnyou.tech/categories/Spring/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源码|初识AutoProxyRegistrar</title>
    <link href="https://shawnyou.tech/2019/06/24/Spring-boot/%E5%88%9D%E8%AF%86AutoProxyRegistrar/"/>
    <id>https://shawnyou.tech/2019/06/24/Spring-boot/初识AutoProxyRegistrar/</id>
    <published>2019-06-24T14:51:50.000Z</published>
    <updated>2019-06-27T13:37:13.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AutoProxyRegistrar源码分析"><a href="#AutoProxyRegistrar源码分析" class="headerlink" title="AutoProxyRegistrar源码分析"></a>AutoProxyRegistrar源码分析</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;AutoProxyRegistrar源码分析&quot;&gt;&lt;a href=&quot;#AutoProxyRegistrar源码分析&quot; class=&quot;headerlink&quot; title=&quot;AutoProxyRegistrar源码分析&quot;&gt;&lt;/a&gt;AutoProxyRegistrar源码
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://shawnyou.tech/categories/SpringBoot/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源碼|@EnbaleXxx的实现原理</title>
    <link href="https://shawnyou.tech/2019/06/16/Spring-boot/@Enable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://shawnyou.tech/2019/06/16/Spring-boot/@Enable源码解析/</id>
    <published>2019-06-16T06:55:37.000Z</published>
    <updated>2019-06-26T13:35:22.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-EnableXxx实现原理解析"><a href="#1-EnableXxx实现原理解析" class="headerlink" title="1.EnableXxx实现原理解析"></a>1.EnableXxx实现原理解析</h3><blockquote><p>Spring Boot的核心作用在于他具有强大的自动配置的功能，在Spring框架的基础上利用约定大于配置减少了Spring开发中配置复杂等问题。Spring Boot提供了很多类似于@EnableXXX的注解，这些注解有什么用呢？解决了Spring Boot什么问题？ 接下来我们通过源码来学习一下关@EnableXXX相关注解。</p></blockquote><h4 id="1-1常见的-Enable注解"><a href="#1-1常见的-Enable注解" class="headerlink" title="1.1常见的@Enable注解"></a>1.1常见的@Enable注解</h4><ul><li>@EnableCaching</li><li>@EnableAsync</li><li>@EnbaleJpaRepositories</li><li>@EnableAutoConfiguration</li></ul><h4 id="1-2-EnableXxxx源码入口"><a href="#1-2-EnableXxxx源码入口" class="headerlink" title="1.2 @EnableXxxx源码入口"></a>1.2 @EnableXxxx源码入口</h4><p>本文主要以@EnableCaching作为核心来讲解一下SpringBoot关于@EnbaleXXX注解实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;CachingConfigurationSelector.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCaching &#123;</span><br><span class="line">    <span class="comment">//动态代理的两种实现方式（JDK动态代理或者CGLIB）,默认使用JDK动态代理</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理实现的两种方式（AspectJ或者动态代理），默认使用动态代理</span></span><br><span class="line">    <span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 2147483647</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableCaching是Spring Cache的入口，开启了注解式的缓存支持。</p><ol><li>设置动态代理的实现方式，默认采用JDK动态代理。</li><li>默认采用动态代理的方式实现代理</li><li>通过@Import注解导入了一个CachingConfigurationSelector配置类。</li></ol><p>关于@Import，可以参照博客<a href="http://shawnyou.tech/2019/06/15/Spring-boot/@Import%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">@Import注解</a><br>接下来根据@Import导入的CachingConfigurationSelector类进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableCaching</span>&gt; </span>&#123;</span><br><span class="line">    、、、、只保留关键代码</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据@EnableCaching注解的信息确定需要导入容器的Bean的类名</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">null</span>.$SwitchMap$org$springframework$context$annotation$AdviceMode[adviceMode.ordinal()]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getProxyImports();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getAspectJImports();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取动态代理的配置Bean.</span></span><br><span class="line">    <span class="keyword">private</span> String[] getProxyImports() &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList(<span class="number">3</span>);</span><br><span class="line">        result.add(AutoProxyRegistrar.class.getName());</span><br><span class="line">        result.add(ProxyCachingConfiguration.class.getName());</span><br><span class="line">        <span class="keyword">if</span>(jsr107Present &amp;&amp; jcacheImplPresent) &#123;</span><br><span class="line">            result.add(<span class="string">"org.springframework.cache.jcache.config.ProxyJCacheConfiguration"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于AspectJ代理模式，不作分析</span></span><br><span class="line">    <span class="keyword">private</span> String[] getAspectJImports() &#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList(<span class="number">2</span>);</span><br><span class="line">        result.add(<span class="string">"org.springframework.cache.aspectj.AspectJCachingConfiguration"</span>);</span><br><span class="line">        <span class="keyword">if</span>(jsr107Present &amp;&amp; jcacheImplPresent) &#123;</span><br><span class="line">            result.add(<span class="string">"org.springframework.cache.aspectj.AspectJJCacheConfiguration"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">    &#125;</span><br><span class="line">    、、、只保留关键代码、</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，CachingConfigurationSelector的父类AdviceModeImportSelector实现了ImportSelector接口，导入两个关键的动态代理配置类。</p><ol><li>AutoProxyRegistrar<br>AutoProxyRegistrar就是一个自动代理注册器，他负责给容器注册了一个InfrastructureAdvisorAutoProxyCreator，他就是一个后置增强处理器，负责在Bean初始化后通过动态代理生成代理对象，关于AutoProxyRegistrar的解析，这里有专门的博客对AutoProxyRegistrar创建代理的过程进行阐述。</li><li>ProxyCachingConfiguration <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCachingConfiguration</span> <span class="keyword">extends</span> <span class="title">AbstractCachingConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyCachingConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(</span><br><span class="line">        name = &#123;<span class="string">"org.springframework.cache.config.internalCacheAdvisor"</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanFactoryCacheOperationSourceAdvisor <span class="title">cacheAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BeanFactoryCacheOperationSourceAdvisor advisor = <span class="keyword">new</span> BeanFactoryCacheOperationSourceAdvisor();</span><br><span class="line">        advisor.setCacheOperationSource(<span class="keyword">this</span>.cacheOperationSource());</span><br><span class="line">        advisor.setAdvice(<span class="keyword">this</span>.cacheInterceptor());</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.enableCaching != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisor.setOrder(((Integer)<span class="keyword">this</span>.enableCaching.getNumber(<span class="string">"order"</span>)).intValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheOperationSource <span class="title">cacheOperationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnnotationCacheOperationSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Role</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheInterceptor <span class="title">cacheInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CacheInterceptor interceptor = <span class="keyword">new</span> CacheInterceptor();</span><br><span class="line">        interceptor.configure(<span class="keyword">this</span>.errorHandler, <span class="keyword">this</span>.keyGenerator, <span class="keyword">this</span>.cacheResolver, <span class="keyword">this</span>.cacheManager);</span><br><span class="line">        interceptor.setCacheOperationSource(<span class="keyword">this</span>.cacheOperationSource());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>ProxyCachingConfiguration向容器中注入了三个Bean，一起组装了一个BeanFactoryCacheOperationSourceAdvisor，它是一个PointAdvisor(切面),整合了PointCut(切点)和Advice(通知)两个模块，确定了在什么方法上(PointCut)执行什么样的缓存操作(Advice)。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>@Enable通过@Import注解能够将指定的配置文件或者Bean装配到Spring容器中，完成自动装配的功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-EnableXxx实现原理解析&quot;&gt;&lt;a href=&quot;#1-EnableXxx实现原理解析&quot; class=&quot;headerlink&quot; title=&quot;1.EnableXxx实现原理解析&quot;&gt;&lt;/a&gt;1.EnableXxx实现原理解析&lt;/h3&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://shawnyou.tech/categories/SpringBoot/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot源碼|深入理解@Import注解</title>
    <link href="https://shawnyou.tech/2019/06/15/Spring-boot/@Import%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://shawnyou.tech/2019/06/15/Spring-boot/@Import源码解析/</id>
    <published>2019-06-15T06:55:37.000Z</published>
    <updated>2019-06-25T15:04:47.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深入理解-Import注解"><a href="#深入理解-Import注解" class="headerlink" title="深入理解@Import注解"></a>深入理解@Import注解</h3><blockquote><p>查看SpringBoot相关组件的源码，会发现有很多地方运用了@Import注解，这个注解有什么用呢，工作原理是什么，我们可以利用这个@Import来做什么？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span><br><span class="line">    Class&lt;?&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Import的使用方式"><a href="#Import的使用方式" class="headerlink" title="@Import的使用方式"></a>@Import的使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        ServiceImpl service = applicationContext.getBean(ServiceImpl.class);</span><br><span class="line">        Assert.notNull(service,<span class="string">"service has inject successful"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><p>通过@Import将Class加载到AppConfig类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(value = ServiceImpl.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata var1, BeanDefinitionRegistry var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义BeanDefinitionRegistrar的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceImpl.class);</span><br><span class="line">        <span class="comment">//BeanDefinitionRegistry将生成的BeanDefinition注册到容器中去</span></span><br><span class="line">        beanDefinitionRegistry.registerBeanDefinition(<span class="string">"service"</span>,builder.getBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(value = ServiceBeanDefinitionRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过ImportBeanDefinitionRegistrar实现的Import可以针对Bean注册容器的过程进行自定义"><a href="#通过ImportBeanDefinitionRegistrar实现的Import可以针对Bean注册容器的过程进行自定义" class="headerlink" title="通过ImportBeanDefinitionRegistrar实现的Import可以针对Bean注册容器的过程进行自定义"></a>通过ImportBeanDefinitionRegistrar实现的Import可以针对Bean注册容器的过程进行自定义</h4><h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h3><p>告诉容器需要注入哪些类的类名就可以实现Bean的注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">//annotationMetadata是关于注解的元数据信息,可以根据需要获取注解的信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;ServiceImpl.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(value = ServiceImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总结<br>获取注解元数据信息，返回一组需要注入类的类名，有框架来生成对应的实体类从而注入到容器中去。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;深入理解-Import注解&quot;&gt;&lt;a href=&quot;#深入理解-Import注解&quot; class=&quot;headerlink&quot; title=&quot;深入理解@Import注解&quot;&gt;&lt;/a&gt;深入理解@Import注解&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;查看SpringBoot相
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://shawnyou.tech/categories/SpringBoot/"/>
    
    
      <category term="源码" scheme="https://shawnyou.tech/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记|如何更好的创建和销毁对象</title>
    <link href="https://shawnyou.tech/2019/04/14/effectiveJava/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <id>https://shawnyou.tech/2019/04/14/effectiveJava/创建对象/</id>
    <published>2019-04-14T06:55:37.000Z</published>
    <updated>2019-04-17T14:46:10.930Z</updated>
    
    <content type="html"><![CDATA[<h3 id="静态工厂方法代替构造器"><a href="#静态工厂方法代替构造器" class="headerlink" title="静态工厂方法代替构造器"></a>静态工厂方法代替构造器</h3><h4 id="静态工厂方法的几大优势"><a href="#静态工厂方法的几大优势" class="headerlink" title="静态工厂方法的几大优势"></a>静态工厂方法的几大优势</h4><ol><li><p>静态工厂方法有名称，易于区分。</p></li><li><p>避免不必要的重复对象的创建工作</p></li></ol><p>不必每次调用都创建一个新的对象，可以将构建好的实例缓存起来重复使用</p><ol start="3"><li>可以返回原返回类型的任何子类型</li></ol><p>返回对象有了更大的灵活性</p><ol start="4"><li><p>返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值</p></li><li><p>方法返回对象所属的类，在编写包含静态工厂方法的类时可以不存在</p></li></ol><h4 id="静态工厂方法的几个缺点"><a href="#静态工厂方法的几个缺点" class="headerlink" title="静态工厂方法的几个缺点"></a>静态工厂方法的几个缺点</h4><ul><li>类如果不含公有的或者受保护的构造器，就不能被子类化</li><li>不易发现</li></ul><h3 id="遇到多个参数时要使用构建器"><a href="#遇到多个参数时要使用构建器" class="headerlink" title="遇到多个参数时要使用构建器"></a>遇到多个参数时要使用构建器</h3><h4 id="当构造器扩展到大量的可选参数时，静态工厂和构造器就显得相当局限了。目前用的比较多的是重叠构造器"><a href="#当构造器扩展到大量的可选参数时，静态工厂和构造器就显得相当局限了。目前用的比较多的是重叠构造器" class="headerlink" title="当构造器扩展到大量的可选参数时，静态工厂和构造器就显得相当局限了。目前用的比较多的是重叠构造器"></a>当构造器扩展到大量的可选参数时，静态工厂和构造器就显得相当局限了。目前用的比较多的是重叠构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts(<span class="number">240</span>,<span class="number">8</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">35</span>,<span class="number">27</span>);</span><br></pre></td></tr></table></figure><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>可读性比较差</li><li>容易出错,如参数位置弄错位置</li></ul><h4 id="使用setter方案"><a href="#使用setter方案" class="headerlink" title="使用setter方案"></a>使用setter方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servingSize = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servings = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServingSize</span><span class="params">(<span class="keyword">int</span> servingSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServings</span><span class="params">(<span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servings = servings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCalories</span><span class="params">(<span class="keyword">int</span> calories)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calories = calories;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFat</span><span class="params">(<span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fat = fat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSodium</span><span class="params">(<span class="keyword">int</span> sodium)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sodium = sodium;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCarbohydrate</span><span class="params">(<span class="keyword">int</span> carbohydrate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carbohydrate = carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NutritionFacts nutritionFacts = <span class="keyword">new</span> NutritionFacts();</span><br><span class="line">nutritionFacts.setServingSize(<span class="number">240</span>);</span><br><span class="line">nutritionFacts.setServings(<span class="number">100</span>);</span><br><span class="line">nutritionFacts.setSodium(<span class="number">35</span>);</span><br><span class="line">nutritionFacts.setCarbohydrate(<span class="number">27</span>);</span><br><span class="line">nutritionFacts.setCalories(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><ul><li>可读性增强</li><li>一致性的问题(不安全)</li></ul><h4 id="构建器"><a href="#构建器" class="headerlink" title="构建器"></a>构建器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servingSize = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servings = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servingSize = builder.servingSize;</span><br><span class="line">        <span class="keyword">this</span>.servings = builder.servings;</span><br><span class="line">        <span class="keyword">this</span>.calories = builder.calories;</span><br><span class="line">        <span class="keyword">this</span>.fat = builder.fat;</span><br><span class="line">        <span class="keyword">this</span>.sodium = builder.sodium;</span><br><span class="line">        <span class="keyword">this</span>.carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.calories = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.fat = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sodium = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.carbohydrate = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NutritionFacts nutritionFacts = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>,<span class="number">8</span>).calories(<span class="number">100</span>)</span><br><span class="line">                .sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直观、易于阅读(优点)</li><li>在注重性能的情况下，创建构建起是个问题(缺点)</li><li>最好一开始就用构建器(建议)</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式是个不错的选择</p><h3 id="私有构造器或者枚举类型强化Singleton属性"><a href="#私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="私有构造器或者枚举类型强化Singleton属性"></a>私有构造器或者枚举类型强化Singleton属性</h3><p>Singleton:仅仅被实例化一次的类</p><h4 id="Singleton的两种实现"><a href="#Singleton的两种实现" class="headerlink" title="Singleton的两种实现"></a>Singleton的两种实现</h4><h5 id="单例模式的实现（一）"><a href="#单例模式的实现（一）" class="headerlink" title="单例模式的实现（一）"></a>单例模式的实现（一）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis instance = <span class="keyword">new</span> Elvis();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>私有构造器只调用一次，用来实例化公有的静态final域(instance)</li><li>没有public或者protect的构造器，保证了instance的唯一性</li><li>但是可以通过反射的方式调用私有构造器(可以修改构造器在创建第二次实例时抛出异常)</li></ul><h5 id="单例模式的实现（二）"><a href="#单例模式的实现（二）" class="headerlink" title="单例模式的实现（二）"></a>单例模式的实现（二）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis instance = <span class="keyword">new</span> Elvis();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>添加了一个静态工厂方法，静态工厂方法的调用每次都返回同一个对象引用</li><li>公有的静态域是final的，该域总是包含相同的对象引用。公有域方法在性能上不会有任何优势，现在JVM实现能够将静态工厂方法的调用内联化。(内联：函数被调用的地方直接展开，编译器在调用时不会像一般函数那样，参数压栈，返回时参数出栈以及释放资源，直接提高程序的执行速度)</li></ul><h6 id="Singleton可序列化问题"><a href="#Singleton可序列化问题" class="headerlink" title="Singleton可序列化问题"></a>Singleton可序列化问题</h6><p>Singleton仅仅在声明中加上implement Serializable是不够的，必须所有的实例都是瞬时的，并提供一个readResolve方法，否则每次反序列化都会创建一个新的实例</p><h4 id="单例模式的实现（三）—-通过枚举类型实现"><a href="#单例模式的实现（三）—-通过枚举类型实现" class="headerlink" title="单例模式的实现（三）— 通过枚举类型实现"></a>单例模式的实现（三）— 通过枚举类型实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Elvis &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    public void doSomething()&#123;</span><br><span class="line">        System.out.println(&quot;do something&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点</p><ul><li>简洁</li><li>无偿提供了序列化机制，防止多次实例化</li><li>单元素的枚举类型是实现Singleton的最佳方法</li></ul><h3 id="使用依赖注入来引用资源"><a href="#使用依赖注入来引用资源" class="headerlink" title="使用依赖注入来引用资源"></a>使用依赖注入来引用资源</h3><p>静态工具类引用底层资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Dictionary DICTIONARY = <span class="keyword">new</span> Dictionary();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Singleton引用底层资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary = <span class="keyword">new</span> Dictionary();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上引入资源的两种形式都不太好。因为没法支持多种词典。所以静态资源类和Singleton类不适合作需要引用底层资源的类。</p><p>所以使用依赖注入来引入底层资源，当创建一个新的实例时，将该资源传到构造器中去。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dictionary dictionary;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Dictionary dictionary)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = dictionary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="依赖注入的变体形式"><a href="#依赖注入的变体形式" class="headerlink" title="依赖注入的变体形式"></a>依赖注入的变体形式</h4><p>将资源工厂传给构造器</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>不要使用Singleton和静态工具类来实现依赖一个或者多个底层资源的类</li><li>尽量将资源或者创建资源的工厂传给构造器，（或者工厂方法、builder）,这样会增加类的灵活性、重用性和可测试性</li></ul><h3 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><p>最好重用对象而不是每次需要的时候创建一个相同功能的新对象，这样可以提高性能，缩短响应时间。</p><h4 id="String创建的案例"><a href="#String创建的案例" class="headerlink" title="String创建的案例"></a>String创建的案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">String s = <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure><p>第一个语句： 每次执行都会创建新的String实例，这些创建的对象都是不必要的。如果用在一个频繁调用的方法中，就回创建成千上万不必要的String实例。</p><p>第二个语句： 对于所有在同一台虚拟机运行的代码，只要它们包含相同的字符串字面常量，该对象就会被重用。</p><ul><li>java会在方法区运行时常量池保存”test”,当下次调用String = “test”,java会直接返回这个对象的引用，而不会重新创建对象，由此节省了内存开销，可以放心在循环中使用</li><li>String s = new String(“test”)实际创建了两个对象，一个对象在堆中，一个保存在常量池</li></ul><h4 id="优先使用静态工厂方法而不是构造器来创建对象"><a href="#优先使用静态工厂方法而不是构造器来创建对象" class="headerlink" title="优先使用静态工厂方法而不是构造器来创建对象"></a>优先使用静态工厂方法而不是构造器来创建对象</h4><ul><li>构造器每次调用都会创建新对象，而静态工厂方法不会这样，静态工厂方法可以重用对象，也可以加缓存</li><li>如果反复需要一些创建成本比较高的对象，建议缓存下来重用。</li></ul><h4 id="不要创建多个适配器"><a href="#不要创建多个适配器" class="headerlink" title="不要创建多个适配器"></a>不要创建多个适配器</h4><p>如果对象是可以变化的，也可以实现重用</p><p>适配器：把功能委托给一个后备对象，从而为后备对象提供一个可以替代的接口，适配器除了后备对象，没有其他任何信息。</p><ul><li>Map接口的keyset()返回Map对象的Set视图，包含Map的所有键</li><li>每次调用都返回Map对象锁对应的Set实例，即便Map内容会有所变化，也能反映到Set实例中。</li></ul><p>所以没有必要创建多个Set实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ks = <span class="keyword">new</span> AbstractSet&lt;K&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;K&gt;() &#123;</span><br><span class="line">                        <span class="keyword">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> i.hasNext();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> i.next().getKey();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            i.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.size();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    AbstractMap.<span class="keyword">this</span>.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> AbstractMap.<span class="keyword">this</span>.containsKey(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="避免自动装箱造成重复对象的创建"><a href="#避免自动装箱造成重复对象的创建" class="headerlink" title="避免自动装箱造成重复对象的创建"></a>避免自动装箱造成重复对象的创建</h4><p>自动装箱会导致多余对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>;i&lt;=Integer.MAX_VALUE;i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>声明的变量是Long而不是long,所以每一次循环都会构造多余的Long实例， 所以要优先使用基本类型而不是装箱基本类型，当心无意识的自动装箱。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>通过维护对象池来避免创建对象也不是好事情，除非对象池中的对象是非常重要的对象。</li><li>维护对象池会把代码弄得很乱，同时增加内存占用，损害性能</li></ul><h3 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h3><p>虽然java帮助我们完成了大部分内存管理的工作，但是我们还不不能对内存管理置之不理。</p><ol><li>Stack引发的内存溢出的问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACOTY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACOTY];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span></span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"no element"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length == size)&#123;</span><br><span class="line">            elements = Arrays.copyOf(elements,<span class="number">2</span>*size+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>栈先增长，后收缩，对于弹出来的对象，栈依旧维护者这些对象的引用，所以这些对象不会被当做垃圾回收</li><li>所以一旦对象引用已经过期，只需清空这些引用就可以了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size ==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"no element"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line">        elements[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意点： 清空对象引用是一种例外，而不是一种规范行为，对于栈这种自己管理内存的情况，程序员就应该警惕内存泄露问题。</p><ol start="2"><li>缓存引起的内存泄露</li></ol><p>缓存容易被遗忘，一旦时间长了,日积月累的缓存容易出现内存溢出的情况。</p><ol start="3"><li>监听器和回调造成的内存溢出</li></ol><h3 id="避免使用终结方法"><a href="#避免使用终结方法" class="headerlink" title="避免使用终结方法"></a>避免使用终结方法</h3><h3 id="try-with-resource优先于try-finally"><a href="#try-with-resource优先于try-finally" class="headerlink" title="try-with-resource优先于try-finally"></a>try-with-resource优先于try-finally</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;静态工厂方法代替构造器&quot;&gt;&lt;a href=&quot;#静态工厂方法代替构造器&quot; class=&quot;headerlink&quot; title=&quot;静态工厂方法代替构造器&quot;&gt;&lt;/a&gt;静态工厂方法代替构造器&lt;/h3&gt;&lt;h4 id=&quot;静态工厂方法的几大优势&quot;&gt;&lt;a href=&quot;#静态工厂方法
      
    
    </summary>
    
      <category term="读书笔记(Effective Java)" scheme="https://shawnyou.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Effective-Java/"/>
    
    
      <category term="Notes" scheme="https://shawnyou.tech/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="https://shawnyou.tech/2019/04/14/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/04/14/适配器模式/</id>
    <published>2019-04-14T01:44:58.000Z</published>
    <updated>2019-11-10T05:13:01.343Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式"></a>什么是适配器模式</h3><blockquote><p>将一个接口变换成客户期待的另一个的接口，从而使原本因接口不匹配无法一起工作的两个类能够一起工作。<br>生活中不乏这样的案例，如电脑的电源适配器，它的作用主要是解决家用电和电脑之间的兼容问题</p></blockquote><p>通过适配器模式可以解决‘现有程序’和‘所需程序’之间的差异，让现有程序和所需程序能够完美的兼容。</p><h3 id="如何做一个将”交流100伏特电压”转换成“直流12伏特电压”的适配器"><a href="#如何做一个将”交流100伏特电压”转换成“直流12伏特电压”的适配器" class="headerlink" title="如何做一个将”交流100伏特电压”转换成“直流12伏特电压”的适配器"></a>如何做一个将”交流100伏特电压”转换成“直流12伏特电压”的适配器</h3><h3 id="适配器模式的两种实现"><a href="#适配器模式的两种实现" class="headerlink" title="适配器模式的两种实现"></a>适配器模式的两种实现</h3><ul><li>类适配器模式(继承）</li><li>对象适配器模式(委托)</li></ul><h4 id="继承适配器模式"><a href="#继承适配器模式" class="headerlink" title="继承适配器模式"></a>继承适配器模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span></span>&#123;</span><br><span class="line">    <span class="comment">//现有的实际情况</span></span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithParen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithAster</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">""</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">    <span class="comment">//需求接口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">extends</span> <span class="title">Banner</span> <span class="keyword">implements</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">    <span class="comment">//适配器类：在实现了现有的需求接口的方法中对原有的功能情况进行包装，以达到适配以前功能的目的。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        showWithParen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>&#123;</span><br><span class="line">        showWithAster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Print p = <span class="keyword">new</span> PringBanner(<span class="string">"hello"</span>);</span><br><span class="line">p.pritWeak();</span><br><span class="line">p.printStrong();</span><br></pre></td></tr></table></figure><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>面向接口编程，客户端代码只需要通过Print接口进行调用，隐藏了方法实现。(连接笔记本电脑的12伏特电压就有可能是由100伏特交流电压通过适配器转换而成的)</li></ul><h4 id="委托适配器模式"><a href="#委托适配器模式" class="headerlink" title="委托适配器模式"></a>委托适配器模式</h4><p>通过委托来实现适配器</p><ul><li>适配器(PrintBanner)通过调用现有需求的方法(Print)来间接调用以前的的功能(Banner)</li><li>Banner通过委托的形式传入到适配器(PrintBanner)中,现有功能(Print)作为抽象类被适配器继承。</li></ul><blockquote><p>Talk is cheap, show me the code</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">publc <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">    <span class="comment">//抽象类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">extends</span> <span class="title">Print</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过委托的形式将原有功能注入进来，由此虽然调用的是新的功能方法，但实际调用的还是以前的老功能，由此实现了新、老功能之间的适配兼容。</span></span><br><span class="line">    <span class="keyword">private</span> Banner banner;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        banner.shouwWithParen();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>&#123;</span><br><span class="line">        banner.showWithAster();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是适配器模式&quot;&gt;&lt;a href=&quot;#什么是适配器模式&quot; class=&quot;headerlink&quot; title=&quot;什么是适配器模式&quot;&gt;&lt;/a&gt;什么是适配器模式&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;将一个接口变换成客户期待的另一个的接口，从而使原本因接口不匹配无法
      
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://shawnyou.tech/2019/04/13/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/04/13/策略模式/</id>
    <published>2019-04-13T12:44:43.000Z</published>
    <updated>2019-04-14T11:53:15.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><h4 id="一个主题切换案例"><a href="#一个主题切换案例" class="headerlink" title="一个主题切换案例"></a>一个主题切换案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Theme</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyTheme</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTheme</span> <span class="keyword">implements</span> <span class="title">Theme</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"设置默认主题"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DarkTheme</span> <span class="keyword">implements</span> <span class="title">Theme</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"设置暗黑风格主题"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorfulTheme</span> <span class="keyword">implements</span> <span class="title">Theme</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"设置彩色风格主题"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThemeManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Theme theme;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThemeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.theme = <span class="keyword">new</span> DefaultTheme();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTheme</span><span class="params">(Theme theme)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.theme = theme;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyTheme</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.theme.applyTheme();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThemeManager themeManager = <span class="keyword">new</span> ThemeManager();</span><br><span class="line">        <span class="comment">//设置黑暗风格主题</span></span><br><span class="line">        themeManager.setTheme(<span class="keyword">new</span> DarkTheme());</span><br><span class="line">        themeManager.applyTheme();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主题模式更换的案例中，不同的主题风格就是一个个策略，我们可以根须需要选择不同的策略。</p><h3 id="如何理解策略模式"><a href="#如何理解策略模式" class="headerlink" title="如何理解策略模式"></a>如何理解策略模式</h3><blockquote><p>定义椅子算法，将每个算法都以类的方式凤凰钻起来，并且使他们可以互相交换。</p></blockquote><p>类图（TODO）</p><p>策略模式模型抽象</p><ul><li>Context封装角色</li></ul><p>主题更换案例中的ThemeManager就是一个封装角色，也叫上下文角色，拼比高层对策略的直接访问。</p><ul><li>Strategy抽象策略角色</li></ul><p>定义每个策略必须具有的方法和属性</p><ul><li>ConcreteStrategy具体策略角色</li></ul><p>抽象策略的实现，具体的算法</p><h3 id="策略模式的优点"><a href="#策略模式的优点" class="headerlink" title="策略模式的优点"></a>策略模式的优点</h3><ul><li>算法可以自由切换</li><li>避免了多重条件的判断</li><li>良好的扩展性(符合开闭原则)</li></ul><h3 id="策略模式的缺点"><a href="#策略模式的缺点" class="headerlink" title="策略模式的缺点"></a>策略模式的缺点</h3><ul><li>策略类会逐渐增多(超过四个考虑使用混合模式)</li><li>策略类必须向外暴露(违反迪米特法则) — 上层模块必须知道哪些策略，才能使用哪些策略，可用工厂方法模式修正</li></ul><h3 id="策略模式的具体应用"><a href="#策略模式的具体应用" class="headerlink" title="策略模式的具体应用"></a>策略模式的具体应用</h3><ul><li>Shiro权限控制框架有三种验证策略</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实际案例&quot;&gt;&lt;a href=&quot;#实际案例&quot; class=&quot;headerlink&quot; title=&quot;实际案例&quot;&gt;&lt;/a&gt;实际案例&lt;/h3&gt;&lt;h4 id=&quot;一个主题切换案例&quot;&gt;&lt;a href=&quot;#一个主题切换案例&quot; class=&quot;headerlink&quot; title=&quot;一
      
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>装饰器模式</title>
    <link href="https://shawnyou.tech/2019/04/13/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/04/13/装饰器模式/</id>
    <published>2019-04-13T06:55:37.000Z</published>
    <updated>2019-04-14T11:54:07.979Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个故事"><a href="#一个故事" class="headerlink" title="一个故事"></a>一个故事</h3><p>小明今年买了一个毛坯房，计划六月份装修作为婚房使用。小明选择了自定义的装修方案。线槽、刷漆、家具定制、门窗定制都是由不同的厂家来定制安装。</p><h3 id="通过装饰器模式来模拟装修"><a href="#通过装饰器模式来模拟装修" class="headerlink" title="通过装饰器模式来模拟装修"></a>通过装饰器模式来模拟装修</h3><ul><li>毛坯房是一个被装饰的对象</li><li>线槽、刷漆、家具定制、门窗定制等就是装饰对象，他们负责对毛坯房进行装饰。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decorate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoughHouse</span> <span class="keyword">implements</span> <span class="title">House</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"毛坯房要开始装修了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDecorate</span> <span class="keyword">implements</span> <span class="title">House</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> House house;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDecorate</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.house = house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷漆的装饰类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrushingHouseDecorate</span> <span class="keyword">extends</span> <span class="title">HouseDecorate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrushingHouseDecorate</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(house);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.decorate();</span><br><span class="line">        System.out.println(<span class="string">"房屋装修------刷漆"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>家具定制的装饰类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedFurnitureHouseDecorate</span> <span class="keyword">extends</span> <span class="title">HouseDecorate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomizedFurnitureHouseDecorate</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(house);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.decorate();</span><br><span class="line">        System.out.println(<span class="string">"房屋装修------定制家具"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>门窗定制的装饰类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoorWindowHouseDecorate</span> <span class="keyword">extends</span> <span class="title">HouseDecorate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoorWindowHouseDecorate</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(house);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.decorate();</span><br><span class="line">        System.out.println(<span class="string">"房屋装修------门窗定制"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线槽安装的装饰类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrunkingHouseDecorate</span> <span class="keyword">extends</span> <span class="title">HouseDecorate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrunkingHouseDecorate</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(house);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.decorate();</span><br><span class="line">        System.out.println(<span class="string">"房屋装修------安装线槽"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        House house = <span class="keyword">new</span> RoughHouse();</span><br><span class="line"></span><br><span class="line">        house = <span class="keyword">new</span> BrushingHouseDecorate(house);</span><br><span class="line">        house = <span class="keyword">new</span> TrunkingHouseDecorate(house);</span><br><span class="line">        house = <span class="keyword">new</span> CustomizedFurnitureHouseDecorate(house);</span><br><span class="line">        house = <span class="keyword">new</span> DoorWindowHouseDecorate(house);</span><br><span class="line"></span><br><span class="line">        house.decorate();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Result<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">毛坯房要开始装修了</span><br><span class="line">房屋装修------刷漆</span><br><span class="line">房屋装修------安装线槽</span><br><span class="line">房屋装修------定制家具</span><br><span class="line">房屋装修------门窗定制</span><br></pre></td></tr></table></figure></p><h3 id="如何理解装饰器模式"><a href="#如何理解装饰器模式" class="headerlink" title="如何理解装饰器模式"></a>如何理解装饰器模式</h3><blockquote><p>动态的给一个对象添加额外的职责。提供了比集成更有弹性的替代方案</p></blockquote><ul><li>装饰器<br>刷漆装修、安装线槽、定制家具、门窗定制都是属于装饰器。当我们居住一段时间后，想把厕所改造一下，我们只需要再构造一个装饰器，对房屋就是包装装饰就完成了工作，而不需要做过多的改变。</li><li>被装饰对象<br>毛坯房就是属于被装饰对象</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>装饰器与被装饰对象实现同一个接口</li><li>装饰器持有被装饰对象的引用</li><li>可以随意添加装饰器</li></ul><p>看到装饰器模式的前两个特点，我们是不是有种似曾相识的感觉，这不是静态代理的特点吗？装饰器就好比代理类，他持有被代理对象（被装饰对象）的引用，去做被代理对象能做但是不想做的事情。</p><h3 id="装饰器模式与静态代理"><a href="#装饰器模式与静态代理" class="headerlink" title="装饰器模式与静态代理"></a>装饰器模式与静态代理</h3><ol><li>静态代理<br>想做但不能做，需要找一个能干的人帮我做</li><li>装饰器模式<br>我想做，但不能做，需要找各具特色的人来帮我做</li></ol><h4 id="用一个例子来说明"><a href="#用一个例子来说明" class="headerlink" title="用一个例子来说明"></a>用一个例子来说明</h4><p>这是一个代理类的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.before();</span><br><span class="line">        subject.request();</span><br><span class="line">        <span class="keyword">this</span>.after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置处理。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置处理。。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们想给主题添加一点操作日志，最简单的方法就是添加一个log();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"添加日志"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于需求，我们是不可控的，未来需求不断的增长，代理类会越来越大，难以维护，而且也不符合开闭原则。</p><h4 id="如何应用"><a href="#如何应用" class="headerlink" title="如何应用"></a>如何应用</h4><ul><li>装饰器模式与静态代理模式都是包装模式，为其添加特定的功能</li><li>功能单一，可以选择代理模式</li><li>功能较多其需要动态扩张海燕，可以选择装饰器模式</li></ul><h3 id="装饰器模式应用场景"><a href="#装饰器模式应用场景" class="headerlink" title="装饰器模式应用场景"></a>装饰器模式应用场景</h3><ul><li>Java IO流<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">while</span> ((str = in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br></pre></td></tr></table></figure></li></ul><p>查看DataInputStream源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> <span class="keyword">implements</span> <span class="title">DataInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a DataInputStream that uses the specified</span></span><br><span class="line"><span class="comment">     * underlying InputStream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  in   the specified input stream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The input stream to be filtered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &lt;code&gt;FilterInputStream&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * by assigning the  argument &lt;code&gt;in&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * to the field &lt;code&gt;this.in&lt;/code&gt; so as</span></span><br><span class="line"><span class="comment">     * to remember it for later use.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   in   the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if</span></span><br><span class="line"><span class="comment">     *          this instance is to be created without an underlying stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源代码可以看出</p><ul><li>装饰器<br>FilterInputStream及其子类（DataInputstream）</li><li>被装饰对象<br>InputStream</li></ul><p>由此可以设计出很多具有不同的特性的IO流。</p><h3 id="装饰器模式的优点"><a href="#装饰器模式的优点" class="headerlink" title="装饰器模式的优点"></a>装饰器模式的优点</h3><ul><li>扩展方式了灵活</li><li>每个装饰器互相独立不受影响</li><li>装饰模式是继承的替代方案，能够解决类膨胀的问题，继承是静态增加功能，装饰模式是动态增加功能。不管装饰多少层，返回的还是父类，实现的是is-a的关系。如果需要去掉某个功能，装饰模式去掉封装就可以了，但是继承就必须修改代码。</li><li></li><li>动态扩展装饰器类</li></ul><h3 id="装饰器模式的缺点"><a href="#装饰器模式的缺点" class="headerlink" title="装饰器模式的缺点"></a>装饰器模式的缺点</h3><ul><li>多层装饰比较复杂(类似剥洋葱)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一个故事&quot;&gt;&lt;a href=&quot;#一个故事&quot; class=&quot;headerlink&quot; title=&quot;一个故事&quot;&gt;&lt;/a&gt;一个故事&lt;/h3&gt;&lt;p&gt;小明今年买了一个毛坯房，计划六月份装修作为婚房使用。小明选择了自定义的装修方案。线槽、刷漆、家具定制、门窗定制都是由
      
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="https://shawnyou.tech/2019/04/13/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shawnyou.tech/2019/04/13/责任链模式/</id>
    <published>2019-04-13T04:36:10.000Z</published>
    <updated>2019-04-14T11:54:33.649Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个故事"><a href="#一个故事" class="headerlink" title="一个故事"></a>一个故事</h3><blockquote><p>小张需要申请一台显示器，需要在公司内部系统提交审核清单。审核清单的审批流程要经过直属领导、部门领导、资源部领导几个环节审批，其中任何一个环节审核不通过，显示器就申请不下来。</p></blockquote><h3 id="责任链模式来模拟审批流程"><a href="#责任链模式来模拟审批流程" class="headerlink" title="责任链模式来模拟审批流程"></a>责任链模式来模拟审批流程</h3><p>审批流程就像一个链条一样，一级一级审批，直到最后资源部领导核查通过，小张就能拿到想要的显示器了</p><h4 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VerifyHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> VerifyHandler nextVerify;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextVerify</span><span class="params">(VerifyHandler nextVerify)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextVerify = nextVerify;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">examine</span><span class="params">(Request request)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextVerify</span><span class="params">(Request request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nextVerify != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.nextVerify.examine(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeamLeaderVerifyHandler</span> <span class="keyword">extends</span> <span class="title">VerifyHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">examine</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        System.out.println(request.getRequest());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"直属领导审批通过"</span>);</span><br><span class="line"></span><br><span class="line">        nextVerify(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApartmentVerifyHandler</span> <span class="keyword">extends</span> <span class="title">VerifyHandler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">examine</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"部门领导审批通过"</span>);</span><br><span class="line"></span><br><span class="line">        nextVerify(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceVerifyHandler</span> <span class="keyword">extends</span> <span class="title">VerifyHandler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">examine</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"资源部领导审批通过"</span>);</span><br><span class="line">        System.out.println(<span class="string">"发放显示器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String request;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(String request)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TeamLeaderVerifyHandler teamLeaderVerifyHandler = <span class="keyword">new</span> TeamLeaderVerifyHandler();</span><br><span class="line">        ApartmentVerifyHandler apartmentVerifyHandler = <span class="keyword">new</span> ApartmentVerifyHandler();</span><br><span class="line">        ResourceVerifyHandler resourceVerifyHandler = <span class="keyword">new</span> ResourceVerifyHandler();</span><br><span class="line"></span><br><span class="line">        teamLeaderVerifyHandler.setNextVerify(apartmentVerifyHandler);</span><br><span class="line">        apartmentVerifyHandler.setNextVerify(resourceVerifyHandler);</span><br><span class="line"></span><br><span class="line">        Request request = <span class="keyword">new</span> Request(<span class="string">"申请一条显示器"</span>);</span><br><span class="line">        teamLeaderVerifyHandler.examine(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何理解责任链模式"><a href="#如何理解责任链模式" class="headerlink" title="如何理解责任链模式"></a>如何理解责任链模式</h3><blockquote><p>使多个对象都有机会处理请求，从未避免了发送者与接收者之间的耦合关系，将这些对象连成一个链条，沿着链条传递请求。其结构和链表是类似的。</p></blockquote><p>当有审批流程进入时，先经过直属领导审批，待直属领导审批通过后，再把审批请求传递给部门领导，部门领导审批过后再传递给资源部领导，由此类推，形成一个链条，链条上的每个对象的职责各不相同。</p><h3 id="责任链模式模型抽象"><a href="#责任链模式模型抽象" class="headerlink" title="责任链模式模型抽象"></a>责任链模式模型抽象</h3><p>类图（TODO）</p><h3 id="责任链模式的应用"><a href="#责任链模式的应用" class="headerlink" title="责任链模式的应用"></a>责任链模式的应用</h3><ul><li>过滤器</li><li>拦截器</li></ul><h3 id="责任链模式的优点"><a href="#责任链模式的优点" class="headerlink" title="责任链模式的优点"></a>责任链模式的优点</h3><ul><li>请求者与接收者之间解耦</li><li>符合开闭原则，易于扩展</li></ul><h3 id="责任链模式的缺点"><a href="#责任链模式的缺点" class="headerlink" title="责任链模式的缺点"></a>责任链模式的缺点</h3><ul><li>性能问题。链表较长的时候会有性能问题（应该设置节点阈值）</li><li>调试逻辑比较复杂（调用者不知道被哪些接受者调用）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一个故事&quot;&gt;&lt;a href=&quot;#一个故事&quot; class=&quot;headerlink&quot; title=&quot;一个故事&quot;&gt;&lt;/a&gt;一个故事&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;小张需要申请一台显示器，需要在公司内部系统提交审核清单。审核清单的审批流程要经过直属领导、部门领导
      
    
    </summary>
    
      <category term="设计模式" scheme="https://shawnyou.tech/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Design" scheme="https://shawnyou.tech/tags/Design/"/>
    
  </entry>
  
</feed>

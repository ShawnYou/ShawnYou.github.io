<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot源碼|深入理解@EnbaleXxx]]></title>
    <url>%2F2019%2F06%2F16%2FSpring-boot%2FSpring%2F</url>
    <content type="text"><![CDATA[EnableXXX源码解析 Spring Boot的核心作用在于他具有强大的自动配置的功能，在Spring框架的基础上利用约定大于配置减少了Spring开发中配置复杂等问题。Spring Boot提供了很多类似于@EnableXXX的注解，这些注解有什么用呢？解决了Spring Boot什么问题？ 接下来我们通过源码来学习一下关@EnableXXX相关注解。 常见的@Enable注解 @EnableCaching @EnableAsync @EnbaleJpaRepositories @EnableAutoConfiguration 本文主要以@EnableCaching作为核心来讲解一下SpringBoot关于@EnbaleXXX注解实现 12345678910111213@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(&#123;CachingConfigurationSelector.class&#125;)public @interface EnableCaching &#123; //采用基于JDK的动态代理还是CGLIB boolean proxyTargetClass() default false; //默认采用动态代理的模式 AdviceMode mode() default AdviceMode.PROXY; int order() default 2147483647;&#125; 关于@Import，可以参照博客 @EnableCaching利用@Import导入了一个CachingConfigurationSelector配置类， 12345678910111213141516171819202122232425262728293031323334353637public class CachingConfigurationSelector extends AdviceModeImportSelector&lt;EnableCaching&gt; &#123; 、、、、只保留关键代码 public String[] selectImports(AdviceMode adviceMode) &#123; switch(null.$SwitchMap$org$springframework$context$annotation$AdviceMode[adviceMode.ordinal()]) &#123; case 1: return this.getProxyImports(); case 2: return this.getAspectJImports(); default: return null; &#125; &#125; private String[] getProxyImports() &#123; List&lt;String&gt; result = new ArrayList(3); result.add(AutoProxyRegistrar.class.getName()); result.add(ProxyCachingConfiguration.class.getName()); if(jsr107Present &amp;&amp; jcacheImplPresent) &#123; result.add("org.springframework.cache.jcache.config.ProxyJCacheConfiguration"); &#125; return StringUtils.toStringArray(result); &#125; //对于AspectJ代理模式，不作分析 private String[] getAspectJImports() &#123; List&lt;String&gt; result = new ArrayList(2); result.add("org.springframework.cache.aspectj.AspectJCachingConfiguration"); if(jsr107Present &amp;&amp; jcacheImplPresent) &#123; result.add("org.springframework.cache.aspectj.AspectJJCacheConfiguration"); &#125; return StringUtils.toStringArray(result); &#125; 、、、只保留关键代码、&#125; CachingConfigurationSelector导入两个关键的动态代理配置类 AutoProxyRegistrar ProxyCachingConfiguration AutoProxyRegistrar(自动代理构建器)AutoProxyRegistrar就是一个自动代理注册器，他负责给容器注册了一个InfrastructureAdvisorAutoProxyCreator ProxyCachingConfiguration123456789101112131415161718192021222324252627282930313233343536@Configuration@Role(2)public class ProxyCachingConfiguration extends AbstractCachingConfiguration &#123; public ProxyCachingConfiguration() &#123; &#125; @Bean( name = &#123;"org.springframework.cache.config.internalCacheAdvisor"&#125; ) @Role(2) public BeanFactoryCacheOperationSourceAdvisor cacheAdvisor() &#123; BeanFactoryCacheOperationSourceAdvisor advisor = new BeanFactoryCacheOperationSourceAdvisor(); advisor.setCacheOperationSource(this.cacheOperationSource()); advisor.setAdvice(this.cacheInterceptor()); if(this.enableCaching != null) &#123; advisor.setOrder(((Integer)this.enableCaching.getNumber("order")).intValue()); &#125; return advisor; &#125; @Bean @Role(2) public CacheOperationSource cacheOperationSource() &#123; return new AnnotationCacheOperationSource(); &#125; @Bean @Role(2) public CacheInterceptor cacheInterceptor() &#123; CacheInterceptor interceptor = new CacheInterceptor(); interceptor.configure(this.errorHandler, this.keyGenerator, this.cacheResolver, this.cacheManager); interceptor.setCacheOperationSource(this.cacheOperationSource()); return interceptor; &#125;&#125; ProxyCachingConfiguration向容器中注入三个Bean。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源碼|深入理解@Import注解]]></title>
    <url>%2F2019%2F06%2F15%2FSpring-boot%2FImport%2F</url>
    <content type="text"><![CDATA[深入理解@Import注解 查看SpringBoot相关组件的源码，会发现有很多地方运用了@Import注解，这个注解有什么用呢，工作原理是什么，我们可以利用这个@Import来做什么？ 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Import &#123; Class&lt;?&gt;[] value();&#125; @Import的使用方式1234567public class Client &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); ServiceImpl service = applicationContext.getBean(ServiceImpl.class); Assert.notNull(service,"service has inject successful"); &#125;&#125; Configuration通过@Import将Class加载到AppConfig类中 1234@Configuration@Import(value = ServiceImpl.class)public class AppConfig &#123;&#125; ImportBeanDefinitionRegistrar123public interface ImportBeanDefinitionRegistrar &#123; void registerBeanDefinitions(AnnotationMetadata var1, BeanDefinitionRegistry var2);&#125; 自定义BeanDefinitionRegistrar的实现12345678public class ServiceBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar&#123; @Override public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123; BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceImpl.class); //BeanDefinitionRegistry将生成的BeanDefinition注册到容器中去 beanDefinitionRegistry.registerBeanDefinition("service",builder.getBeanDefinition()); &#125;&#125; 1234@Configuration@Import(value = ServiceBeanDefinitionRegistrar.class)public class AppConfig &#123;&#125; 通过ImportBeanDefinitionRegistrar实现的Import可以针对Bean注册容器的过程进行自定义ImportSelector告诉容器需要注入哪些类的类名就可以实现Bean的注入 123public interface ImportSelector &#123; String[] selectImports(AnnotationMetadata var1);&#125; 1234567public class ServiceImportSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; //annotationMetadata是关于注解的元数据信息,可以根据需要获取注解的信息 return new String[]&#123;ServiceImpl.class.getName()&#125;; &#125;&#125; 1234@Configuration@Import(value = ServiceImportSelector.class)public class AppConfig &#123;&#125; 总结获取注解元数据信息，返回一组需要注入类的类名，有框架来生成对应的实体类从而注入到容器中去。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记|如何更好的创建和销毁对象]]></title>
    <url>%2F2019%2F04%2F14%2FeffectiveJava%2F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[静态工厂方法代替构造器静态工厂方法的几大优势 静态工厂方法有名称，易于区分。 避免不必要的重复对象的创建工作 不必每次调用都创建一个新的对象，可以将构建好的实例缓存起来重复使用 可以返回原返回类型的任何子类型 返回对象有了更大的灵活性 返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值 方法返回对象所属的类，在编写包含静态工厂方法的类时可以不存在 静态工厂方法的几个缺点 类如果不含公有的或者受保护的构造器，就不能被子类化 不易发现 遇到多个参数时要使用构建器当构造器扩展到大量的可选参数时，静态工厂和构造器就显得相当局限了。目前用的比较多的是重叠构造器1NutritionFacts cocaCola = new NutritionFacts(240,8,100,0,35,27); 缺点 可读性比较差 容易出错,如参数位置弄错位置 使用setter方案123456789101112131415161718192021222324252627282930313233343536373839404142public class NutritionFacts &#123; private int servingSize = -1; private int servings = -1; private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public NutritionFacts() &#123; &#125; public void setServingSize(int servingSize) &#123; this.servingSize = servingSize; &#125; public void setServings(int servings) &#123; this.servings = servings; &#125; public void setCalories(int calories) &#123; this.calories = calories; &#125; public void setFat(int fat) &#123; this.fat = fat; &#125; public void setSodium(int sodium) &#123; this.sodium = sodium; &#125; public void setCarbohydrate(int carbohydrate) &#123; this.carbohydrate = carbohydrate; &#125;&#125;NutritionFacts nutritionFacts = new NutritionFacts();nutritionFacts.setServingSize(240);nutritionFacts.setServings(100);nutritionFacts.setSodium(35);nutritionFacts.setCarbohydrate(27);nutritionFacts.setCalories(8); 可读性增强 一致性的问题(不安全) 构建器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class NutritionFacts &#123; private int servingSize = -1; private int servings = -1; private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; private NutritionFacts(Builder builder)&#123; this.servingSize = builder.servingSize; this.servings = builder.servings; this.calories = builder.calories; this.fat = builder.fat; this.sodium = builder.sodium; this.carbohydrate = builder.carbohydrate; &#125; public static class Builder&#123; private final int servingSize; private final int servings; private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) &#123; this.servingSize = servingSize; this.servings = servings; &#125; public NutritionFacts build()&#123; return new NutritionFacts(this); &#125; public Builder calories(int val)&#123; this.calories = val; return this; &#125; public Builder fat(int val)&#123; this.fat = val; return this; &#125; public Builder sodium(int val)&#123; this.sodium = val; return this; &#125; public Builder carbohydrate(int val)&#123; this.carbohydrate = val; return this; &#125; &#125; public static void main(String[] args) &#123; NutritionFacts nutritionFacts = new NutritionFacts.Builder(240,8).calories(100) .sodium(35).carbohydrate(27).build(); &#125;&#125; 直观、易于阅读(优点) 在注重性能的情况下，创建构建起是个问题(缺点) 最好一开始就用构建器(建议) 小结如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式是个不错的选择 私有构造器或者枚举类型强化Singleton属性Singleton:仅仅被实例化一次的类 Singleton的两种实现单例模式的实现（一）123456789public class Elvis &#123; public static final Elvis instance = new Elvis(); private Elvis()&#123;&#125; public void doSomething()&#123; System.out.println("do something"); &#125;&#125; 特点 私有构造器只调用一次，用来实例化公有的静态final域(instance) 没有public或者protect的构造器，保证了instance的唯一性 但是可以通过反射的方式调用私有构造器(可以修改构造器在创建第二次实例时抛出异常) 单例模式的实现（二）12345678910111213public class Elvis &#123; public static final Elvis instance = new Elvis(); private Elvis()&#123;&#125; public static Elvis getInstance()&#123; return instance; &#125; public void doSomething()&#123; System.out.println("do something"); &#125;&#125; 特点 添加了一个静态工厂方法，静态工厂方法的调用每次都返回同一个对象引用 公有的静态域是final的，该域总是包含相同的对象引用。公有域方法在性能上不会有任何优势，现在JVM实现能够将静态工厂方法的调用内联化。(内联：函数被调用的地方直接展开，编译器在调用时不会像一般函数那样，参数压栈，返回时参数出栈以及释放资源，直接提高程序的执行速度) Singleton可序列化问题Singleton仅仅在声明中加上implement Serializable是不够的，必须所有的实例都是瞬时的，并提供一个readResolve方法，否则每次反序列化都会创建一个新的实例 单例模式的实现（三）— 通过枚举类型实现1234567public enum Elvis &#123; INSTANCE; public void doSomething()&#123; System.out.println(&quot;do something&quot;); &#125; &#125; 特点 简洁 无偿提供了序列化机制，防止多次实例化 单元素的枚举类型是实现Singleton的最佳方法 使用依赖注入来引用资源静态工具类引用底层资源1234567891011public class SpellChecker &#123; private static final Dictionary DICTIONARY = new Dictionary(); public static boolean isValid(String word)&#123; System.out.println("do something"); return true; &#125; public SpellChecker()&#123;&#125;&#125; Singleton引用底层资源1234567891011public class SpellChecker &#123; private final Dictionary dictionary = new Dictionary(); private SpellChecker()&#123;&#125; public boolean isValid(String word)&#123; System.out.println("do something"); return true; &#125;&#125; 以上引入资源的两种形式都不太好。因为没法支持多种词典。所以静态资源类和Singleton类不适合作需要引用底层资源的类。 所以使用依赖注入来引入底层资源，当创建一个新的实例时，将该资源传到构造器中去。12345678910111213public class SpellChecker &#123; private final Dictionary dictionary; public SpellChecker(Dictionary dictionary)&#123; this.dictionary = dictionary; &#125; public boolean isValid(String word)&#123; System.out.println("do something"); return true; &#125;&#125; 依赖注入的变体形式将资源工厂传给构造器 小结 不要使用Singleton和静态工具类来实现依赖一个或者多个底层资源的类 尽量将资源或者创建资源的工厂传给构造器，（或者工厂方法、builder）,这样会增加类的灵活性、重用性和可测试性 避免创建不必要的对象最好重用对象而不是每次需要的时候创建一个相同功能的新对象，这样可以提高性能，缩短响应时间。 String创建的案例123String s = new String("test");String s = "test"; 第一个语句： 每次执行都会创建新的String实例，这些创建的对象都是不必要的。如果用在一个频繁调用的方法中，就回创建成千上万不必要的String实例。 第二个语句： 对于所有在同一台虚拟机运行的代码，只要它们包含相同的字符串字面常量，该对象就会被重用。 java会在方法区运行时常量池保存”test”,当下次调用String = “test”,java会直接返回这个对象的引用，而不会重新创建对象，由此节省了内存开销，可以放心在循环中使用 String s = new String(“test”)实际创建了两个对象，一个对象在堆中，一个保存在常量池 优先使用静态工厂方法而不是构造器来创建对象 构造器每次调用都会创建新对象，而静态工厂方法不会这样，静态工厂方法可以重用对象，也可以加缓存 如果反复需要一些创建成本比较高的对象，建议缓存下来重用。 不要创建多个适配器如果对象是可以变化的，也可以实现重用 适配器：把功能委托给一个后备对象，从而为后备对象提供一个可以替代的接口，适配器除了后备对象，没有其他任何信息。 Map接口的keyset()返回Map对象的Set视图，包含Map的所有键 每次调用都返回Map对象锁对应的Set实例，即便Map内容会有所变化，也能反映到Set实例中。 所以没有必要创建多个Set实例。 123456789101112131415161718192021222324252627282930313233343536373839404142public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; if (ks == null) &#123; ks = new AbstractSet&lt;K&gt;() &#123; public Iterator&lt;K&gt; iterator() &#123; return new Iterator&lt;K&gt;() &#123; private Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); public boolean hasNext() &#123; return i.hasNext(); &#125; public K next() &#123; return i.next().getKey(); &#125; public void remove() &#123; i.remove(); &#125; &#125;; &#125; public int size() &#123; return AbstractMap.this.size(); &#125; public boolean isEmpty() &#123; return AbstractMap.this.isEmpty(); &#125; public void clear() &#123; AbstractMap.this.clear(); &#125; public boolean contains(Object k) &#123; return AbstractMap.this.containsKey(k); &#125; &#125;; keySet = ks; &#125; return ks; &#125; 避免自动装箱造成重复对象的创建自动装箱会导致多余对象的创建 1234567private static long sum()&#123; Long sum = 0L; for(long i = 0;i&lt;=Integer.MAX_VALUE;i++)&#123; sum += i; &#125; return sum; &#125; 声明的变量是Long而不是long,所以每一次循环都会构造多余的Long实例， 所以要优先使用基本类型而不是装箱基本类型，当心无意识的自动装箱。 小结 通过维护对象池来避免创建对象也不是好事情，除非对象池中的对象是非常重要的对象。 维护对象池会把代码弄得很乱，同时增加内存占用，损害性能 消除过期的对象引用虽然java帮助我们完成了大部分内存管理的工作，但是我们还不不能对内存管理置之不理。 Stack引发的内存溢出的问题1234567891011121314151617181920212223242526272829public class Stack &#123; private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACOTY = 16; public Stack()&#123; elements = new Object[DEFAULT_INITIAL_CAPACOTY]; &#125; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if(size ==0)&#123; throw new RuntimeException("no element"); &#125; return elements[--size]; &#125; private void ensureCapacity()&#123; if(elements.length == size)&#123; elements = Arrays.copyOf(elements,2*size+1); &#125; &#125;&#125; 栈先增长，后收缩，对于弹出来的对象，栈依旧维护者这些对象的引用，所以这些对象不会被当做垃圾回收 所以一旦对象引用已经过期，只需清空这些引用就可以了12345678public Object pop()&#123; if(size ==0)&#123; throw new RuntimeException("no element"); &#125; Object result = elements[--size]; elements[size] = null; return result; &#125; 注意点： 清空对象引用是一种例外，而不是一种规范行为，对于栈这种自己管理内存的情况，程序员就应该警惕内存泄露问题。 缓存引起的内存泄露 缓存容易被遗忘，一旦时间长了,日积月累的缓存容易出现内存溢出的情况。 监听器和回调造成的内存溢出 避免使用终结方法try-with-resource优先于try-finally]]></content>
      <categories>
        <category>读书笔记(Effective Java)</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2019%2F04%2F14%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是适配器模式 将一个接口变换成客户期待的另一个的接口，从而使原本因接口不匹配无法一起工作的两个类能够一起工作。 生活中不乏这样的案例，如电脑的电源适配器，它的作用主要是解决家用电和电脑之间的兼容问题 程序模拟]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2019%2F04%2F13%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[实际案例一个主题切换案例123public interface Theme &#123; void applyTheme();&#125; 123456public class DefaultTheme implements Theme&#123; @Override public void applyTheme() &#123; System.out.println("设置默认主题"); &#125;&#125; 123456public class DarkTheme implements Theme&#123; @Override public void applyTheme() &#123; System.out.println("设置暗黑风格主题"); &#125;&#125; 123456public class ColorfulTheme implements Theme&#123; @Override public void applyTheme() &#123; System.out.println("设置彩色风格主题"); &#125;&#125; 123456789101112131415public class ThemeManager &#123; private Theme theme; public ThemeManager() &#123; this.theme = new DefaultTheme(); &#125; public void setTheme(Theme theme)&#123; this.theme = theme; &#125; public void applyTheme()&#123; this.theme.applyTheme(); &#125;&#125; 12345678public class Client &#123; public static void main(String[] args) &#123; ThemeManager themeManager = new ThemeManager(); //设置黑暗风格主题 themeManager.setTheme(new DarkTheme()); themeManager.applyTheme(); &#125;&#125; 主题模式更换的案例中，不同的主题风格就是一个个策略，我们可以根须需要选择不同的策略。 如何理解策略模式 定义椅子算法，将每个算法都以类的方式凤凰钻起来，并且使他们可以互相交换。 类图（TODO） 策略模式模型抽象 Context封装角色 主题更换案例中的ThemeManager就是一个封装角色，也叫上下文角色，拼比高层对策略的直接访问。 Strategy抽象策略角色 定义每个策略必须具有的方法和属性 ConcreteStrategy具体策略角色 抽象策略的实现，具体的算法 策略模式的优点 算法可以自由切换 避免了多重条件的判断 良好的扩展性(符合开闭原则) 策略模式的缺点 策略类会逐渐增多(超过四个考虑使用混合模式) 策略类必须向外暴露(违反迪米特法则) — 上层模块必须知道哪些策略，才能使用哪些策略，可用工厂方法模式修正 策略模式的具体应用 Shiro权限控制框架有三种验证策略]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器模式]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一个故事小明今年买了一个毛坯房，计划六月份装修作为婚房使用。小明选择了自定义的装修方案。线槽、刷漆、家具定制、门窗定制都是由不同的厂家来定制安装。 通过装饰器模式来模拟装修 毛坯房是一个被装饰的对象 线槽、刷漆、家具定制、门窗定制等就是装饰对象，他们负责对毛坯房进行装饰。 123public interface House &#123; void decorate();&#125; 123456public class RoughHouse implements House&#123; @Override public void decorate() &#123; System.out.println("毛坯房要开始装修了"); &#125;&#125; 1234567public abstract class HouseDecorate implements House&#123; protected House house; public HouseDecorate(House house) &#123; this.house = house; &#125;&#125; 刷漆的装饰类1234567891011public class BrushingHouseDecorate extends HouseDecorate&#123; public BrushingHouseDecorate(House house) &#123; super(house); &#125; @Override public void decorate() &#123; house.decorate(); System.out.println("房屋装修------刷漆"); &#125;&#125; 家具定制的装饰类123456789101112public class CustomizedFurnitureHouseDecorate extends HouseDecorate&#123; public CustomizedFurnitureHouseDecorate(House house) &#123; super(house); &#125; @Override public void decorate() &#123; house.decorate(); System.out.println("房屋装修------定制家具"); &#125;&#125; 门窗定制的装饰类1234567891011public class DoorWindowHouseDecorate extends HouseDecorate&#123; public DoorWindowHouseDecorate(House house) &#123; super(house); &#125; @Override public void decorate() &#123; house.decorate(); System.out.println("房屋装修------门窗定制"); &#125;&#125; 线槽安装的装饰类1234567891011public class TrunkingHouseDecorate extends HouseDecorate&#123; public TrunkingHouseDecorate(House house) &#123; super(house); &#125; @Override public void decorate() &#123; house.decorate(); System.out.println("房屋装修------安装线槽"); &#125;&#125; 客户端12345678910111213public class Client &#123; public static void main(String[] args) &#123; House house = new RoughHouse(); house = new BrushingHouseDecorate(house); house = new TrunkingHouseDecorate(house); house = new CustomizedFurnitureHouseDecorate(house); house = new DoorWindowHouseDecorate(house); house.decorate(); &#125;&#125; Result12345毛坯房要开始装修了房屋装修------刷漆房屋装修------安装线槽房屋装修------定制家具房屋装修------门窗定制 如何理解装饰器模式 动态的给一个对象添加额外的职责。提供了比集成更有弹性的替代方案 装饰器刷漆装修、安装线槽、定制家具、门窗定制都是属于装饰器。当我们居住一段时间后，想把厕所改造一下，我们只需要再构造一个装饰器，对房屋就是包装装饰就完成了工作，而不需要做过多的改变。 被装饰对象毛坯房就是属于被装饰对象 特点 装饰器与被装饰对象实现同一个接口 装饰器持有被装饰对象的引用 可以随意添加装饰器 看到装饰器模式的前两个特点，我们是不是有种似曾相识的感觉，这不是静态代理的特点吗？装饰器就好比代理类，他持有被代理对象（被装饰对象）的引用，去做被代理对象能做但是不想做的事情。 装饰器模式与静态代理 静态代理想做但不能做，需要找一个能干的人帮我做 装饰器模式我想做，但不能做，需要找各具特色的人来帮我做 用一个例子来说明这是一个代理类的实现12345678910111213141516171819202122public class Proxy implements Subject&#123; private Subject subject; public Proxy(Subject subject)&#123; this.subject = subject; &#125; @Override public void request() &#123; this.before(); subject.request(); this.after(); &#125; private void before()&#123; System.out.println("前置处理。。。。"); &#125; private void after()&#123; System.out.println("后置处理。。。。"); &#125;&#125; 如果我们想给主题添加一点操作日志，最简单的方法就是添加一个log();123private void log()&#123; System.out.println("添加日志");&#125; 对于需求，我们是不可控的，未来需求不断的增长，代理类会越来越大，难以维护，而且也不符合开闭原则。 如何应用 装饰器模式与静态代理模式都是包装模式，为其添加特定的功能 功能单一，可以选择代理模式 功能较多其需要动态扩张海燕，可以选择装饰器模式 装饰器模式应用场景 Java IO流123456DataInputStream in = new DataInputStream(new FileInputStream("test.txt")); String str; while ((str = in.readLine())!=null)&#123; System.out.println(str); &#125; in.close(); 查看DataInputStream源码1234567891011121314publicclass DataInputStream extends FilterInputStream implements DataInput &#123; /** * Creates a DataInputStream that uses the specified * underlying InputStream. * * @param in the specified input stream */ public DataInputStream(InputStream in) &#123; super(in); &#125; ......&#125; 12345678910111213141516171819202122publicclass FilterInputStream extends InputStream &#123; /** * The input stream to be filtered. */ protected volatile InputStream in; /** * Creates a &lt;code&gt;FilterInputStream&lt;/code&gt; * by assigning the argument &lt;code&gt;in&lt;/code&gt; * to the field &lt;code&gt;this.in&lt;/code&gt; so as * to remember it for later use. * * @param in the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if * this instance is to be created without an underlying stream. */ protected FilterInputStream(InputStream in) &#123; this.in = in; &#125; ...&#125; 通过源代码可以看出 装饰器FilterInputStream及其子类（DataInputstream） 被装饰对象InputStream 由此可以设计出很多具有不同的特性的IO流。 装饰器模式的优点 扩展方式了灵活 每个装饰器互相独立不受影响 装饰模式是继承的替代方案，能够解决类膨胀的问题，继承是静态增加功能，装饰模式是动态增加功能。不管装饰多少层，返回的还是父类，实现的是is-a的关系。如果需要去掉某个功能，装饰模式去掉封装就可以了，但是继承就必须修改代码。 动态扩展装饰器类 装饰器模式的缺点 多层装饰比较复杂(类似剥洋葱)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一个故事 小张需要申请一台显示器，需要在公司内部系统提交审核清单。审核清单的审批流程要经过直属领导、部门领导、资源部领导几个环节审批，其中任何一个环节审核不通过，显示器就申请不下来。 责任链模式来模拟审批流程审批流程就像一个链条一样，一级一级审批，直到最后资源部领导核查通过，小张就能拿到想要的显示器了 代码案例123456789101112131415public abstract class VerifyHandler &#123; private VerifyHandler nextVerify; public void setNextVerify(VerifyHandler nextVerify)&#123; this.nextVerify = nextVerify; &#125; public abstract void examine(Request request); public void nextVerify(Request request)&#123; if(nextVerify != null)&#123; this.nextVerify.examine(request); &#125; &#125;&#125; 1234567891011public class TeamLeaderVerifyHandler extends VerifyHandler&#123; @Override public void examine(Request request) &#123; System.out.println(request.getRequest()); System.out.println("直属领导审批通过"); nextVerify(request); &#125;&#125; 12345678public class ApartmentVerifyHandler extends VerifyHandler&#123; @Override public void examine(Request request) &#123; System.out.println("部门领导审批通过"); nextVerify(request); &#125;&#125; 1234567public class ResourceVerifyHandler extends VerifyHandler&#123; @Override public void examine(Request request) &#123; System.out.println("资源部领导审批通过"); System.out.println("发放显示器"); &#125;&#125; 123456789101112131415public class Request &#123; private String request; public String getRequest() &#123; return request; &#125; public void setRequest(String request) &#123; this.request = request; &#125; public Request(String request)&#123; this.request = request; &#125;&#125; 12345678910111213public class Client &#123; public static void main(String[] args) &#123; TeamLeaderVerifyHandler teamLeaderVerifyHandler = new TeamLeaderVerifyHandler(); ApartmentVerifyHandler apartmentVerifyHandler = new ApartmentVerifyHandler(); ResourceVerifyHandler resourceVerifyHandler = new ResourceVerifyHandler(); teamLeaderVerifyHandler.setNextVerify(apartmentVerifyHandler); apartmentVerifyHandler.setNextVerify(resourceVerifyHandler); Request request = new Request("申请一条显示器"); teamLeaderVerifyHandler.examine(request); &#125;&#125; 如何理解责任链模式 使多个对象都有机会处理请求，从未避免了发送者与接收者之间的耦合关系，将这些对象连成一个链条，沿着链条传递请求。其结构和链表是类似的。 当有审批流程进入时，先经过直属领导审批，待直属领导审批通过后，再把审批请求传递给部门领导，部门领导审批过后再传递给资源部领导，由此类推，形成一个链条，链条上的每个对象的职责各不相同。 责任链模式模型抽象类图（TODO） 责任链模式的应用 过滤器 拦截器 责任链模式的优点 请求者与接收者之间解耦 符合开闭原则，易于扩展 责任链模式的缺点 性能问题。链表较长的时候会有性能问题（应该设置节点阈值） 调试逻辑比较复杂（调用者不知道被哪些接受者调用）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是命令模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[关于克隆，我们会想到《西游记》里面孙悟空的猴毛分身，也会想到《火影忍者》里面的影分身之术。他们都是用一个物体复制若干个一模一样的物体。在面向对象的系统中，我们也可以通过克隆来复制一些对象—也就是我们所说的原型模式 用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象，也就是利用一个原型对象来指明我们要创建对象的类型，然后通过复制这个对象来获取一模一样的对象实例 一个简单的原型模式Demo123456789101112public class PrototypeClass implements Cloneable&#123; @Override protected PrototypeClass clone()&#123; PrototypeClass prototypeClass = null; try &#123; prototypeClass = (PrototypeClass)super.clone(); &#125;catch (CloneNotSupportedException e)&#123; &#125; return prototypeClass; &#125;&#125; 实现Cloneable接口，在JVM中只有具有这个标记的对象才有可能被拷贝 重写覆盖Clone()方法 为什么要用原型模式 性能优良。 原型模式是在内存二进制流的拷贝，比直接new一个对象性能要好得多。所以特别是要在一个循环体内产生大量对象的时候，原型模式更好体现其优点 避开构造函数的束缚（既是优点也是缺点）直接在内存中拷贝，构造函数是不会执行的 原型模式应用场景 资源优化场景 性能和安全要求场景 一个对象多个修改者的场景 两种拷贝方式浅拷贝只拷贝本对象，对象内部的数组、引用对象都不拷贝，还是指向原生对象的内部元素地址。原始类型（int、long、char）以及String都会被拷贝 如何才能保证成员变量不被拷贝（保证以下两个条件） 必须是类的成员变量，而不是方法内变量 必须是一个可变的引用对象，而不是一个原始类型或者不可变对象 12345678910111213141516171819202122public class Thing implements Cloneable &#123; private List&lt;String&gt; list = new ArrayList&lt;String&gt;(); @Override protected Thing clone()&#123; Thing thing = null; try &#123; thing = (Thing)super.clone(); &#125;catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return thing; &#125; public void setValue(String value)&#123; this.list.add(value); &#125; public List&lt;String&gt; getValue()&#123; return this.list; &#125;&#125; 浅克隆是不安全的方式，两个对象共享了一个私有变量，大家都能够进行修改。 深拷贝1234567891011121314151617181920212223public class DeepThing implements Cloneable &#123; private ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); @Override protected DeepThing clone()&#123; DeepThing thing = null; try &#123; thing = (DeepThing)super.clone(); this.list = (ArrayList&lt;String&gt;)this.list.clone(); &#125;catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return thing; &#125; public void setValue(String value)&#123; this.list.add(value); &#125; public List&lt;String&gt; getValue()&#123; return this.list; &#125;&#125; 总结 原型模式向客户隐藏了创建对象的复杂性，客户只需要知道创建对象类型，就可以获得对象一模一样的新对象。 有两种克隆方式：深克隆、浅克隆 浅克隆；不安全，对象公有私有变量 有时对象的复制可能会比较复杂]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2F2019%2F04%2F05%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[中介者模式如何理解中介者模式复杂的进销存系统类图 类图 虽然不同类型的参与者完成各自的活动，但是每个类相互关联耦合 每个类与多个朋友类相互交互，朋友类越多，耦合性越大，要修改一个，就得修改一大片— 违反迪米特法则 不同参与者之间交互过于复杂，维护比较困难 使用一个中介者对象，他将各个对象之间的交互封装起来作为一个中间桥梁，降低各个参与者的耦合性。 中介者类图 每个参与者只负责自己的业务逻辑，不属于自己的交给中介者去处理 每个参与者不再交互交流，简化了各模块间的耦合性 抽象中介者类 定义统一的接口，用于各个参与者角色之间的通信1234567891011121314151617public abstract class Mediator &#123; protected ConcreteColleagueA concreteColleagueA; protected ConcreteColleagueB concreteColleagueB; public Mediator()&#123; concreteColleagueA = new ConcreteColleagueA(this); concreteColleagueB = new ConcreteColleagueB(this); &#125; public abstract void doSomethingA(); public abstract void doSomethingB();&#125;Q:为什么使用参与类实现类注入，而不使用抽象类注入(接口注入)A:因为每个参与类没有必须要完成的业务方法(没有相同的方法), 假如有相同的方法，当然要注入抽象类做到依赖倒置。 抽象参与者类 每一个参与者必须知道中介者角色，所以通过构造函数传入1234567public abstract class Colleague &#123; protected Mediator mediator; public Colleague(Mediator mediator)&#123; this.mediator = mediator; &#125;&#125; 具体中介者类 协调各个参与者实现协作工作行为，要依赖各个参与者 1234567891011121314public class ConcreteMediator extends Mediator&#123; @Override public void doSomethingA() &#123; super.concreteColleagueA.selfMethod(); super.concreteColleagueB.selfMethod(); &#125; @Override public void doSomethingB() &#123; super.concreteColleagueA.selfMethod(); super.concreteColleagueB.selfMethod(); &#125;&#125; 具体参与者类A 自身的行为selfMethod,用于处理自身的业务逻辑 依赖的行为depMethod,依靠中介者去完成1234567891011121314public class ConcreteColleagueA extends Colleague&#123; public ConcreteColleagueA(Mediator mediator)&#123; super(mediator); &#125; public void selfMethod()&#123; //自己的业务逻辑 &#125; public void depMethod()&#123; //不能处理的业务逻辑，交给中介者处理 super.mediator.doSomethingA(); &#125;&#125; 具体参与者类B 12345678910111213public class ConcreteColleagueB extends Colleague&#123; public ConcreteColleagueB(Mediator mediator) &#123; super(mediator); &#125; public void selfMethod()&#123; //自己能够处理的业务逻辑 &#125; public void depMethod()&#123; super.mediator.doSomethingB(); &#125;&#125; 客户端 12345678910111213public class ConcreteColleagueB extends Colleague&#123; public ConcreteColleagueB(Mediator mediator) &#123; super(mediator); &#125; public void selfMethod()&#123; //自己能够处理的业务逻辑 &#125; public void depMethod()&#123; super.mediator.doSomethingB(); &#125;&#125; 用一个中介对象封装一系列的对象交互，中介者使对象不需要显示的相互作用，从而使其耦合松散,并且可以独立的改变他们之间的交互 中介者模式有什么优势 系统更加灵活，各个参与者相互独立 减少类间的依赖，参与类只依赖中介者，减少了依赖，降低了类间的耦合中介者模式存在的问题 中介者承担了太多的职责，一旦出现问题，整个系统都会受影响 中介者会变得非常复杂，原本参与者间的关系转换成了中介者与参与者的关系，参与者越多，中介者就越复杂 中介者模式要慎用 量力而行。 中介者模式会使中介者逻辑复杂化。使用不当会把问题变得复杂，如果本身就只有简单的几个依赖关系，就没必要用终结者模式。所以要根据情况权衡中介者模式的使用 中介者适合多个对象紧密耦合的情况–蜘蛛网结构，中介者模式能将蜘蛛网结构梳理成星型结构 留下的问题Q:不符合依赖倒置原则，很少使用接口或者抽象类 参与者之间是协作关系，处理不同的任务，不能严格定义参与者需要具有的方法，不能抽象出一个统一的父类 每个中介者所围绕的参与类各不相同，不能抽象出一个具有共性的中介者 两个对象不能提炼出共性，就不要追求两者的抽象]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式|动态代理原理浅析]]></title>
    <url>%2F2019%2F04%2F05%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[为其他对象提供一个代理以控制对这个对象的访问，在不改变目标对象基础上添加额外的功能。 如何理解代理模式 两个主体：代理对象和被代理对象 对于被代理对象，事情必须要去做吗，但是自己不想去做或是没有条件去做，需要代理对象代替被代理对象去做。 代理对象能够获取被代理对象的资料信息。 代理层面（获得被代理对象的引用） 生活案例 中介：通常买二手车的时候，会去网上找车源，对车进行质量检测，以及各种过户手续的办理，自己可能不想做这些事情，所以可以找第三方的中介公司来完成这些事情，我只负责把我想要的车辆的信息（价位、车辆新旧程度、品牌）反馈给中介，中介把所有的办好就只管我来签字验收就可以了。 黄牛：当春运火车票比较紧张的时候，我抢不到票，且自己也不想去抢，则可以通过黄牛去买，我只管把我的车票信息给他（初始地、目的地、出发时间、车次），由此不用抢票，也可以买到相应的车票，抢票的过程由黄牛去做。 媒人：平时自己没有时间去交女朋友，则需要媒人去介绍，我们只管把我们想要的女朋友的类型给媒人，媒人则帮我们去寻找合适的对象。 需要类图 Subject(抽象主题) 可以是抽象类也可以是接口 RealSubject(具体角色) 被代理的对象，业务逻辑的执行者 Proxy(代理角色) 代理类，负责对真实角色的应用，把所有抽象主题定义的方法限制委托给真实角色实现，并在真实角色处理完毕前后做相应工作 几种代理实现形式代理有两种主要形式 静态代理 编译前，代码已经创建好，程序运行时，class文件已经存在 动态代理 程序运行时通过反射生成代理类 静态代理 代理类与目标类实现相同的接口 代理类持有目标类的引用，可以控制目标类方法的访问 普通代理1234public interface Subject &#123; void request();&#125; 123456public class RealSubject implements Subject &#123; @Override public void request() &#123; System.out.println("start to request"); &#125;&#125; 12345678910111213141516171819202122public class Proxy implements Subject&#123; private Subject subject; public Proxy(Subject subject)&#123; this.subject = subject; &#125; @Override public void request() &#123; this.before(); subject.request(); this.after(); &#125; private void before()&#123; System.out.println("前置处理。。。。"); &#125; private void after()&#123; System.out.println("后置处理。。。。"); &#125;&#125; 强制代理 只能通过真实角色角色制定的代理类才能访问 不允许直接访问真实角色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public interface Subject &#123; void request(); Subject getProxy();&#125;```javapublic class SubjectProxy implements Subject&#123; private Subject subject; public SubjectProxy(Subject subject) &#123; this.subject = subject; &#125; @Override public void request() &#123; this.subject.request(); &#125; @Override public Subject getProxy() &#123; return this; &#125;&#125;```javapublic class RealSubject implements Subject&#123; private Subject proxy = null; @Override public void request() &#123; if(this.isProxy())&#123; System.out.println("start to request"); &#125;else &#123; System.out.println("请使用指定的代理进行访问"); &#125; &#125; @Override public Subject getProxy() &#123; this.proxy = new SubjectProxy(this); return this.proxy; &#125; private boolean isProxy()&#123; if(this.proxy == null)&#123; return false; &#125;else &#123; return true; &#125; &#125;&#125; 1234567public class Client &#123; public static void main(String[] args) &#123; RealSubject subject = new RealSubject(); Subject proxy = subject.getProxy(); proxy.request(); &#125;&#125; 静态代理局限性 不够灵活，每个代理只为一个接口服务，会造成大量代码重复 静态代理类职位特定的接口服务，如果有多个接口，需要生成多个代理对象，不利于系统维护 动态代理123public interface CustomerService &#123; void buyCar();&#125; 123456public class CustomerServiceImpl implements CustomerService&#123; @Override public void buyCar() &#123; System.out.println("决定买这个车了"); &#125;&#125; 123456789101112131415161718public class CarAgency implements InvocationHandler&#123; //被代理对象的引用 private Object target; public Object getInstance(Object target)&#123; this.target = target; Class clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(),target.getClass().getInterfaces(),this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("办理车辆质量检查报告"); method.invoke(target,args); System.out.println("办理车辆二手车过户"); return null; &#125;&#125; 动态代理源码解析 代理模式的意义（如何案例理解） 三种代理方式 动态代理实现原理 动态代理的实际运用（RPC、Spring等 RMI 收集相关的应用）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[建造者模式 将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示 如何理解建造者模式建造者模式就是将建造复杂对象的过程和组成对象的部件进行解耦。 案例游戏公司设计游戏角色，其中人、兽、精灵三个种族。而每个种族又拥有不同的英雄角色。所以角色设计应该具备以下特点: 角色基本属性一致 角色创建过程复杂，不暴露创建细节 符合开闭原则，可以随时新增角色 各个角色间彼此不受影响 这些特点很符合工厂模式的适用特点，那用工厂模式就可以实现的案例为何要用建造者模式？ 主要是一个角色包含有头、手、脚、毛发…等许多部件，不同种族不同角色的部件有许多差异。如果使用工厂模式，那么角色的创建过程会与其各个部件耦合在一起，如果部件比较多，那么角色的创建是比较复杂的。比如所以我们需要将对象的创建过程与组成对象的部件进行解耦，也就是这一章的主题—建造者模式 类图（todo） 产品类 定义产品的基本属性 抽象建造者 定义产品各个部件的构建规范 具体构建者 实现抽象构建者的所有方法，返回一个具体的产品 导演类 负责封装已有模块的顺序 隔离客户与生产过程 控制产品的生成过程 优势 良好的封装性。产品类和建造类相对固定，将主要逻辑封装到导演类可以取得比较好的稳定性。 不需暴露产品内部细节，将产品本身与产品创建过程进行解耦。 精细控制产品创建过程。创建过程清晰，能够把控产品每个部件的创建过程。 良好的扩展性。新的需求只需要增加新的建造类就可以解决，符合开闭原则。 局限性 建造者不适合差异性很大的产品类。 产品内部变化复杂，需要定义很多建造类来实现，会导致系统变得庞大。 使用场景 相同的方法，不同的执行顺序，产生不同的事件结果 一个对象具有多个部件，但是不同的对象的部件有所差异，也可以使用建造者模式 需要隔离复杂对象的创建和使用，并使相同创建过程可以创建不同的产品 建造者模式与工厂模式的区别工厂模式职责—创建对象 将创建过程封装到工厂类，有工厂类提供最终产品。 建造模式职责—零件的装配以产生不同的对象 负责创建复杂对象，需要对对象的部件进行装配以产生不同效果的对象，具有的建造过程交给指挥类。由指挥类负责将各个组件按照规则组建为产品。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板模式]]></title>
    <url>%2F2019%2F03%2F25%2F%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法模式 定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤 如何理解模板模式在我们的认识中，模板就是一些约定俗成的东西，是一些自然而然的事物规律。当我们想要解决一些具有模板规律的事情的时候，手中的模板就是一个个整齐待发的磨具，能够轻松进行重复制造、生产。由此想了想，生活中哪些事情满足模板模式的规律： 制茶，制茶是一个很有讲究的学问。制造茶的流程总是相对固定的。采青-&gt; 萎凋-&gt;发酵-&gt; 杀青 -&gt; 揉捻 -&gt; 干燥 -&gt; 初制茶。每个工坊的制作工艺有所差别，有些工坊的手工揉捻做的比较好，有些工坊的萎凋做的比较有特点，所以生产出来的茶叶有所区别。但是他们的总体流程是相对差不多的，都遵循相同的制作模板。 造车，车的总体功能差不多， 能够启动、停止，能够鸣笛、跑路。但是不同型号的车是有所差异的。有些车是手动挡，有些是自动挡。 我们可以根据这类食物的规律总结一下特点： 具有一个抽象的模板，这个模板决定了这类事物的总体流程规律（父类抽象模板） 不同的事物虽然具有共同的抽象模板，但是彼此有着个性化的差异（个性化子类） 子类的个性化特点能够重新定义整个事物的最终呈现结构，就好比不同的茶叶工坊的制作工艺的差别会导致这个茶叶具有不同销量和名声。不同型号的车会导致车具有不同的价格和市场。 程序是现实世界的抽象，模板模式的类可以总结如下： 抽象模板 基本方法 子类的个性化方法，由子类去实现，如制茶过程中每一个环节（发酵…） 模板方法 对基本方法的调度，已完成固定的逻辑。如制茶这样的模板方法就是将制茶每个环节的调度，完成造茶这么一个逻辑。 注意： 基本方法尽量设计成protected类型，符合迪米特法则，若非必要，尽量不要扩大父类的访问权限。 模板方法一般设计成final类型，不要被覆写 为什么要用模板模式 封装不变部分，扩展可变部分 不变的流程规律由父类来实现，而可变的每个环节由子类来控制。 提取公共部分代码，便于维护 行为由父类控制、子类实现 基本方法由子类实现，子类可以通过扩展类来增加相应功能，符合开闭原则。 模板模式实现 模板模式也有缺陷 四思维方式与以往有所不同，不好理解。 常规思路: 抽象类-&gt;最抽象、最一般的事物属性和方法 具体类-&gt;具体的事物属性和方法 模板模式思路： 抽象类-&gt;定义部分抽象方法 实现类-&gt;子类的执行结果对父类结构产生影响 总结一下 模板模式的扩展–钩子函数的应用由子类的一个方法返回值来决定公共部分的执行结果 引申 父类怎么调用子类的方法 子类传递到父类的有参构造中 反射 父类调用子类的静态方法 其实模板模式就间接的实现了父类依赖子类的场景 父类建立框架-&gt;子类重写父类 -&gt; 调用父类继承方法-&gt; 影响父类结果]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式|如何优雅的new对象]]></title>
    <url>%2F2019%2F03%2F24%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[写在前面在面向对象编程（OOP）中，通过new去实例化一个对象是再正常不过的事情。但是每当new一个对象，后面都会跟一个具体类，这使得代码与具体类过度耦合，让我们陷入面向实现编程的漩涡里面。每当有新的需求变更，我们代码的扩展性就比较差。 手动new对象有哪些问题 与具体类耦合，每当有新的变化，就必须改变代码（不符合对修改关闭） 无法借助接口、多态的力量去隔离变化（与面向接口编程相违背） 如何才能优雅的new对象 对扩展开放，应对后期的各种需求 对修改关闭，对于新的需求，不改变原有的代码 不关心构造对象的细节和复杂过程，轻松获取对象实例 可以通过工厂模式来构造我们想要的对象。 工厂模式是一种常用的创建型设计模式，在基类中定义了创建对象的接口，让子类来决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。 工厂模式包括我们所熟知的简单工厂模式、工厂方法模式、抽象工厂工厂模式。其中简单工厂模式在一定程度上只算是一种编程思想，还谈不上设计模式。但它作为工厂方法模式和抽象工厂模式的基石，还是有必要深入了解一下。 造车案例来了解一下不同的工厂模式 客户想要一辆奔驰车，客户需要奔驰车的设计图纸相应的汽车零件来自己制造。当客户想要悍马车，手上的设计图纸和汽车零件已经毫无用处，需要获取悍马车的设计图纸以及汽车零件（不符合对修改关闭） 客户不需要自己生产汽车，由工厂来提供服务，客户需要什么车，工厂就生产什么车。但是每当客户有新的需求的时候，工厂就得想尽办法去找相关的图纸和零件来交付生产。—简单工厂模式（不符合对修改关闭） 客户的需求太多，一个工厂完全应付不过来，所以工厂就开始建立新的场地，有些场地只生产宝马车，有些场地只生产悍马车，这样客户想要什么样的车就找对应的车工厂去提货。— 工厂方法模式 客户的需求逐渐升级，不同型号的车具有不同配置，所以每一个具体工厂应该具备生产不同型号车辆的能力，奥迪的工厂不仅能生产A4，也能生产A6、A8。所以一个工厂应该具备生产不同型号车辆的生产车间—抽象工厂模式 几种工厂模式的实现简单工厂 定义一个工厂类，根据传入的参数不同返回不同的实例。 123public interface Shape &#123; void draw();&#125; 123456public class RectShape implements Shape &#123; @Override public void draw() &#123; System.out.println("draw rectangle"); &#125;&#125; 123456public class CircleShape implements Shape &#123; @Override public void draw() &#123; System.out.println("draw circle"); &#125;&#125; 12345678910111213141516171819public class ShapeFactory &#123; public static Shape getShape(String type)&#123; Shape shape = null; if("circle".equalsIgnoreCase(type))&#123; shape = new CircleShape(); &#125;else if("rectangle".equalsIgnoreCase(type))&#123; shape = new RectShape(); &#125; return shape; &#125; public static void main(String[] args) &#123; Shape circle = ShapeFactory.getShape("circle"); circle.draw(); Shape rectangle = ShapeFactory.getShape("rectangle"); rectangle.draw(); &#125;&#125; 应用场景： 只有一个工厂类，对于创建对象不多的案例比较适合 工厂类封装了对象的创建过程，客户端不需要关心对象的创建过程。 工厂方法 简单工厂的深入化， 通过创建不同的对象工厂来取代统一的工厂。让子类来决定哪一个类实例化，让一个类的实例化延迟到子类。 案例：有一个图片加载器，可以加载jpg、png、gif等图片格式， 123456/** * 图片加载器接口 */public interface Reader &#123; void read();&#125; 12345678910/** * * gif 图片加载器 */public class GifReader implements Reader&#123; @Override public void read() &#123; System.out.println("gif picture reader"); &#125;&#125; 12345678910/** * * png 图片加载器 */public class PngReader implements Reader&#123; @Override public void read() &#123; System.out.println("png picture reader"); &#125;&#125; 12345678910/** * * jpg 图片加载器 */public class JpgReader implements Reader&#123; @Override public void read() &#123; System.out.println("jpg picture reader"); &#125;&#125; 123456789/** * gif 图片加载器工厂 */public class GifReaderFactory implements ReaderFactory&#123; @Override public Reader getReader() &#123; return new GifReader(); &#125;&#125; 123456789/** * jpg 图片加载器工厂 */public class JpgReaderFactory implements ReaderFactory&#123; @Override public Reader getReader() &#123; return new JpgReader(); &#125;&#125; 123456789/** * png 图片加载器工厂 */public class PngReaderFactory implements ReaderFactory &#123; @Override public Reader getReader() &#123; return new PngReader(); &#125;&#125; 12345678910111213141516171819/** * 客户端 */public class Client &#123; public static void main(String[] args) &#123; GifReaderFactory gifReaderFactory = new GifReaderFactory(); Reader gifReader = gifReaderFactory.getReader(); gifReader.read(); PngReaderFactory pngReaderFactory = new PngReaderFactory(); Reader pngReader = pngReaderFactory.getReader(); pngReader.read(); JpgReaderFactory jpgReaderFactory = new JpgReaderFactory(); Reader jpgReader = jpgReaderFactory.getReader(); jpgReader.read(); &#125;&#125; 工厂方法模式优点 良好的封装性。调用者需要创建一个产品对象，只需要知道产品工厂的类名就可以了，不要了解对象创建过程，降低模块间的耦合。 良好的扩展性。当有新增产品类的需求变化，只要适当扩展一个工厂类就可以完成拥抱变化 屏蔽产品类。产品类如何变化，调用者不需要关心—切换数据源（数据库从MySQL切换到Oracle,需要改动的只是切换一下驱动名称） 典型的解耦框架。 高层模块需要知道产品抽象类，不关心实现类—迪米特法则 只依赖产品类的抽象 — 依赖倒置原则 产品子类替换产品父类 — 里氏替换原则 应用场景 所以生成对象的地方都可以使用工厂方法模式，但是要权衡增加工厂类进行管理带来的代码复杂度 需要灵活、可扩展的框架是，可以采用工厂方法模式 客户端不需要知道它所创建对象的类，只需要知道创建的工厂名就可以完成创建过程 抽象工厂 为创建一组相关或相互依赖的对象提供一个借口，而无需指定他们的具体类。 案例：设计一个兼容Android、ios、Wp三个操作系统的游戏，每个系统都有一套操作控制和界面控制器 123456/** * 界面控制器 */public interface UIController &#123; void display();&#125; 123456/** * 操作控制器 */public interface OperationController &#123; void control();&#125; 123456789/** * wp ui controller */public class WpUIController implements UIController &#123; @Override public void display() &#123; System.out.println("wp ui controller"); &#125;&#125; 123456789/** * ios 界面控制器 */public class IosUIController implements UIController &#123; @Override public void display() &#123; System.out.println("ios ui controller"); &#125;&#125; 123456789/** * 安卓界面控制器 */public class AndroidUIController implements UIController&#123; @Override public void display() &#123; System.out.println("android ui controller"); &#125;&#125; 123456789/** * wp 操作控制器 */public class WpOperationController implements OperationController &#123; @Override public void control() &#123; System.out.println("wp operation controller"); &#125;&#125; 123456789/** * ios 操作控制器 */public class IosOperationController implements OperationController &#123; @Override public void control() &#123; System.out.println("ios operation controller"); &#125;&#125; 123456789/** * 安卓操作控制器 */public class AndroidOperationController implements OperationController&#123; @Override public void control() &#123; System.out.println("android opration controller"); &#125;&#125; 1234public interface SystemFactory &#123; OperationController createOperationController(); UIController createUIController();&#125; 1234567891011121314/** * ios 工厂 */public class IosFactory implements SystemFactory &#123; @Override public OperationController createOperationController() &#123; return new IosOperationController(); &#125; @Override public UIController createUIController() &#123; return new IosUIController(); &#125;&#125; 1234567891011121314/** * wp 工厂 */public class WpFactory implements SystemFactory&#123; @Override public OperationController createOperationController() &#123; return new WpOperationController(); &#125; @Override public UIController createUIController() &#123; return new WpUIController(); &#125;&#125; 1234567891011121314/** * 安卓工厂 */public class AndroidFactory implements SystemFactory &#123; @Override public OperationController createOperationController() &#123; return new AndroidOperationController(); &#125; @Override public UIController createUIController() &#123; return new AndroidUIController(); &#125;&#125; 123456789101112131415161718192021222324public class Client &#123; public static void main(String[] args) &#123; AndroidFactory androidFactory = new AndroidFactory(); OperationController androidOperation = androidFactory.createOperationController(); androidOperation.control(); UIController androidUI = androidFactory.createUIController(); androidUI.display(); IosFactory iosFactory = new IosFactory(); OperationController iosOperation = iosFactory.createOperationController(); iosOperation.control(); UIController iosUI = iosFactory.createUIController(); iosUI.display(); WpFactory wpFactory = new WpFactory(); OperationController wpOperation = wpFactory.createOperationController(); wpOperation.control(); UIController wpUI = wpFactory.createUIController(); wpUI.display(); &#125;&#125; 优点 封装性。高层模块不需要关心产品实现类 缺点 产品族扩展困难,当要新增一个控制器，所有的实现类都要改变—违反开闭原则，改变了契约，所有与契约有关系的代码都要改变 应用场景 不关心对象创建过程 需要一组对象功能完成某种功能 系统结构稳定，不会频繁的增加产品族功能，增加产品族功能就回修改原有代码，不符合开闭原则。 注意产品族扩展困难(增加控制器)，但是产品扩展容易(增加小米系统的支持)，也就是纵向扩展困难，横向扩展容易，从产品横向扩展来说，抽象工厂模式是符合开闭原则的 参考文档 https://juejin.im/entry/58f5e080b123db2fa2b3c4c6]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于单例模式的几种变体形式]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式是一种简单的的设计模式。虽然简单，但是应用却是十分的广泛。所有有必要针对单例模式的知识点进行梳理。 单例模式 确保类只有一个实例，并自动实例化向整个系统提供全局的访问点。从定义上可以推断出单例模式更倾向于节约资源，利于资源的重用从而节约时间。所以应用单例模式的对象应该具有以下特点： 频繁地创建、销毁且性能无法优化 消耗大量资源（读取配置、产生依赖对象），可以在应用启动时直接产生一个单例对象 避免资源的多重占用 设置全局的访问点，优化和共享资源访问 应用场景单例模式设计的几点考虑 延迟加载 线程安全 并发性能 序列化/反序列化安全 name 延迟加载 线程安全 并发性能 序列化/反序列化安全 饿汉式 N Y Y N 懒汉式(不加锁) Y N Y N 懒汉式(加锁) Y Y N N DCL Y Y Y N 静态内部类 Y Y Y N 枚举 N Y Y Y 单例模式实现 饿汉式 类加载时完成初始化 类加载慢 获取对象速度快 123456789public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return singleton; &#125;&#125; 懒汉式 获取对象的时候完成初始化，实现懒加载。但是线程不安全，高并发下会出现多个实例。123456789101112public class Singleton &#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if( instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉式（加锁） 线程安全的懒汉式单例模式。 1234567891011121314public class SafeSingleton &#123; private static SafeSingleton instance = null; private SafeSingleton()&#123;&#125; public static synchronized SafeSingleton getInstance()&#123; if(instance == null)&#123; instance = new SafeSingleton(); &#125; return instance; &#125;&#125; 双重检查DCL synchronized同步代码块保证只创建一个对象。 条件判断使对象创建过后，不在进入同步块，减少锁的粒度。 volatitle防止指令重排序(否则出现一个线程创建一般的对象呗另一个线程访问，造成空指针)。 12345678910111213141516public class Singleton &#123; private volatile static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized (Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类 利用ClassLoader的机制保证了线程安全 相比饿汉式单例模式，实现懒加载，只有显示调用SingleHolder才会触发初始化。 1234567891011121314public class Singleton &#123; private static class SingletonHolder&#123; private static final Singleton instance = new Singleton(); &#125; private Singleton()&#123;&#125; public static final Singleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 枚举 线程安全（虚拟机加载枚举的时候，会使用ClassLoader的loadClass方法，这个方法使用同步代码块保证线程安全） 解决反序列化破坏单例的问题: 普通序列化过程中，通过反射调用默认构造函数来初始化对象，反序列化的对象是新建的 枚举的反序列化不是通过构造函数实现，因此不会发生于由于反序列化导致的单例破坏问题 1234567public enum Singleton &#123; INSTANCE; public void getInstance()&#123; &#125;&#125; 如何设计优秀的单例模式引申 双重校验DCL为什么使用volatile synchronized与volatile的区别]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单一职责原则]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[单一职责原则应该有且只有一个原因引起累的变更。 一个例子去理解单一职责原则12345678public interface IPhone &#123; //接通 public void dial(String phoneNumber); //聊天 public void chat(Object o); //挂断 public void hangup();&#125; 定义了一个Iphone的接口，包含了电话的三个功能，接通、聊天、挂断。 试想一下这个接口符合单一职责原则吗？（一个类或者接口只有一个原因引起变化） 很明显，IPhone包括了两个职责,应该设计成两个接口。 信号的接通与果断 通话（数据传输） 12345public interface IConnectionManager &#123; void dial(String phoneNumber); void hangup();&#125; 123public interface IDataTransfer &#123; void transfer();&#125; 单一职责原则的好处 降低类的复杂度，职责清晰、明确 复杂度降低，可读性提高 可维护性提高 变更的风险降低 职责没有量化的标准类的单一职责原则受非常多的网因素制约，从理论上是非常优秀，但从实际的角度上来讲，单一职责原却难以落地。类职责的划分没有量化的标准，因为职责和变化原因都是不可度量的，因项目而异，因环境而异。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迪米特法则|如何降低类间耦合]]></title>
    <url>%2F2019%2F03%2F22%2F%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%2F</url>
    <content type="text"><![CDATA[软件开发一直在推崇一个概念-低耦合、高内聚。 那什么样的代码设计才算得上低耦合、高内聚的代码。本文通过迪米特法则来讲解一下如何进行低耦合的代码设计。 迪米特法则也叫最小知识原则（Least Knowledge Principle）,即一个类应该对自己需要耦合和调用的类保持最少的认识。也就是一个类对自己依赖的类知道的越少越好。因而迪米特法则应该遵循一下的要义 被依赖者，只应该暴露应该暴露的方法 依赖者，只依赖应该依赖的对象 一个案例David Bock根据迪米特法则给出了一个超市购物的案例。三个关键信息：消费者、钱包、收银员定义了三个类，分别是Customer、Wallet、PaperBoy1234567891011121314public class Customer &#123; private String firstName; private String lastName; private Wallet myWallet; public String getFirstName()&#123; return firstName; &#125; public String getLastName()&#123; return lastName; &#125; public Wallet getWallet()&#123; return myWallet; &#125;&#125; 123456789101112131415public class Wallet &#123; private float value; public float getTotalMoney() &#123; return value; &#125; public void setTotalMoney(float newValue) &#123; value = newValue; &#125; public void addMoney(float deposit) &#123; value += deposit; &#125; public void subtractMoney(float debit) &#123; value -= debit; &#125;&#125; 12345678910public class Paperboy &#123; public void charge(Customer myCustomer, double payment) &#123; Wallet theWallet = myCustomer.getWallet(); if (theWallet.getTotalMoney() &gt; payment) &#123; theWallet.subtractMoney(payment); &#125; else &#123; //money not enough &#125; &#125;&#125; 从这三个类可以看出， PaperBoy承担了大多数的功能实现。PaperBoy从消费者那里拿到了钱包，核点钱包的的金钱并自己从中拿去购物的费用。paperBoy既与Customer发生直接交互，又与Wallet发生间接交互，不符合最小知识原则（迪米特法则）。案例主要存在以下问题 Wallet暴露太多方法，其实Customer只要能够用钱包进行付钱就行了。所以这违反了迪米特法则的第一条（被依赖者，只暴露应该暴露的方法） 让PaperBoy与Wallet直接交互是错误的行为，Wallet是Customer的私有财物，ParperBoy是无权过问Wallet的情况的， 所以从职责的角度上来看，这是不符合逻辑，违反了迪米特法则的第二条（依赖者，只依赖应该依赖的对象） 如何进行修改 PaperBoy不再与钱包发生直接关系，直接向customer要钱 钱包只暴露付钱的方法给Customer。 方法暴露越多，后期需求变更的影响越大。 1234567891011public class PaperBoy &#123; private Customer customer; public PaperBoy(Customer customer)&#123; this.customer = customer; &#125; public void charge(float payment)&#123; customer.pay(payment); &#125;&#125; 12345678910111213141516171819202122public class Customer &#123; private String firstName; private String lastName; private Wallet myWallet; public Customer(String firstName, String lastName, Wallet myWallet) &#123; this.firstName = firstName; this.lastName = lastName; this.myWallet = myWallet; &#125; public String getFirstName()&#123; return firstName; &#125; public String getLastName()&#123; return lastName; &#125; public void pay(float payment)&#123; myWallet.pay(payment); &#125;&#125; 1234567891011121314151617181920212223public class Wallet &#123; private float value; private float getTotalMoney() &#123; return value; &#125; public void setTotalMoney(float newValue) &#123; value = newValue; &#125; private void addMoney(float deposit) &#123; value += deposit; &#125; private void subtractMoney(float debit) &#123; value -= debit; &#125; public void pay(float payment)&#123; if(getTotalMoney()&gt;payment)&#123; subtractMoney(payment); &#125;else &#123; &#125; &#125;&#125; 迪米特法则核心观念— 类间解耦、弱耦合]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[里氏替换原则]]></title>
    <url>%2F2019%2F03%2F22%2F%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[里氏替换原则继承作为面向对象设计的重要手段，具有以下的特点 优点 代码共享，减少重复工作 提高代码复用性 子类形似于父类而区别于父类 提高代码扩展性 缺点 代码侵入性，继承必须拥有父类的所有方法 降低代码灵活性，子类必须拥有父类的属性和方法 增强了耦合性，当父类被改变时，需要考虑到子类的修改 什么叫里氏替换原则 所有引用基类的地方必须能够透明的使用其子类的对象（） 由此里氏替换原则是为继承定义的一个规范 子类必完全实现父类的方法 子类可以有自己独特的个性 覆盖或者实现父类的方法时，输入参数可以被放大 覆盖或实现父类方法时，输出结果可以被缩小]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口隔离原则|]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[什么是接口隔离原则 客户端不应该依赖它不需要的接口 类间的依赖关系应该建立在最小的接口上 总的来说，就是建立单一的接口，不要建立臃肿庞大的接口，接口尽量细化，接口的方法尽量少]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开闭原则|]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
</search>

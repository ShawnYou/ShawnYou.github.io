<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2019%2F04%2F03%2FbuildPattern%2F</url>
    <content type="text"><![CDATA[建造者模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板模式]]></title>
    <url>%2F2019%2F03%2F25%2FtemplateMethod%2F</url>
    <content type="text"><![CDATA[模板方法模式 定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤 如何理解模板模式在我们的认识中，模板就是一些约定俗成的东西，是一些自然而然的事物规律。当我们想要解决一些具有模板规律的事情的时候，手中的模板就是一个个整齐待发的磨具，能够轻松进行重复制造、生产。由此想了想，生活中哪些事情满足模板模式的规律： 制茶，制茶是一个很有讲究的学问。制造茶的流程总是相对固定的。采青-&gt; 萎凋-&gt;发酵-&gt; 杀青 -&gt; 揉捻 -&gt; 干燥 -&gt; 初制茶。每个工坊的制作工艺有所差别，有些工坊的手工揉捻做的比较好，有些工坊的萎凋做的比较有特点，所以生产出来的茶叶有所区别。但是他们的总体流程是相对差不多的，都遵循相同的制作模板。 造车，车的总体功能差不多， 能够启动、停止，能够鸣笛、跑路。但是不同型号的车是有所差异的。有些车是手动挡，有些是自动挡。 我们可以根据这类食物的规律总结一下特点： 具有一个抽象的模板，这个模板决定了这类事物的总体流程规律（父类抽象模板） 不同的事物虽然具有共同的抽象模板，但是彼此有着个性化的差异（个性化子类） 子类的个性化特点能够重新定义整个事物的最终呈现结构，就好比不同的茶叶工坊的制作工艺的差别会导致这个茶叶具有不同销量和名声。不同型号的车会导致车具有不同的价格和市场。 程序是现实世界的抽象，模板模式的类可以总结如下： 抽象模板 基本方法 子类的个性化方法，由子类去实现，如制茶过程中每一个环节（发酵…） 模板方法 对基本方法的调度，已完成固定的逻辑。如制茶这样的模板方法就是将制茶每个环节的调度，完成造茶这么一个逻辑。 注意： 基本方法尽量设计成protected类型，符合迪米特法则，若非必要，尽量不要扩大父类的访问权限。 模板方法一般设计成final类型，不要被覆写 为什么要用模板模式 封装不变部分，扩展可变部分 不变的流程规律由父类来实现，而可变的每个环节由子类来控制。 提取公共部分代码，便于维护 行为由父类控制、子类实现 基本方法由子类实现，子类可以通过扩展类来增加相应功能，符合开闭原则。 模板模式实现 模板模式也有缺陷 四思维方式与以往有所不同，不好理解。 常规思路: 抽象类-&gt;最抽象、最一般的事物属性和方法 具体类-&gt;具体的事物属性和方法 模板模式思路： 抽象类-&gt;定义部分抽象方法 实现类-&gt;子类的执行结果对父类结构产生影响 总结一下 模板模式的扩展–钩子函数的应用由子类的一个方法返回值来决定公共部分的执行结果 引申 父类怎么调用子类的方法 子类传递到父类的有参构造中 反射 父类调用子类的静态方法 其实模板模式就间接的实现了父类依赖子类的场景 父类建立框架-&gt;子类重写父类 -&gt; 调用父类继承方法-&gt; 影响父类结果]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式|如何优雅的new对象]]></title>
    <url>%2F2019%2F03%2F24%2Ffactory%2F</url>
    <content type="text"><![CDATA[写在前面在面向对象编程（OOP）中，通过new去实例化一个对象是再正常不过的事情。但是每当new一个对象，后面都会跟一个具体类，这使得代码与具体类过度耦合，让我们陷入面向实现编程的漩涡里面。每当有新的需求变更，我们代码的扩展性就比较差。 手动new对象有哪些问题 与具体类耦合，每当有新的变化，就必须改变代码（不符合对修改关闭） 无法借助接口、多态的力量去隔离变化（与面向接口编程相违背） 如何才能优雅的new对象 对扩展开放，应对后期的各种需求 对修改关闭，对于新的需求，不改变原有的代码 不关心构造对象的细节和复杂过程，轻松获取对象实例 可以通过工厂模式来构造我们想要的对象。 工厂模式是一种常用的创建型设计模式，在基类中定义了创建对象的接口，让子类来决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。 工厂模式包括我们所熟知的简单工厂模式、工厂方法模式、抽象工厂工厂模式。其中简单工厂模式在一定程度上只算是一种编程思想，还谈不上设计模式。但它作为工厂方法模式和抽象工厂模式的基石，还是有必要深入了解一下。 造车案例来了解一下不同的工厂模式 客户想要一辆奔驰车，客户需要奔驰车的设计图纸相应的汽车零件来自己制造。当客户想要悍马车，手上的设计图纸和汽车零件已经毫无用处，需要获取悍马车的设计图纸以及汽车零件（不符合对修改关闭） 客户不需要自己生产汽车，由工厂来提供服务，客户需要什么车，工厂就生产什么车。但是每当客户有新的需求的时候，工厂就得想尽办法去找相关的图纸和零件来交付生产。—简单工厂模式（不符合对修改关闭） 客户的需求太多，一个工厂完全应付不过来，所以工厂就开始建立新的场地，有些场地只生产宝马车，有些场地只生产悍马车，这样客户想要什么样的车就找对应的车工厂去提货。— 工厂方法模式 客户的需求逐渐升级，不同型号的车具有不同配置，所以每一个具体工厂应该具备生产不同型号车辆的能力，奥迪的工厂不仅能生产A4，也能生产A6、A8。所以一个工厂应该具备生产不同型号车辆的生产车间—抽象工厂模式 几种工厂模式的实现简单工厂 定义一个工厂类，根据传入的参数不同返回不同的实例。123public interface Shape &#123; void draw();&#125; 123456public class RectShape implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;draw rectangle&quot;); &#125;&#125; 123456public class CircleShape implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;draw circle&quot;); &#125;&#125; 12345678910111213141516171819public class ShapeFactory &#123; public static Shape getShape(String type)&#123; Shape shape = null; if(&quot;circle&quot;.equalsIgnoreCase(type))&#123; shape = new CircleShape(); &#125;else if(&quot;rectangle&quot;.equalsIgnoreCase(type))&#123; shape = new RectShape(); &#125; return shape; &#125; public static void main(String[] args) &#123; Shape circle = ShapeFactory.getShape(&quot;circle&quot;); circle.draw(); Shape rectangle = ShapeFactory.getShape(&quot;rectangle&quot;); rectangle.draw(); &#125;&#125; 应用场景： 只有一个工厂类，对于创建对象不多的案例比较适合 工厂类封装了对象的创建过程，客户端不需要关心对象的创建过程。 工厂方法 简单工厂的深入化， 通过创建不同的对象工厂来取代统一的工厂。让子类来决定哪一个类实例化，让一个类的实例化延迟到子类。 案例：有一个图片加载器，可以加载jpg、png、gif等图片格式， 123456/** * 图片加载器接口 */public interface Reader &#123; void read();&#125; 12345678910/** * * gif 图片加载器 */public class GifReader implements Reader&#123; @Override public void read() &#123; System.out.println(&quot;gif picture reader&quot;); &#125;&#125; 12345678910/** * * png 图片加载器 */public class PngReader implements Reader&#123; @Override public void read() &#123; System.out.println(&quot;png picture reader&quot;); &#125;&#125; 12345678910/** * * jpg 图片加载器 */public class JpgReader implements Reader&#123; @Override public void read() &#123; System.out.println(&quot;jpg picture reader&quot;); &#125;&#125; 123456789/** * gif 图片加载器工厂 */public class GifReaderFactory implements ReaderFactory&#123; @Override public Reader getReader() &#123; return new GifReader(); &#125;&#125; 123456789/** * jpg 图片加载器工厂 */public class JpgReaderFactory implements ReaderFactory&#123; @Override public Reader getReader() &#123; return new JpgReader(); &#125;&#125; 123456789/** * png 图片加载器工厂 */public class PngReaderFactory implements ReaderFactory &#123; @Override public Reader getReader() &#123; return new PngReader(); &#125;&#125; 12345678910111213141516171819/** * 客户端 */public class Client &#123; public static void main(String[] args) &#123; GifReaderFactory gifReaderFactory = new GifReaderFactory(); Reader gifReader = gifReaderFactory.getReader(); gifReader.read(); PngReaderFactory pngReaderFactory = new PngReaderFactory(); Reader pngReader = pngReaderFactory.getReader(); pngReader.read(); JpgReaderFactory jpgReaderFactory = new JpgReaderFactory(); Reader jpgReader = jpgReaderFactory.getReader(); jpgReader.read(); &#125;&#125; 工厂方法模式优点 良好的封装性。调用者需要创建一个产品对象，只需要知道产品工厂的类名就可以了，不要了解对象创建过程，降低模块间的耦合。 良好的扩展性。当有新增产品类的需求变化，只要适当扩展一个工厂类就可以完成拥抱变化 屏蔽产品类。产品类如何变化，调用者不需要关心—切换数据源（数据库从MySQL切换到Oracle,需要改动的只是切换一下驱动名称） 典型的解耦框架。 高层模块需要知道产品抽象类，不关心实现类—迪米特法则 只依赖产品类的抽象 — 依赖倒置原则 产品子类替换产品父类 — 里氏替换原则 应用场景 所以生成对象的地方都可以使用工厂方法模式，但是要权衡增加工厂类进行管理带来的代码复杂度 需要灵活、可扩展的框架是，可以采用工厂方法模式 客户端不需要知道它所创建对象的类，只需要知道创建的工厂名就可以完成创建过程 抽象工厂 为创建一组相关或相互依赖的对象提供一个借口，而无需指定他们的具体类。 案例：设计一个兼容Android、ios、Wp三个操作系统的游戏，每个系统都有一套操作控制和界面控制器 123456/** * 界面控制器 */public interface UIController &#123; void display();&#125; 123456/** * 操作控制器 */public interface OperationController &#123; void control();&#125; 123456789/** * wp ui controller */public class WpUIController implements UIController &#123; @Override public void display() &#123; System.out.println(&quot;wp ui controller&quot;); &#125;&#125; 123456789/** * ios 界面控制器 */public class IosUIController implements UIController &#123; @Override public void display() &#123; System.out.println(&quot;ios ui controller&quot;); &#125;&#125; 123456789/** * 安卓界面控制器 */public class AndroidUIController implements UIController&#123; @Override public void display() &#123; System.out.println(&quot;android ui controller&quot;); &#125;&#125; 123456789/** * wp 操作控制器 */public class WpOperationController implements OperationController &#123; @Override public void control() &#123; System.out.println(&quot;wp operation controller&quot;); &#125;&#125; 123456789/** * ios 操作控制器 */public class IosOperationController implements OperationController &#123; @Override public void control() &#123; System.out.println(&quot;ios operation controller&quot;); &#125;&#125; 123456789/** * 安卓操作控制器 */public class AndroidOperationController implements OperationController&#123; @Override public void control() &#123; System.out.println(&quot;android opration controller&quot;); &#125;&#125; 1234public interface SystemFactory &#123; OperationController createOperationController(); UIController createUIController();&#125; 1234567891011121314/** * ios 工厂 */public class IosFactory implements SystemFactory &#123; @Override public OperationController createOperationController() &#123; return new IosOperationController(); &#125; @Override public UIController createUIController() &#123; return new IosUIController(); &#125;&#125; 1234567891011121314/** * wp 工厂 */public class WpFactory implements SystemFactory&#123; @Override public OperationController createOperationController() &#123; return new WpOperationController(); &#125; @Override public UIController createUIController() &#123; return new WpUIController(); &#125;&#125; 1234567891011121314/** * 安卓工厂 */public class AndroidFactory implements SystemFactory &#123; @Override public OperationController createOperationController() &#123; return new AndroidOperationController(); &#125; @Override public UIController createUIController() &#123; return new AndroidUIController(); &#125;&#125; 123456789101112131415161718192021222324public class Client &#123; public static void main(String[] args) &#123; AndroidFactory androidFactory = new AndroidFactory(); OperationController androidOperation = androidFactory.createOperationController(); androidOperation.control(); UIController androidUI = androidFactory.createUIController(); androidUI.display(); IosFactory iosFactory = new IosFactory(); OperationController iosOperation = iosFactory.createOperationController(); iosOperation.control(); UIController iosUI = iosFactory.createUIController(); iosUI.display(); WpFactory wpFactory = new WpFactory(); OperationController wpOperation = wpFactory.createOperationController(); wpOperation.control(); UIController wpUI = wpFactory.createUIController(); wpUI.display(); &#125;&#125; 优点 封装性。高层模块不需要关心产品实现类 缺点 产品族扩展困难,当要新增一个控制器，所有的实现类都要改变—违反开闭原则，改变了契约，所有与契约有关系的代码都要改变 应用场景 不关心对象创建过程 需要一组对象功能完成某种功能 系统结构稳定，不会频繁的增加产品族功能，增加产品族功能就回修改原有代码，不符合开闭原则。 注意产品族扩展困难(增加控制器)，但是产品扩展容易(增加小米系统的支持)，也就是纵向扩展困难，横向扩展容易，从产品横向扩展来说，抽象工厂模式是符合开闭原则的 参考文档 https://juejin.im/entry/58f5e080b123db2fa2b3c4c6]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于单例模式的几种变体形式]]></title>
    <url>%2F2019%2F03%2F23%2Fsingleton%2F</url>
    <content type="text"><![CDATA[单例模式是一种简单的的设计模式。虽然简单，但是应用却是十分的广泛。所有有必要针对单例模式的知识点进行梳理。 单例模式 确保类只有一个实例，并自动实例化向整个系统提供全局的访问点。从定义上可以推断出单例模式更倾向于节约资源，利于资源的重用从而节约时间。所以应用单例模式的对象应该具有以下特点： 频繁地创建、销毁且性能无法优化 消耗大量资源（读取配置、产生依赖对象），可以在应用启动时直接产生一个单例对象 避免资源的多重占用 设置全局的访问点，优化和共享资源访问 应用场景单例模式设计的几点考虑 延迟加载 线程安全 并发性能 序列化/反序列化安全 name 延迟加载 线程安全 并发性能 序列化/反序列化安全 饿汉式 N Y Y N 懒汉式(不加锁) Y N Y N 懒汉式(加锁) Y Y N N DCL Y Y Y N 静态内部类 Y Y Y N 枚举 N Y Y Y 单例模式实现 饿汉式 类加载时完成初始化 类加载慢 获取对象速度快 123456789public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return singleton; &#125;&#125; 懒汉式 获取对象的时候完成初始化，实现懒加载。但是线程不安全，高并发下会出现多个实例。123456789101112public class Singleton &#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if( instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉式（加锁） 线程安全的懒汉式单例模式。 1234567891011121314public class SafeSingleton &#123; private static SafeSingleton instance = null; private SafeSingleton()&#123;&#125; public static synchronized SafeSingleton getInstance()&#123; if(instance == null)&#123; instance = new SafeSingleton(); &#125; return instance; &#125;&#125; 双重检查DCL synchronized同步代码块保证只创建一个对象。 条件判断使对象创建过后，不在进入同步块，减少锁的粒度。 volatitle防止指令重排序(否则出现一个线程创建一般的对象呗另一个线程访问，造成空指针)。 12345678910111213141516public class Singleton &#123; private volatile static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized (Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类 利用ClassLoader的机制保证了线程安全 相比饿汉式单例模式，实现懒加载，只有显示调用SingleHolder才会触发初始化。 1234567891011121314public class Singleton &#123; private static class SingletonHolder&#123; private static final Singleton instance = new Singleton(); &#125; private Singleton()&#123;&#125; public static final Singleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 枚举 线程安全（虚拟机加载枚举的时候，会使用ClassLoader的loadClass方法，这个方法使用同步代码块保证线程安全） 解决反序列化破坏单例的问题: 普通序列化过程中，通过反射调用默认构造函数来初始化对象，反序列化的对象是新建的 枚举的反序列化不是通过构造函数实现，因此不会发生于由于反序列化导致的单例破坏问题 1234567public enum Singleton &#123; INSTANCE; public void getInstance()&#123; &#125;&#125; 如何设计优秀的单例模式引申 双重校验DCL为什么使用volatile synchronized与volatile的区别]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单一职责原则]]></title>
    <url>%2F2019%2F03%2F22%2FsingleResponsibility%2F</url>
    <content type="text"><![CDATA[单一职责原则应该有且只有一个原因引起累的变更。 一个例子去理解单一职责原则12345678public interface IPhone &#123; //接通 public void dial(String phoneNumber); //聊天 public void chat(Object o); //挂断 public void hangup();&#125; 定义了一个Iphone的接口，包含了电话的三个功能，接通、聊天、挂断。 试想一下这个接口符合单一职责原则吗？（一个类或者接口只有一个原因引起变化） 很明显，IPhone包括了两个职责,应该设计成两个接口。 信号的接通与果断 通话（数据传输） 12345public interface IConnectionManager &#123; void dial(String phoneNumber); void hangup();&#125; 123public interface IDataTransfer &#123; void transfer();&#125; 单一职责原则的好处 降低类的复杂度，职责清晰、明确 复杂度降低，可读性提高 可维护性提高 变更的风险降低 职责没有量化的标准类的单一职责原则受非常多的网因素制约，从理论上是非常优秀，但从实际的角度上来讲，单一职责原却难以落地。类职责的划分没有量化的标准，因为职责和变化原因都是不可度量的，因项目而异，因环境而异。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迪米特法则|如何降低类间耦合]]></title>
    <url>%2F2019%2F03%2F22%2Fdimite%2F</url>
    <content type="text"><![CDATA[软件开发一直在推崇一个概念-低耦合、高内聚。 那什么样的代码设计才算得上低耦合、高内聚的代码。本文通过迪米特法则来讲解一下如何进行低耦合的代码设计。 迪米特法则也叫最小知识原则（Least Knowledge Principle）,即一个类应该对自己需要耦合和调用的类保持最少的认识。也就是一个类对自己依赖的类知道的越少越好。因而迪米特法则应该遵循一下的要义 被依赖者，只应该暴露应该暴露的方法 依赖者，只依赖应该依赖的对象 一个案例David Bock根据迪米特法则给出了一个超市购物的案例。三个关键信息：消费者、钱包、收银员定义了三个类，分别是Customer、Wallet、PaperBoy1234567891011121314public class Customer &#123; private String firstName; private String lastName; private Wallet myWallet; public String getFirstName()&#123; return firstName; &#125; public String getLastName()&#123; return lastName; &#125; public Wallet getWallet()&#123; return myWallet; &#125;&#125; 123456789101112131415public class Wallet &#123; private float value; public float getTotalMoney() &#123; return value; &#125; public void setTotalMoney(float newValue) &#123; value = newValue; &#125; public void addMoney(float deposit) &#123; value += deposit; &#125; public void subtractMoney(float debit) &#123; value -= debit; &#125;&#125; 12345678910public class Paperboy &#123; public void charge(Customer myCustomer, double payment) &#123; Wallet theWallet = myCustomer.getWallet(); if (theWallet.getTotalMoney() &gt; payment) &#123; theWallet.subtractMoney(payment); &#125; else &#123; //money not enough &#125; &#125;&#125; 从这三个类可以看出， PaperBoy承担了大多数的功能实现。PaperBoy从消费者那里拿到了钱包，核点钱包的的金钱并自己从中拿去购物的费用。paperBoy既与Customer发生直接交互，又与Wallet发生间接交互，不符合最小知识原则（迪米特法则）。案例主要存在以下问题 Wallet暴露太多方法，其实Customer只要能够用钱包进行付钱就行了。所以这违反了迪米特法则的第一条（被依赖者，只暴露应该暴露的方法） 让PaperBoy与Wallet直接交互是错误的行为，Wallet是Customer的私有财物，ParperBoy是无权过问Wallet的情况的， 所以从职责的角度上来看，这是不符合逻辑，违反了迪米特法则的第二条（依赖者，只依赖应该依赖的对象） 如何进行修改 PaperBoy不再与钱包发生直接关系，直接向customer要钱 钱包只暴露付钱的方法给Customer。 方法暴露越多，后期需求变更的影响越大。 1234567891011public class PaperBoy &#123; private Customer customer; public PaperBoy(Customer customer)&#123; this.customer = customer; &#125; public void charge(float payment)&#123; customer.pay(payment); &#125;&#125; 12345678910111213141516171819202122public class Customer &#123; private String firstName; private String lastName; private Wallet myWallet; public Customer(String firstName, String lastName, Wallet myWallet) &#123; this.firstName = firstName; this.lastName = lastName; this.myWallet = myWallet; &#125; public String getFirstName()&#123; return firstName; &#125; public String getLastName()&#123; return lastName; &#125; public void pay(float payment)&#123; myWallet.pay(payment); &#125;&#125; 1234567891011121314151617181920212223public class Wallet &#123; private float value; private float getTotalMoney() &#123; return value; &#125; public void setTotalMoney(float newValue) &#123; value = newValue; &#125; private void addMoney(float deposit) &#123; value += deposit; &#125; private void subtractMoney(float debit) &#123; value -= debit; &#125; public void pay(float payment)&#123; if(getTotalMoney()&gt;payment)&#123; subtractMoney(payment); &#125;else &#123; &#125; &#125;&#125; 迪米特法则核心观念— 类间解耦、弱耦合]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[里氏替换原则]]></title>
    <url>%2F2019%2F03%2F22%2FparentReplace%2F</url>
    <content type="text"><![CDATA[里氏替换原则继承作为面向对象设计的重要手段，具有以下的特点 优点 代码共享，减少重复工作 提高代码复用性 子类形似于父类而区别于父类 提高代码扩展性 缺点 代码侵入性，继承必须拥有父类的所有方法 降低代码灵活性，子类必须拥有父类的属性和方法 增强了耦合性，当父类被改变时，需要考虑到子类的修改 什么叫里氏替换原则 所有引用基类的地方必须能够透明的使用其子类的对象（） 由此里氏替换原则是为继承定义的一个规范 子类必完全实现父类的方法 子类可以有自己独特的个性 覆盖或者实现父类的方法时，输入参数可以被放大 覆盖或实现父类方法时，输出结果可以被缩小]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口隔离原则|]]></title>
    <url>%2F2019%2F03%2F22%2FinterfaceIsolate%2F</url>
    <content type="text"><![CDATA[什么是接口隔离原则 客户端不应该依赖它不需要的接口 类间的依赖关系应该建立在最小的接口上 总的来说，就是建立单一的接口，不要建立臃肿庞大的接口，接口尽量细化，接口的方法尽量少]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开闭原则|]]></title>
    <url>%2F2019%2F03%2F22%2FopenClose%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
</search>

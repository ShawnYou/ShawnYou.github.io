<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何决定用组合还是继承]]></title>
    <url>%2F2019%2F12%2F01%2Fdesign-pattern-notes%2F10%7C%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E7%94%A8%E7%BB%84%E5%90%88%E8%BF%98%E6%98%AF%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[组合优于继承，多用组合，少用继承 继承 面向对象四个特性之一，用来表示is-a的关系，解决代码复用的问题 不足 继承层次过深，过复杂。 不利于后期需求的变更，影响代码的可扩展性。 代码的可读性变差，需要弄清楚某个类需要哪些方法，必须阅读所有父类的代码。 破坏了类的封装性，将父类的实现细节暴露给子类，子类的实现依赖父类的子线，子类和父类高度耦合，一旦父类变化就会影响子类。 案例 鸟的继承体系 有会飞的鸟也有不会飞的鸟，，当父类定义一个fly()的方法，则子类都会拥有飞行的功能，对于鸵鸟，可以重写fly()方法，抛出异常即可，这样虽然可行，但是不够优美，违反最少知识原则，暴露了不该暴露的接口给外部。 后序考虑鸟会不会叫、鸟下不下单等属性，那么继承体系就非常庞大了。 组合 有什么手段可以代替继承，并且避免继承的不足–组合+接口+委托 多态(接口)，运用接口可以实现继承体系中的多态的作用。接口表示某种行为特征，Flyable(可以飞的行为)，EggLayable(可下蛋的行为) 代码复用(组合+委托)，由于每一个会飞的鸟都要去实现Flyable，所有我们可以定义一个实现类，然后通过组合和委托的形式，将Flyable的实现类组合进去 12345678910111213141516171819public interface Flyable&#123; void fly();&#125;public class FlyAbility implement Flyable&#123; public void fly()&#123; .... &#125;&#125;public class Ostrish implements Tweetable,EggLayable&#123; //组合 private TweetAbility tweetAbility = new TweetAbility(); public void tweet()&#123; //委托 tweetAbility.tweet(); &#125;&#125; 如何决定选择组合还是继承组合的不足 更细粒度的类划分，更多的类和接口 增加代码的复杂程度和维护成本 继承的不足 继承层次过深灰降低代码的扩展性 代码可读性差 继承的条件 类之间的继承结构稳定(不会轻易改变) 继承层次浅(2-3层) 继承关系简单 继承和组合在设计模式中的应用 继承(模板模式) 组合(装饰器模式、策略模式、组合模式) 多用组合，少用继承并不是绝对的，需要具体情况具体分析，控制好他们的副作用，发挥他们各自的优势。]]></content>
      <categories>
        <category>design-notes</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05|深入浅出索引(下)]]></title>
    <url>%2F2019%2F11%2F24%2Fmysql-notes%2F05%7C%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[索引分析 select * from T where K betwwen 3 and 5 需要执行几次树的搜索操作？ ID为主键索引，K为普通索引 在K的普通索引树上找到K=3对应的记录，取得对应的主键ID=300值—普通索引 通过主键ID=300查到对应的记录—主键索引(回表) 在K索引树取下一个值K=5,取得主键ID=500—普通索引 根据ID=500取得对应的记录—主键索引(回表) K索引树取下一个值k=6,不满足条件，循环结束—普通索引 这个过程总共搜索了三次普通索引，二次主键索引(回表)。如何优化索引，避免回表过程？可以使用覆盖索引 覆盖索引 select ID from T where K betwwen 3 and 5. 由于查询的返回值通过普通索引就能够获取，所以就不用回表去查主键索引了。能够减少数的搜索次数，提高查询性能。 覆盖索引的使用场景 联合索引 身份证号是市民的唯一表示，而身份证号通常应该建立普通索引，如果有一个需求是通过身份证号查市民的真实姓名，可以建立身份证号和姓名的联合索引，由此可以通过直接在身份证的普通索引上直接搜索到姓名，由此可以避免回表的操作，减少语句执行时间。 最左前缀原则 B+树可以通过索引的最左前缀，来定位记录，由此可以避免为每一种查询都设计一个索引 最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符 联合索引(name,age), 如(“张三”，10)，通过张三可以通过索引检索到记录，通过”张”也可以通过索引检索到记录。 如果通过调配联合索引的字段顺序来减少索引的维护？ 评估索引的复用能力，当已经有了(a,b)的联合索引，就不需要单独在a上面建立索引了。 空间的考虑。如果已经有了(age,name)的索引，因为name的字段比age大，所以我们可以调配字段顺序(name,age),就只需要再加一个age的单字段索引。 索引下推 select * from tuser where name like “张%” and age = 10 and is ismale = 1 对于这样的查询语句，在老版本的mysql中，age和ismale没法通过最左前缀进行匹配。需要回表到主键索引进行过滤。 Mysql5.6之前，通过普通索引找到对应的主键，然后回到主键索引上找到对应的记录，最后去比对字段值去过滤。 Mysql5.6之后，Mysql进行索引下推优化，可以普通索引遍历过程中，对索引包含的字段(age)先作判断，由此在普通索引搜索过程过滤掉不满足条件的记录，减少了回表的次数。]]></content>
      <categories>
        <category>mysql-notes</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03|事务隔离]]></title>
    <url>%2F2019%2F11%2F22%2Fmysql-notes%2F03%7C%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[事务保证一组数据库操作，要么全部成功，要么全部失败。 ACID Atomicity(原子性) Consistency(一致性) Isolation(隔离性) Durability(持久性) 隔离性 为什么需要隔离性 因为多个事务同时执行的时候，容易引发脏读、不可重复读、幻读等问题。 脏读 一个事务在处理过程中，读取了别的事务未提交的脏数据。如果别的事务回滚，那么我们拿到的数据是不准确的，由此会造成一定的问题。 不可重复读一个事务在处理过程，两次查询的数据不一样。这是因为第二次查询读取了别的事务已经提交的变更。那么我们在这个事务操作中就能看到别的事务提交的变更。 幻读一个事务在处理过程中，两次查询的数据不一样，第二次查询读取了别的事务已经提交的变更。 不可重复读和幻读都在还未提交的事务过程中读取了另一个已经提交的事务变更。不可重读读针对的是同一个数据项，而幻读针对的是一批数据整体。例如小编去取钱， 不可重复读：重点在于修改，两次读取的数据不一样 幻读：重点在新增和删除，比如这里有一个事务1要查询公司里面工资1000元以上的职工有10人，这时另一个事务2里面，HR新增了一个新员工，工资也在1000元以上。这时候事务1在次查询，发现工资1000元以上的人员增加到了11个人。 隔离级别 多个事务同时执行，引发的脏读、不可重复读、幻读等问题，就产生了‘隔离级别’的概念。隔离越严实，效率就越低，但数据一致性的程度越高。由此需要在隔离性和效率之间寻找一个平衡点。 读未提交(read uncommitted) 一个事务还未提交的时候，它的变更能被别的事务看到。 读提交(read committed) 一个事务提交之后，它的改动才能被其他事务看到。事务A修改了一项数据，B事务读取不到变动，只有等事务A提交之后，B事务才能够读取。由此可以避免脏读，但是会造成不可重复读和幻读。 可重复读(repeatable read) 一个事务在执行过程中看到的数据和事务启动是看到的数据时一致的。当事务A开始读取一条记录的时候，事务B是不能够进行修改的。由此可以避免不可重复读，但是还是会造成幻读(事务A读取一些数据，事务B插入或者删除一些数据，这时候在此读取，会发现数据多了或者少了)。 串行化(serializable) ‘读’和‘写’会进行加锁，读写锁发生冲突时候，后访问的事务必须等前一个事务执行完成。 视图 事务的隔离级别往往和视图有关系，不同的隔离级别创建视图的顺序是不一样。视图可以理解为数据副本，每次创建视图，将当前已持久化的数据创建副本，后面直接从副本读取，从而达到数据隔离。 读未提交 没有视图概念，不同事务在读未提交的隔离级别上直接读取记录的最新值，容易出现脏读的情况。 读提交 视图在每个SQL开始执行的时候创建的。所以第二次查询的时候，别的事务已经提交了数据，重新建立的视图里面包含已经变更的数据。因此能够读取别的事务修改的数据。 可重复读 视图是在事务启动的时候创建的。（TODO） 串行化 直接用加锁的方式避免并行访问 事务隔离的实现MVCC(多版本并发控制)同一条记录在系统中可以存在多个版本。 避免使用长事务 长事务存在很老的事务视图，在未提交之前，所有的回滚记录都必须保留，会导致大量占用存储空间。 占用锁资源，拖垮数据库。]]></content>
      <categories>
        <category>mysql-notes</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04|深入浅出索引(上)]]></title>
    <url>%2F2019%2F11%2F22%2Fmysql-notes%2F04%7C%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[索引类似于书本的目录，能够提高数据查询效率。 常见的索引模型 哈希表 key-value的数据存储结构。通过哈希函数将key换算成一个具体的数组位置，将value放在对应的数组位置。多余哈希冲突，则使用拉链法进行解决。 插入很快。因为可以直接往后追加 区间查询速度很慢。因为因为数据存储不是有序的。 哈希表适合等值查询的场景(Memcached和一些NoSQL引擎) 有序数组 有序数组在等值查询和范围查询的场景中的性能都非常优秀。 查询效率高，利用二分法进行查询。，同样也支持范围查询 新增记录成本太高，因为每增加一条新纪录，都要挪动后面所有的记录 所以有序数组适合静态存储引擎，如2017年某个城市的所有人口信息。 搜索树 二叉搜索树 左子节点小于父节点，父节点小于右子节点。 查询复杂度：O(log(n))更新时间复杂度：O(log(n)) 数据库为什么不使用二叉树而选择多叉树 （1）二叉树虽然效率高，但是每一层存储的数据量比较少。假如在特别大的数据量的情况下，使用二叉树会导致树的层数非常高。层数越多，访问磁盘的次数越多，磁盘读取往往是性能的瓶颈，所以二叉树的读取性能就回很差。 （2）为了尽量的少读磁盘，让查询过程访问尽量少的数据块，应该使用多叉树。假如一个N=1200的多叉树，树高为4，可以存储1200的三次方的数据(17亿)。也就是在这17亿的数据中，查找一条记录，最多访问磁盘三次。 InnoDB的索引模型 InnoDB的索引模型：B+树索引模型,每一个索引在InnoDB中就对应一棵B+树 B+树索引类型 主键索引(聚簇索引) 叶子节点存储整行数据 普通索引(二级索引) 叶子节点存储的是主键的值 主键索引和非主键索引的区别 通过主键查询的方式，就是直接搜索主键索引这棵B+树。 如果通过普通索引的方式，则是先通过普通索引B+树查询到主键值，再通过主键值去主键索引B+树里面所有(回表) 普通索引会多扫描一次索引，应该优先使用主键索引 索引维护 B+树维护了索引的有效性，当插入新值的时候，就要做必要的维护 页分裂 当插入数据所在页的数据页满了，就要重新申请一个新的数据页，让后再挪动部分数据过去。性能受影响。 页合并 相邻两个数据页因为删除了数据，利用率很低之后，会将数据页进行合并。 自增字段的重要性 索引的维护过程中，会出现页分裂和页合并的现象，这些是比较耗费性能的。所以现在的建表规范里面都要求使用自增字段。那自增字段能够对索引维护起到什么作用吗？ 自增逐渐的插入数据模式都是追加操作，不会涉及挪动其他记录，不会触发叶子节点的分裂。—-性能 如果使用业务字段做主键，不容易保证有序插入，写数据成本高。—-性能 自增逐渐相比业务字段作逐渐节省存储空间。如果使用身份证之类的作为主键，那么普通索引的叶子节点(主键)就会占用比较多的存储空间(字符串20个字节)，整型(4个字节)，长整型(8个字节)。—-存储空间 主键长度约小，普通索引的叶子节点就越小，普通索引占用的空间就越小 业务字段作为主键的场景： 只有一个索引 该索引是唯一索引]]></content>
      <categories>
        <category>mysql-notes</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么基于接口而非实现编程]]></title>
    <url>%2F2019%2F11%2F21%2Fdesign-pattern-notes%2F09%7C%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[基于接口而非实现编程是一种非常高效且提高代码质量的手段。 接口的含义 抽象层面的接口 服务端与客户端之间的“接口” 类库提供的“接口” 通信协议接口 代码接口 编程语言中的接口类或者抽象类 接口的意义 “面向接口而非实现编程”也可以表述为”基于抽象而非实现编程”，抽象是提高代码扩展性、灵活性、可维护性的最优先手段之一。 将接口与实现相分离，封装不稳定的实现，暴露稳定的接口。 抽象、顶层、脱离具体实现的设计可以提高代码的灵活性，应对未来复杂的需求变化。 基于接口而非实现编程的要求 函数命名不能暴露任何实现细节，适配未来的需求变化，应该取一个较为宽泛且概括中心概念的名字。 封装具体实现细节 为实现类定义抽象的接口。使用者依赖接口，而非具体的实现类编程。 接口实现的度 任何事情都要讲一个度,对于基于接口而非实现编程的‘度’应该如何把握呢？哪些可以直接使用实现类进行编程？ 业务场景中，某个功能只有一种实现方式，我来也不可能会被其他方式替代，就没必要设计接口，直接使用实现类 系统特别稳定，基本不做维护，就没必要在扩展性投入不必要的开发时间。]]></content>
      <categories>
        <category>design-notes</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02|一条SQL更新语句是如何执行的]]></title>
    <url>%2F2019%2F11%2F21%2Fmysql-notes%2F02%7C%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%2F</url>
    <content type="text"><![CDATA[执行流程(和查询流程保持一致) 连接器 –&gt; 连接数据库 分析器 –&gt; 词法和语法分析这是一条更新语句 优化器 –&gt; 决定使用哪个索引 执行器 –&gt; 找到具体的某一行，然后更新 日志模块 SQL更新过程中涉及两个重要的日志模块 redo log(重做日志) WHATredo log(重做日志)类似于掌柜账本记账的模式，先记账(先写日志)，后清账(再写磁盘) WHYmysql的每一次更新过程IO成本和查找成本很高。每一次更新操作都要在磁盘中找到对应的记录然后更新。当更新比较频繁的时候，性能就非常的不好。 HOW当一条记录需要更新的时候： InnoDB引擎先把记录写到redo log 更新内存 InnoDB引擎在系统空闲的时候，将操作记录更新到磁盘中 PS： redo log是InnoDB特有的日志 如果更新特别频繁，redo log特别多，系统会放下工作，将一部分redo log的任务更新到磁盘中，为redo log腾出空间 redo log是固定大小的，可以配置一组四个文件，每个文件1GB, 从头开始写，写到末尾然后继续回到开头写 InnoDB 可以依靠redo log保证数据库发生异常重启的时候，之前的记录不会丢失(crash-safe) binlog(归档日志)bin log是server层实现的日志，可以应用于所有存储引擎 redolog与binlog的区别 redolog是InnoDB独有, binlog是Server层实现的，所有引擎都可以使用 redolog是物理日志，记录某个数据页做了什么改动，binlog是逻辑日志，记录语句的原始逻辑 redolog是循环写，空间固定会用完，binlog可以最佳写入，并不会覆盖以前的日志。 update语句执行的内部流程 执行器通过引擎找到对应的记录。如果这一行所在数据页在内存中，引擎就从内存中取，否则就从磁盘读入。 执行器拿到对应的数据，进行更新，然后调用引擎接口写入数据 引擎将数据更新到内存，同时将更新操作记录到redo日志，此时redo log处于prepare状态，告知执行器执行完成。 执行器生成binlog,并将binlog写入磁盘 执行器调用引擎的提交事务接口，引擎将写入的redo log改成提交状态 以上的流程包含了一个两阶段提交 两阶段提交 what保证redolog与binlog的数据逻辑一致性。 先写redolog后写binlogredolog写完，binlog还没写完的时候，MySQL异常重启,可以通过redolog将记录恢复。但是当我们需要通过binlog恢复临时库的时候，由于binlog丢失，临时库的数据会少一次更新操作 先写binlog厚些redologbinlog写完，redolog还没写，系统崩溃之后，由此数据没有被更新。但是binlog已经有了更新的日志，之后用binlog来恢复数据的时候就多了一条更新。]]></content>
      <categories>
        <category>mysql-notes</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01|一条SQL查询语句是如何执行的]]></title>
    <url>%2F2019%2F11%2F20%2Fmysql-notes%2F01%7C%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%2F</url>
    <content type="text"><![CDATA[MySQL基础架构连接器 负责与客户端建立连接。shou processlist (查看连接)长连接内存占用过大OOM如何解决： 定期断开长连接 MySQL5.7以及以上版本，可以在执行完比较大的操作后，通过mysql_reset_connection重新初始化连接资源，使连接恢复到刚刚创建完时的状态。 查询缓存 建立连接后会优先查询缓存，查询缓存弊大于利，MySQL8.0将查询缓存删除。 对于一张经常变更的表，缓存经常被清空，缓存的命中率非常低，对于静态表适合做查询缓存。 按需使用查询缓存。 分析器(分析要做什么) 如何没有命中查询缓存，就要开始执行SQl语句了。 词法分析：识别关键词，如select, from ,table…. 语法分析：根据语法规则判断SQL语句的正确性。 优化器(确定执行方案) 当存在多个索引的时候，决定索引的选择 多表关联的时候，决定多个表的连接顺序执行器 根据选择的存储引擎调用引擎接口从第一行开始比对，直到最后一行找出所有满足条件的记录返回结果集。 慢查询日志：rows_examined(语句执行过程中的扫描行)]]></content>
      <categories>
        <category>mysql-notes</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01|接口与抽象类]]></title>
    <url>%2F2019%2F11%2F20%2Fdesign-pattern-notes%2F08%7C%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[接口和抽象类是很多设计模式、设计思想、设计原则编程实现的基础。 抽象类 不允许被实例化 抽象类包含属性和方法。其中方法可以包含代码实现，也可以不包含代码实现(抽象方法) 子类集成抽象类。子类必须实现抽象类的抽象方法。 接口类 接口不能包含属性(成员变量) 接口只能声明方法，方法不能包含方法实现 类实现接口的时候，必须实现接口的所有方法。 抽象类与接口类的区别 抽象类的本质是类，主要只能被子类去继承，体现着is-a的继承关系 接口类表示一种has-a的关系，体现具有某些功能，表现为一种约定和协议。 抽象类和接口类能解决什么问题抽象类 代码复用，避免在子类中编写相同的代码 同样是代码复用，为什么不直接用继承，而要使用抽象类来实现？相比继承来说，抽象类的实现更加的优雅 父类中定义一个被子类继承的无意义的log()方法会使代码的可读性变差。 创建子类的时候，会忘记重写log()。然而抽象类会强制子类实现。 继承中，父类是可以被实例化的，我们可以调用空的log()方法，会增加类误用的风险。(可以通过设置私有构造函数解决) 接口类 侧重于解耦。对行为进行抽象，之关系接口的协议，不关心具体实现，实现约定与实现相分离。 模拟接口类和抽象类模拟接口类 普通类模拟接口类 protect访问权限，避免类被实例化 不含具体实现的方法 123456public class MockInteface &#123; protected MockInteface() &#123;&#125; public void funcA() &#123; throw new MethodUnSupportedException(); &#125;&#125; 抽象类和接口类的使用 抽象类：is-a的关系，解决代码复用的问题 接口类：has-a的关系，解决耦合的问题，表示一组行为特征，隔离接口和具体实现]]></content>
      <categories>
        <category>design-notes</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式|手写一个迭代器]]></title>
    <url>%2F2019%2F10%2F22%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[迭代器模式我们在日常的开发中，特别是在使用集合的过程中都或多或少使用了迭代器来对集合进行遍历。这时候我们就会思考一个问题，明明简单的For循环就能解决的集合遍历问题，我们非得创造一个迭代器来进行集合的遍历，使用迭代器来遍历到底有什么不一样的地方吗？本着‘存在即合理’的原则，我们通过手写迭代器的方式来深入了解一下迭代器模式的实现和带来的编码好处。 实现案例有一个书架，我们想要知道这个书架里面堆了哪些书籍，这时候我们就需要对书架里面的书一本一本的遍历，直到没有书本，我们就能清楚的知道数据上堆满了哪些书籍。 可以被遍历的标记(生成迭代器的接口)首先提供一个接口，来标明这个类是可以被遍历的集合。实现这个接口的类可以生成对应的迭代器。 123public interface Aggregate&#123; public abstract Iterator iterator();&#125; 迭代器接口迭代器的抽象接口，定义了两个方法（1）是否还有下一个元素（2）返回下一个元素 1234public interface Iterator&#123; public abstract boolean hasNext(); public abstract Object next();&#125; 集合存储的元素（书本） 123public class book&#123; private String name;&#125; 迭代器实现类 1234567891011121314151617181920public class BookShelfIterator&#123; private BookShelf bookShelf; //指向当前遍历的位置 private int index; ... public boolean hasNext()&#123; //将当前的index与集合的大小做比较，小于集合大小，说明还有元素。 if(index &lt; bookShelf.length)&#123; return true; &#125;else&#123; return false; &#125; &#125; public Object next()&#123; Book book = bookShelf.getBookAt(index); index++; return book; &#125;&#125; 书架类书架类用于存放书本，可以用来遍历，因此需要实现Aggregate接口 1234567public class BookShelf implements Aggregate&#123; ... public Iterator iterator()&#123; //生成对应的迭代器 return new BookShelfIterator(); &#125;&#125; 测试方法 1234Iterator it = bookShelf.iterator();while(it.hasNext)&#123; Book book = (Book)it.next();&#125; 由此，我们就自定义实现了一个迭代器，可以满足集合遍历的基本需求 迭代器模式的几点思考为什么要使用迭代模式遍历与实现分开，无论BookShelf是怎样的实现，只要能够获取到对应的迭代器，遍历方式都是不会变的，利于代码的扩展。 1234Iterator it = bookShelf.iterator();while(it.hasNext)&#123; Book book = (Book)it.next();&#125; 多种迭代器迭代器实现了遍历集合的方式，那么我们可以设计多种不一样的迭代器。 从后向前遍历 跳跃性遍历]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F03%2F%E9%87%8D%E6%9E%84%2F%E9%87%8D%E6%9E%84%2F</url>
    <content type="text"><![CDATA[重构总结（TODO）简介1.什么是重构 重构是对软件的内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高代码可理解性，降低维护成本。 关键： 更好的可读性 更好的可扩展性 功能保持一致 为什么要重构 改进软件设计整理代码，使代码结构回到最初设计，维持代码该有的形态，避免软件腐烂变质。 使软件更容易理解代码是人与及其交互的语言。保持语言的简洁有助于：（1）理解代码（2）后来者维护代码 帮助找到Bug重构过程可以重新梳理逻辑，找到潜在的Bug。 提高编程速度良好的设计师快速开发的根本。 何时进行重构事不过三，三则重构 添加功能时重构添加功能时，理解需要修改的代码，使添加功能更加轻松。 修改错误时候重构好的代码是足够清晰以至于能够肉眼观察bug，所以当遇到bug时，说明设计不够清晰，因而需要重构 复审代码时重构 重构的期望 容易阅读 所有的逻辑都只在唯一地点指定 新的改动不会危及现有行为 尽可能简单的表达条件逻辑 代码的坏味道（什么样的代码需要重构） 重复代码（Duplicated Code） 同一个类中的两个函数具有相同的代码，可以使用Extract Method提炼吃重复代码 两个兄弟子类具有相同的代码，则提炼相同代码（Extract Method）,再将提炼出来的函数推送给父类（Pull up method） 对于部分相同的情况，则分离出相似部分和差异部分，使用模板设计模式。 两个不相关类出现重复代码，则将重复代码提取到一个独立类。 过长的函数（Long method） 小型函数作为“间接层”具有解释能力、共享能力、选择能力 当需要用注释来描述代码的时候，就应该对函数进行分解，把需要说明的部分放入独立的函数，以其用途来命名 函数传参里有过多的参数和临时变量，应该尽量消除临时变量，使参数列表更加简洁。 过大的类（Large Class） 过长的参数列（Long Paramenter List） 发散式变化（Divergent Change） 散弹式修改（Shotgun Surgery） 依恋情节（Feature Envy） 数据泥团（Data Clumps） 基本类型偏执（Primitive Obsession） Switch现身（Switch Statement） 平行继承体系（Parallel Inheritance Hierarchies） 冗赘类（Lazy Class） 夸夸其谈未来性（Speculative Generality） 令人迷惑的临时字段（Temporary Field） 过度耦合的消息链（Message Chains） 中间人（Middle Man） 狎昵关系（Inappropriate Intimacy） 异曲同工的类（Alternative Classes with Different Interfaces） 不完美的库类（Incomplete Library Class） 纯稚的数据类（Data Class） 被拒绝的遗赠（Refused Bequest） 过多的注释（Comments） 重构列表 重新组织函数 提炼函数（Extract Method）适用场景]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringCache源码| Spring Cache的AOP实现原理]]></title>
    <url>%2F2019%2F06%2F27%2FSpring-boot%2F%E7%BC%93%E5%AD%98%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%2F</url>
    <content type="text"><![CDATA[1. 简述Spring Cache是通过AOP面向切面编程的思想来对缓存的操作进行封装，通过拦截器对实现了Spring Cache注解的方法进行拦截，可以根据注解信息去完成相应的缓存操作。 2. CacheInterceptor拦截器Spring Cache提供了一个缓存拦截器，负责拦截方法调用执行缓存逻辑。 12345678910111213141516171819202122232425public class CacheInterceptor extends CacheAspectSupport implements MethodInterceptor, Serializable &#123; public CacheInterceptor() &#123; &#125; //被拦截的方法都会走invoke @Nullable public Object invoke(MethodInvocation invocation) throws Throwable &#123; //invocation就是一个连接点(Joinpoint),其实就是对方调用方法的封装。 Method method = invocation.getMethod(); CacheOperationInvoker aopAllianceInvoker = () -&gt; &#123; try &#123; return invocation.proceed(); &#125; catch (Throwable var2) &#123; throw new ThrowableWrapper(var2); &#125; &#125;; try &#123; //核心的方法，来自于父类 return this.execute(aopAllianceInvoker, invocation.getThis(), method, invocation.getArguments()); &#125; catch (ThrowableWrapper var5) &#123; throw var5.getOriginal(); &#125; &#125;&#125; CacheIntercepto实现了MethodInterceptor，MethodInterceptor主要对方法进行拦截，查看MethodInterceptor的继承图，发现MethodInterceptor就是一个Advice，在Spring AOP的概念里面，Advice就是一个通知，通知封装了AOP的横切逻辑。由此来说CacheInterceptor作为一个通知，他里面肯定包含缓存操作的横切逻辑，能够处理方法调用前后的缓存操作。 2.1 查看父类的核心方法execute12345678910111213141516171819@Nullable protected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args) &#123; //是否初始化成功 if(this.initialized) &#123; Class&lt;?&gt; targetClass = this.getTargetClass(target); //获取CacheOperation资源类，负责解析Spring Cache注解的类 CacheOperationSource cacheOperationSource = this.getCacheOperationSource(); if(cacheOperationSource != null) &#123; //解析注解，得到CacheOperation的集合。 Collection&lt;CacheOperation&gt; operations = cacheOperationSource.getCacheOperations(method, targetClass); if(!CollectionUtils.isEmpty(operations)) &#123; //调用内部方法execute，封装了一个缓存操作的上下文并传入 return this.execute(invoker, method, new CacheAspectSupport.CacheOperationContexts(operations, method, args, target, targetClass)); &#125; &#125; &#125; return invoker.invoke(); &#125; 这个方法的主要作用： 获取缓存操作集合CacheOperation 封装缓存操作上下文，并调用内部的execute方法 2.2 核心内部方法execute123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Nullable private Object execute(CacheOperationInvoker invoker, Method method, CacheAspectSupport.CacheOperationContexts contexts) &#123; if(contexts.isSynchronized()) &#123; //获取CacheableOperation对应的缓存操作上下文。 CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)contexts.get(CacheableOperation.class).iterator().next(); if(this.isConditionPassing(context, CacheOperationExpressionEvaluator.NO_RESULT)) &#123; Object key = this.generateKey(context, CacheOperationExpressionEvaluator.NO_RESULT); //获取缓存对象 Cache cache = (Cache)context.getCaches().iterator().next(); try &#123; return this.wrapCacheValue(method, cache.get(key, () -&gt; &#123; return this.unwrapReturnValue(this.invokeOperation(invoker)); &#125;)); &#125; catch (ValueRetrievalException var10) &#123; throw (ThrowableWrapper)var10.getCause(); &#125; &#125; else &#123; return this.invokeOperation(invoker); &#125; &#125; else &#123; //1. 处理BeforeInvocation = true的缓存删除操作 this.processCacheEvicts(contexts.get(CacheEvictOperation.class), true, CacheOperationExpressionEvaluator.NO_RESULT); //2. 查找是否有@Cacheable的缓存数据 ValueWrapper cacheHit = this.findCachedItem(contexts.get(CacheableOperation.class)); List&lt;CacheAspectSupport.CachePutRequest&gt; cachePutRequests = new LinkedList(); if(cacheHit == null) &#123; //如果没有缓存数据，则封装成CachePutRequest this.collectPutRequests(contexts.get(CacheableOperation.class), CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests); &#125; Object cacheValue; Object returnValue; if(cacheHit != null &amp;&amp; !this.hasCachePut(contexts)) &#123; //获取缓存数据里面的值 cacheValue = cacheHit.get(); returnValue = this.wrapCacheValue(method, cacheValue); &#125; else &#123; //如果没有找到Cacheable的缓存数据，或者缓存注解是CachePut则调用方法，获取方法返回值 returnValue = this.invokeOperation(invoker); cacheValue = this.unwrapReturnValue(returnValue); &#125; //3. 将CachePut注解封装成CachePutRequest this.collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests); Iterator var8 = cachePutRequests.iterator(); while(var8.hasNext()) &#123; //遍历cachePutRequest，将方法调用的返回值置入缓存中。 CacheAspectSupport.CachePutRequest cachePutRequest = (CacheAspectSupport.CachePutRequest)var8.next(); cachePutRequest.apply(cacheValue); &#125; //处理BeforeInvocation = false的缓存删除操作 this.processCacheEvicts(contexts.get(CacheEvictOperation.class), false, cacheValue); return returnValue; &#125; &#125; 如果不需要同步，该方法主要完成了以下的逻辑 处理BeforeInvocation = true的缓存删除操作 通过@Cacheable注解找到对应的缓存值。 如果没有找到对应的缓存数据，则将@Cacheable封装成CachePutRequest，标记为一个插入缓存的请求。 进行方法调用 将CachePut注解封装成CachePutRequest 遍历CachePutReqeust集合，将方法调用的返回值置入缓存中。 处理BeforeInvocation = false的缓存删除操作 梳理一下，这个方法里面包括三个注解的逻辑 @Cacheable(1) 首先从缓存中找@Cacheable对应的缓存(2) 如果缓存存在，则取出缓存值作为返回值(3) 如果缓存不存在，则进行方法调用，获取返回值，并将返回值置入缓存 @CachePut(1) 如果包含cachePut注解，则进行方法调用。(2) 获取方法返回值，并置入缓存之中。 @CacheEvic(1) 在方法调用签执行缓存删除操作。(2) 在方法调用后执行缓存删除操作。 2.2.1 processCacheEvicts我们来看看缓存删除的具体逻辑1234567891011121314151617181920212223242526272829303132333435363738//beforeInvocation指的是方法调用前还是调用后，@CacheEvict可以进行设置private void processCacheEvicts(Collection&lt;CacheAspectSupport.CacheOperationContext&gt; contexts, boolean beforeInvocation, @Nullable Object result) &#123; Iterator var4 = contexts.iterator(); while(var4.hasNext()) &#123; CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)var4.next(); CacheEvictOperation operation = (CacheEvictOperation)context.metadata.operation; if(beforeInvocation == operation.isBeforeInvocation() &amp;&amp; this.isConditionPassing(context, result)) &#123; //处理缓存删除操作 this.performCacheEvict(context, operation, result); &#125; &#125; &#125;private void performCacheEvict(CacheAspectSupport.CacheOperationContext context, CacheEvictOperation operation, @Nullable Object result) &#123; Object key = null; Iterator var5 = context.getCaches().iterator(); while(var5.hasNext()) &#123; //遍历获取Cache对象 Cache cache = (Cache)var5.next(); if(operation.isCacheWide()) &#123; this.logInvalidating(context, operation, (Object)null); //删除全部缓存 this.doClear(cache); &#125; else &#123; if(key == null) &#123; key = this.generateKey(context, result); &#125; this.logInvalidating(context, operation, key); //删除指定key的缓存 this.doEvict(cache, key); &#125; &#125; &#125; 2.2.2 findCachedItem(获取缓存数据)12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Nullable private ValueWrapper findCachedItem(Collection&lt;CacheAspectSupport.CacheOperationContext&gt; contexts) &#123; Object result = CacheOperationExpressionEvaluator.NO_RESULT; Iterator var3 = contexts.iterator(); while(var3.hasNext()) &#123; CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)var3.next(); if(this.isConditionPassing(context, result)) &#123; //生成相应的Cache key Object key = this.generateKey(context, result); //通过缓存上下文和key找寻相应的缓存包装对象 ValueWrapper cached = this.findInCaches(context, key); if(cached != null) &#123; return cached; &#125; if(this.logger.isTraceEnabled()) &#123; this.logger.trace("No cache entry for key '" + key + "' in cache(s) " + context.getCacheNames()); &#125; &#125; &#125; return null; &#125;@Nullable private ValueWrapper findInCaches(CacheAspectSupport.CacheOperationContext context, Object key) &#123; Iterator var3 = context.getCaches().iterator(); Cache cache; ValueWrapper wrapper; do &#123; if(!var3.hasNext()) &#123; return null; &#125; //获取缓存对象，并通过key去查找缓存值 cache = (Cache)var3.next(); wrapper = this.doGet(cache, key); &#125; while(wrapper == null); if(this.logger.isTraceEnabled()) &#123; this.logger.trace("Cache entry for key '" + key + "' found in cache '" + cache.getName() + "'"); &#125; return wrapper; &#125; 2.2.3collectPutRequests(封装存储缓存的请求)12345678910111213private void collectPutRequests(Collection&lt;CacheAspectSupport.CacheOperationContext&gt; contexts, @Nullable Object result, Collection&lt;CacheAspectSupport.CachePutRequest&gt; putRequests) &#123; Iterator var4 = contexts.iterator(); while(var4.hasNext()) &#123; CacheAspectSupport.CacheOperationContext context = (CacheAspectSupport.CacheOperationContext)var4.next(); if(this.isConditionPassing(context, result)) &#123; Object key = this.generateKey(context, result); //通过key和缓存上下文封装一个插入缓存的请求。 putRequests.add(new CacheAspectSupport.CachePutRequest(context, key)); &#125; &#125; &#125; 3 总结目前，关于Spring Cache的源码分析就告一段落了，总的来说，SpringCache的分析文章主要对缓存注解实现的源码做了一个简要的分析，目的是能够对缓存操作的AOP实现原理有一个清晰的认识。能够搞清楚Spring Cache是如何借助AOP的思想来实现如何简单、快捷且代码侵入低的缓存组件。由此我们可以借鉴这些思想和案例来丰富我们的阅历，以助于提高我们的技术水平，帮助我们能够实现类似的开源组件。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCache源码| SpringCache缓存注解解析]]></title>
    <url>%2F2019%2F06%2F26%2FSpring-boot%2F%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.缓存的解析Spring Cache提供了缓存解析器，负责为缓存注解抽象成一个缓存信息对象。我们通过面向对象的编程方式就能够轻松的获取缓存操作信息 1.1CacheAnnotationParser缓存注解解析器12345678public interface CacheAnnotationParser &#123; //对类上面的缓存注解进行解析 @Nullable Collection&lt;CacheOperation&gt; parseCacheAnnotations(Class&lt;?&gt; var1); //对方法上面的注解进行解析 @Nullable Collection&lt;CacheOperation&gt; parseCacheAnnotations(Method var1);&#125; CacheAnnotationParser有一个实现类SpringCacheAnnotationParser,两个方法的实现是一样的，最终method也会转换成Class。所以这里针对parseCacheAnnotations(Class&lt;?&gt; var1)做解析123456789101112@Nullablepublic Collection&lt;CacheOperation&gt; parseCacheAnnotations(Class&lt;?&gt; type) &#123; //1. 获取 SpringCacheAnnotationParser.DefaultCacheConfig defaultConfig = this.getDefaultCacheConfig(type); //2. 通过DefaultCacheConfig信息和class去解析缓存注解 return this.parseCacheAnnotations(defaultConfig, type);&#125;@Nullablepublic Collection&lt;CacheOperation&gt; parseCacheAnnotations(Method method) &#123; SpringCacheAnnotationParser.DefaultCacheConfig defaultConfig = this.getDefaultCacheConfig(method.getDeclaringClass()); return this.parseCacheAnnotations(defaultConfig, method);&#125; 1.2getDefaultCacheConfig123456SpringCacheAnnotationParser.DefaultCacheConfig getDefaultCacheConfig(Class&lt;?&gt; target) &#123; //获取类上面的@CacheConfig注解信息 CacheConfig annotation = (CacheConfig)AnnotatedElementUtils.findMergedAnnotation(target, CacheConfig.class); //如果@CacheConfig不存在，则构建一个默认的DefaultCacheConfig return annotation != null ? new SpringCacheAnnotationParser.DefaultCacheConfig(annotation.cacheNames(), annotation.keyGenerator(), annotation.cacheManager(), annotation.cacheResolver()) : new SpringCacheAnnotationParser.DefaultCacheConfig(); &#125; 1.3. parseCacheAnnotations123456789101112@Nullable private Collection&lt;CacheOperation&gt; parseCacheAnnotations(SpringCacheAnnotationParser.DefaultCacheConfig cachingConfig, AnnotatedElement ae) &#123; Collection&lt;CacheOperation&gt; ops = this.parseCacheAnnotations(cachingConfig, ae, false); if (ops != null &amp;&amp; ops.size() &gt; 1 &amp;&amp; ae.getAnnotations().length &gt; 0) &#123; Collection&lt;CacheOperation&gt; localOps = this.parseCacheAnnotations(cachingConfig, ae, true); if (localOps != null) &#123; return localOps; &#125; &#125; return ops; &#125; 这个方法只是一个空壳，真正的逻辑在this.parseCacheAnnotations(cachingConfig, ae, false)这里面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Nullable private Collection&lt;CacheOperation&gt; parseCacheAnnotations(SpringCacheAnnotationParser.DefaultCacheConfig cachingConfig, AnnotatedElement ae, boolean localOnly) &#123; Collection&lt;CacheOperation&gt; ops = null; //解析@Cacheable Collection&lt;Cacheable&gt; cacheables = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, Cacheable.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, Cacheable.class); if (!cacheables.isEmpty()) &#123; ops = this.lazyInit((Collection)null); Iterator var6 = cacheables.iterator(); while(var6.hasNext()) &#123; Cacheable cacheable = (Cacheable)var6.next(); ops.add(this.parseCacheableAnnotation(ae, cachingConfig, cacheable)); &#125; &#125; //解析@cacheEvict Collection&lt;CacheEvict&gt; evicts = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, CacheEvict.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, CacheEvict.class); if (!evicts.isEmpty()) &#123; ops = this.lazyInit(ops); Iterator var13 = evicts.iterator(); while(var13.hasNext()) &#123; CacheEvict evict = (CacheEvict)var13.next(); ops.add(this.parseEvictAnnotation(ae, cachingConfig, evict)); &#125; &#125; //解析@CachePut Collection&lt;CachePut&gt; puts = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, CachePut.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, CachePut.class); if (!puts.isEmpty()) &#123; ops = this.lazyInit(ops); Iterator var15 = puts.iterator(); while(var15.hasNext()) &#123; CachePut put = (CachePut)var15.next(); ops.add(this.parsePutAnnotation(ae, cachingConfig, put)); &#125; &#125; //解析Cache Collection&lt;Caching&gt; cachings = localOnly ? AnnotatedElementUtils.getAllMergedAnnotations(ae, Caching.class) : AnnotatedElementUtils.findAllMergedAnnotations(ae, Caching.class); if (!cachings.isEmpty()) &#123; ops = this.lazyInit(ops); Iterator var17 = cachings.iterator(); while(var17.hasNext()) &#123; Caching caching = (Caching)var17.next(); Collection&lt;CacheOperation&gt; cachingOps = this.parseCachingAnnotation(ae, cachingConfig, caching); if (cachingOps != null) &#123; ops.addAll(cachingOps); &#125; &#125; &#125; return ops; &#125; 由上可知，代码分别对@Cacheable,@CachePut,@CacheEvict进行解析，一旦发现相应的注解，就对注解信息封装成对应的CacheOperation(缓存操作信息对象)。封装过程的代码如下： 1234567891011121314151617CacheableOperation parseCacheableAnnotation(AnnotatedElement ae, SpringCacheAnnotationParser.DefaultCacheConfig defaultConfig, Cacheable cacheable) &#123; Builder builder = new Builder(); builder.setName(ae.toString()); builder.setCacheNames(cacheable.cacheNames()); builder.setCondition(cacheable.condition()); builder.setUnless(cacheable.unless()); builder.setKey(cacheable.key()); builder.setKeyGenerator(cacheable.keyGenerator()); builder.setCacheManager(cacheable.cacheManager()); builder.setCacheResolver(cacheable.cacheResolver()); builder.setSync(cacheable.sync()); defaultConfig.applyDefault(builder); CacheableOperation op = builder.build(); //验证key()与keyGenerator() 以及CacheManager与CacheResolver之间的排他性。代码逻辑如下。 this.validateCacheOperation(ae, op); return op; &#125; 1234567private void validateCacheOperation(AnnotatedElement ae, CacheOperation operation) &#123; if (StringUtils.hasText(operation.getKey()) &amp;&amp; StringUtils.hasText(operation.getKeyGenerator())) &#123; throw new IllegalStateException("Invalid cache annotation configuration on '" + ae.toString() + "'. Both 'key' and 'keyGenerator' attributes have been set. These attributes are mutually exclusive: either set the SpEL expression used tocompute the key at runtime or set the name of the KeyGenerator bean to use."); &#125; else if (StringUtils.hasText(operation.getCacheManager()) &amp;&amp; StringUtils.hasText(operation.getCacheResolver())) &#123; throw new IllegalStateException("Invalid cache annotation configuration on '" + ae.toString() + "'. Both 'cacheManager' and 'cacheResolver' attributes have been set. These attributes are mutually exclusive: the cache manager is used to configure adefault cache resolver if none is set. If a cache resolver is set, the cache managerwon't be used."); &#125; &#125; 1.4小结由此Spring Cache通过缓存注解解析器，将对应的缓存注解解析成了CacheOperation对象，CacheOperation对象封装了缓存注解信息的细节，可以指导相应的缓存操作。 2.谈谈CacheOperation缓存封装类12345678910public abstract class CacheOperation implements BasicOperation &#123; private final String name; private final Set&lt;String&gt; cacheNames; private final String key; private final String keyGenerator; private final String cacheManager; private final String cacheResolver; private final String condition; private final String toString;&#125; CacheOperation是一个抽象的缓存操作类，它封装了Cache操作的基本属性，是对缓存信息的抽象 CacheableOperation(@Cacheable) CachePutOperation(@CachePut) CacheEvictOperation(@CacheEvict) 3.缓存操作资源类Spring Cache提供了一个缓存操作资源接口(CacheOperationSource)来调用缓存注解的解析工作。12345public interface CacheOperationSource &#123; //为一个执行方法返回所有的缓存操作集合 @Nullable Collection&lt;CacheOperation&gt; getCacheOperations(Method var1, @Nullable Class&lt;?&gt; var2);&#125; 123456789101112131415161718192021222324252627282930313233343536@Configuration@Role(2)public class ProxyCachingConfiguration extends AbstractCachingConfiguration &#123; public ProxyCachingConfiguration() &#123; &#125; @Bean( name = &#123;"org.springframework.cache.config.internalCacheAdvisor"&#125; ) @Role(2) public BeanFactoryCacheOperationSourceAdvisor cacheAdvisor() &#123; BeanFactoryCacheOperationSourceAdvisor advisor = new BeanFactoryCacheOperationSourceAdvisor(); advisor.setCacheOperationSource(this.cacheOperationSource()); advisor.setAdvice(this.cacheInterceptor()); if(this.enableCaching != null) &#123; advisor.setOrder(((Integer)this.enableCaching.getNumber("order")).intValue()); &#125; return advisor; &#125; @Bean @Role(2) public CacheOperationSource cacheOperationSource() &#123; return new AnnotationCacheOperationSource(); &#125; @Bean @Role(2) public CacheInterceptor cacheInterceptor() &#123; CacheInterceptor interceptor = new CacheInterceptor(); interceptor.configure(this.errorHandler, this.keyGenerator, this.cacheResolver, this.cacheManager); interceptor.setCacheOperationSource(this.cacheOperationSource()); return interceptor; &#125;&#125; 在@Enable文章的代码解析中，在创建Advisor的时候将CacheOperationSource作为属性传递进去了。那么在方法调用时，AOP会通过CacheInterceptor拦截方法，调用CacheOperationSource获取解析方法上面的缓存注解。 CacheOperationSource有三个实现类，Spring Cache采用AnnotationCacheOperationSource来处理缓存注解的解析工作。 查看AnnotationCacheOperationSource的继承体系。 CacheOperationSource的设计采用的是模板模式的方式,获取CacheOperation的主要的通用逻辑在父类AbstractFallbackCacheOperationSource中,子类AnnotationCacheOperationSource主要实现差异化的功能，接下来看一下他们的实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class AnnotationCacheOperationSource extends AbstractFallbackCacheOperationSource implements Serializable &#123; //省略了部分代码 //只允许public方法 执行缓存操作 private final boolean publicMethodsOnly; //缓存注解解析器 private final Set&lt;CacheAnnotationParser&gt; annotationParsers; //获取Class上面对应的缓存操作(实现父类的方法，方法的调用的父类中) @Nullable protected Collection&lt;CacheOperation&gt; findCacheOperations(Class&lt;?&gt; clazz) &#123; return this.determineCacheOperations((parser) -&gt; &#123; return parser.parseCacheAnnotations(clazz); &#125;); &#125; //获取Method上面对应的缓存操作(实现父类的方法，方法的调用的父类中) @Nullable protected Collection&lt;CacheOperation&gt; findCacheOperations(Method method) &#123; return this.determineCacheOperations((parser) -&gt; &#123; return parser.parseCacheAnnotations(method); &#125;); &#125; //遍历解析器集合，获取所有的CacheOperation @Nullable protected Collection&lt;CacheOperation&gt; determineCacheOperations(AnnotationCacheOperationSource.CacheOperationProvider provider) &#123; Collection&lt;CacheOperation&gt; ops = null; Iterator var3 = this.annotationParsers.iterator(); while(var3.hasNext()) &#123; CacheAnnotationParser annotationParser = (CacheAnnotationParser)var3.next(); Collection&lt;CacheOperation&gt; annOps = provider.getCacheOperations(annotationParser); if (annOps != null) &#123; if (ops == null) &#123; ops = annOps; &#125; else &#123; Collection&lt;CacheOperation&gt; combined = new ArrayList(((Collection)ops).size() + annOps.size()); combined.addAll((Collection)ops); combined.addAll(annOps); ops = combined; &#125; &#125; &#125; return (Collection)ops; &#125; //调用CacheAnnotationParser进行注解解析的函数式接口 @FunctionalInterface protected interface CacheOperationProvider &#123; @Nullable Collection&lt;CacheOperation&gt; getCacheOperations(CacheAnnotationParser var1); &#125;&#125; 3.1查看AbstractFallbackCacheOperationSource源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public abstract class AbstractFallbackCacheOperationSource implements CacheOperationSource &#123; private static final Collection&lt;CacheOperation&gt; NULL_CACHING_ATTRIBUTE = Collections.emptyList(); //维护了一个缓存操作类的map, key为method和class的包装，可以确保唯一性。 private final Map&lt;Object, Collection&lt;CacheOperation&gt;&gt; attributeCache = new ConcurrentHashMap(1024); //执行缓存注解解析工作的主要逻辑 @Nullable public Collection&lt;CacheOperation&gt; getCacheOperations(Method method, @Nullable Class&lt;?&gt; targetClass) &#123; if (method.getDeclaringClass() == Object.class) &#123; return null; &#125; else &#123; //获取method和class组成的唯一key Object cacheKey = this.getCacheKey(method, targetClass); //从缓存中去查找CacheOperation. Collection&lt;CacheOperation&gt; cached = (Collection)this.attributeCache.get(cacheKey); if (cached != null) &#123; return cached != NULL_CACHING_ATTRIBUTE ? cached : null; &#125; else &#123; //如果attributeCache没有发现，则进行缓存操作的解析 Collection&lt;CacheOperation&gt; cacheOps = this.computeCacheOperations(method, targetClass); if (cacheOps != null) &#123; if (this.logger.isTraceEnabled()) &#123; this.logger.trace("Adding cacheable method '" + method.getName() + "' with attribute: " + cacheOps); &#125; 将解析结构存入attributeCache,供下次使用 this.attributeCache.put(cacheKey, cacheOps); &#125; else &#123; this.attributeCache.put(cacheKey, NULL_CACHING_ATTRIBUTE); &#125; return cacheOps; &#125; &#125; &#125; //获取由Method和Class产生的唯一key protected Object getCacheKey(Method method, @Nullable Class&lt;?&gt; targetClass) &#123; return new MethodClassKey(method, targetClass); &#125; //开始解析缓存注解 @Nullable private Collection&lt;CacheOperation&gt; computeCacheOperations(Method method, @Nullable Class&lt;?&gt; targetClass) &#123; //判断非pulic方法 是否可以获取缓存注解信息 if (this.allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123; return null; &#125; else &#123; //找到特定的方法 Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass); //调用子类实现 从方法上找缓存注解 Collection&lt;CacheOperation&gt; opDef = this.findCacheOperations(specificMethod); if (opDef != null) &#123; return opDef; &#125; else &#123; //调用子类实现，试着从Class上获取缓存注解 opDef = this.findCacheOperations(specificMethod.getDeclaringClass()); if (opDef != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123; return opDef; &#125; else &#123; //前面没有找到的话，则从原始执行方法上去找 if (specificMethod != method) &#123; opDef = this.findCacheOperations(method); if (opDef != null) &#123; return opDef; &#125; //从原始执行方法的类上去找 opDef = this.findCacheOperations(method.getDeclaringClass()); if (opDef != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123; return opDef; &#125; &#125; return null; &#125; &#125; &#125; &#125; //由子类实现逻辑 @Nullable protected abstract Collection&lt;CacheOperation&gt; findCacheOperations(Class&lt;?&gt; var1); //由子类实现逻辑 @Nullable protected abstract Collection&lt;CacheOperation&gt; findCacheOperations(Method var1);&#125; 4.总结本章本章主要从SpringCache 缓存注解的解析工作入手分析，主要的关键点如下：（1）Spring cache提供了一个缓存注解解析类，专门负责解析类或者方法层次上面注解（2）解析的过程将注解信息封装成CacheOperation的对象中，由此方面操作。（3）提供了一个缓存操作资源类(CacheOperationSource)负责管控缓存注解的解析过程。只需将这个缓存操作资源置入想要的地方，就能在需要的地方完成缓存注解解析，提供了一个缓存信息的操作对象。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源码|初识AutoProxyRegistrar]]></title>
    <url>%2F2019%2F06%2F24%2FSpring-boot%2F%E5%88%9D%E8%AF%86AutoProxyRegistrar%2F</url>
    <content type="text"><![CDATA[AutoProxyRegistrar源码分析]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCache源码| SpringCache源码总览]]></title>
    <url>%2F2019%2F06%2F24%2FSpring-boot%2FSpringCache%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. 概述Spring提供了一种基于注解（annotation）的缓存技术，他并不是具体的缓存使用方案，而是一个对缓存使用的抽象方案。只要代码使用相应的缓存注解，就能使用各种定义的缓存操作。由此一来缓存的操作非常的便捷，对代码的侵入比较少，让开发者更关注于业务逻辑的实现。 1.1 如何使用Spring Cache2. SpringCache的原理缓存的操作相对固定，可以借助AOP面向切面编程的思想将缓存操作作为通用的逻辑封装起来。SpringCache借助AOP的思想将缓存操作封装成了通用的模块。接下来通过一个流程图来了解一下Spring Cache缓存模块的原理。 2.1 SpringCache的基本接口和注解2.1.1 Cache和CacheManager CacheCache接口是缓存操作的基础接口，它提供了关于缓存的增、删、改、查的相关操作。123456789101112131415161718192021222324252627public interface Cache &#123; String getName(); //返回原始的缓存对象 Object getNativeCache(); //返回包装值 @Nullable Cache.ValueWrapper get(Object var1); //获取指定类型的缓存 @Nullable &lt;T&gt; T get(Object var1, @Nullable Class&lt;T&gt; var2); @Nullable &lt;T&gt; T get(Object var1, Callable&lt;T&gt; var2); void put(Object var1, @Nullable Object var2); //写入缓存 @Nullable Cache.ValueWrapper putIfAbsent(Object var1, @Nullable Object var2); //删除指定key的缓存 void evict(Object var1); //清空缓存 void clear();&#125; Cache有两个实现类ConcurrentMapCache和NoOpCache （1）ConcurrentMapCacheCache接口的默认实现（2）NoOpCache测试用 CacheManagerCacheManager是一个用于管理Cache对象的集合。SpringCache提供了四种CacheManager的实现。(1)SimpleCacheManager简单的CacheManager实现。主要用于测试(2)NoOpCacheManager测试用的CacherManager(3)CompositeCacheManager组合CacheManager, 可以集成多种CacheManager实例，支持多种缓存容器(4)ConcurentMapCacheManagerSpringCache默认的CacheManager实现。使用ConcurrentMap作为缓存技术。 这里就SpringCache提供了默认的缓存容器实现方案(ConcurentMapCacheManager)做一个源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ConcurrentMapCacheManager implements CacheManager, BeanClassLoaderAware &#123; //默认创建大小为16的ConcurrentMap来存储Cache对象 private final ConcurrentMap&lt;String, Cache&gt; cacheMap = new ConcurrentHashMap(16); //是否可以动态创建缓存 private boolean dynamic = true; //是否允许存null值 private boolean allowNullValues = true; private boolean storeByValue = false; @Nullable private SerializationDelegate serialization; public ConcurrentMapCacheManager() &#123; &#125; public ConcurrentMapCacheManager(String... cacheNames) &#123; this.setCacheNames(Arrays.asList(cacheNames)); &#125; //初始化Cache,初始化过后，dynamic设置为false,不会再动态创建Cache. public void setCacheNames(@Nullable Collection&lt;String&gt; cacheNames) &#123; if (cacheNames != null) &#123; Iterator var2 = cacheNames.iterator(); while(var2.hasNext()) &#123; String name = (String)var2.next(); this.cacheMap.put(name, this.createConcurrentMapCache(name)); &#125; this.dynamic = false; &#125; else &#123; this.dynamic = true; &#125; &#125; public boolean isAllowNullValues() &#123; return this.allowNullValues; &#125; //根据name获取Cache实例，如果Cache实例不存在，则动态创建一个缓存Cache实例。 @Nullable public Cache getCache(String name) &#123; Cache cache = (Cache)this.cacheMap.get(name); //如果初始化过Cache,则getCache的时候不会动态创建Cache. if (cache == null &amp;&amp; this.dynamic) &#123; ConcurrentMap var3 = this.cacheMap; synchronized(this.cacheMap) &#123; cache = (Cache)this.cacheMap.get(name); if (cache == null) &#123; cache = this.createConcurrentMapCache(name); this.cacheMap.put(name, cache); &#125; &#125; &#125; return cache; &#125; //创建ConcurrentMapCache对象 protected Cache createConcurrentMapCache(String name) &#123; SerializationDelegate actualSerialization = this.isStoreByValue() ? this.serialization : null; return new ConcurrentMapCache(name, new ConcurrentHashMap(256), this.isAllowNullValues(), actualSerialization); &#125;&#125; 小结Cache接口提供了缓存操作的基础操作(增、删、改、查),CacheManager提供了集中管理Cache对象的功能。两个接口一起提供了缓存操作的基本功能。同时这两个接口也是SpringCache对外提供的扩展点。可以根据需要去扩展想要的缓存对象(Cache)和缓存管理器(CacheManager),假如想用Redis作为缓存容器，则可以自定义RedisCache和RedisCacheManager。 SpringCache核心注解SpringCache提供了几个缓存操作的核心注解 @Cacheable123456789101112131415161718192021222324252627282930313233//可作用于类和方法@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Cacheable &#123; //cache的名称 @AliasFor("cacheNames") String[] value() default &#123;&#125;; //cache的名称 @AliasFor("value") String[] cacheNames() default &#123;&#125;; //缓存值的key,使用SPEL手动指定缓存键的组合方式，默认情况是使用所有参数来组合缓存键 // #root.method：用于获取当前方法的Method实例 // #root.target：用于获取当前方法的target实例 // #root.caches：用于获取当前方法关联的缓存 // #root.methodName：用于获取当前方法的名称 // #root.targetClass：用于获取目标类类型 // #root.args[1]：获取当前方法的第二个参数，等同于：#p1和#a1和#argumentName String key() default ""; //缓存键生成器,功能与key()具有排他性。keyGenerator是一个函数接口，可以通过自定义逻辑来实现key的生成策略 String keyGenerator() default ""; //设置自定义的缓存管理器，与缓存解析器具有排他性 String cacheManager() default ""; //设置自定义的缓存解析器 String cacheResolver() default ""; //执行缓存的条件，条件不满足就不会执行缓存操作 String condition() default ""; //禁止缓存功能，设置的条件满足的话 String unless() default ""; //设置是否对多个针对同一key执行缓存加载的操作的线程进行同步 boolean sync() default false;&#125; 作用： 直接从缓存中拿数据，如果缓存未命中，则执行方法，将方法返回的结果存入缓存。 @Cacheable可以作用在类上，表示类中的所有方法都使用了@Cacheable。 @CachePut@CachePut参数含义与@Cacheable一样1234567891011121314151617181920212223@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CachePut &#123; @AliasFor("cacheNames") String[] value() default &#123;&#125;; @AliasFor("value") String[] cacheNames() default &#123;&#125;; String key() default ""; String keyGenerator() default ""; String cacheManager() default ""; String cacheResolver() default ""; String condition() default ""; String unless() default "";&#125; 作用：作用与@Cacheable保持一致 @CacheEvict12345678910111213141516171819202122232425@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CacheEvict &#123; @AliasFor("cacheNames") String[] value() default &#123;&#125;; @AliasFor("value") String[] cacheNames() default &#123;&#125;; String key() default ""; String keyGenerator() default ""; String cacheManager() default ""; String cacheResolver() default ""; String condition() default ""; //指定当前缓存名称下的所有缓存是否全部删除。 boolean allEntries() default false; //指定删除缓存的操作在方法调用前还是调用后执行，默认False,先用调用方法，后执行缓存删除。 boolean beforeInvocation() default false;&#125; 作用 从缓存中删除数据 allEntries来指定是否删除CacheName中的所有缓存数据 beforeInvocation表示缓存操作的执行顺序 总结Spring Cache提供了基础且核心的接口和注解，使我们能够更加便捷的操作缓存但是我们不禁有个疑问?这些缓存接口和注解是如何作用到我们的方法上的。我们是如何获取到注解信息并通过这些信息指导缓存操作的？下一篇就聊一聊缓存注解的解析和应用。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源碼|@EnbaleXxx的实现原理]]></title>
    <url>%2F2019%2F06%2F16%2FSpring-boot%2F%40Enable%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.EnableXxx实现原理解析 Spring Boot的核心作用在于他具有强大的自动配置的功能，在Spring框架的基础上利用约定大于配置减少了Spring开发中配置复杂等问题。Spring Boot提供了很多类似于@EnableXXX的注解，这些注解有什么用呢？解决了Spring Boot什么问题？ 接下来我们通过源码来学习一下关@EnableXXX相关注解。 1.1常见的@Enable注解 @EnableCaching @EnableAsync @EnbaleJpaRepositories @EnableAutoConfiguration 1.2 @EnableXxxx源码入口本文主要以@EnableCaching作为核心来讲解一下SpringBoot关于@EnbaleXXX注解实现 12345678910111213@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(&#123;CachingConfigurationSelector.class&#125;)public @interface EnableCaching &#123; //动态代理的两种实现方式（JDK动态代理或者CGLIB）,默认使用JDK动态代理 boolean proxyTargetClass() default false; //代理实现的两种方式（AspectJ或者动态代理），默认使用动态代理 AdviceMode mode() default AdviceMode.PROXY; int order() default 2147483647;&#125; @EnableCaching是Spring Cache的入口，开启了注解式的缓存支持。 设置动态代理的实现方式，默认采用JDK动态代理。 默认采用动态代理的方式实现代理 通过@Import注解导入了一个CachingConfigurationSelector配置类。 关于@Import，可以参照博客@Import注解接下来根据@Import导入的CachingConfigurationSelector类进行分析 123456789101112131415161718192021222324252627282930313233343536373839public class CachingConfigurationSelector extends AdviceModeImportSelector&lt;EnableCaching&gt; &#123; 、、、、只保留关键代码 //根据@EnableCaching注解的信息确定需要导入容器的Bean的类名 public String[] selectImports(AdviceMode adviceMode) &#123; switch(null.$SwitchMap$org$springframework$context$annotation$AdviceMode[adviceMode.ordinal()]) &#123; case 1: return this.getProxyImports(); case 2: return this.getAspectJImports(); default: return null; &#125; &#125; //获取动态代理的配置Bean. private String[] getProxyImports() &#123; List&lt;String&gt; result = new ArrayList(3); result.add(AutoProxyRegistrar.class.getName()); result.add(ProxyCachingConfiguration.class.getName()); if(jsr107Present &amp;&amp; jcacheImplPresent) &#123; result.add("org.springframework.cache.jcache.config.ProxyJCacheConfiguration"); &#125; return StringUtils.toStringArray(result); &#125; //对于AspectJ代理模式，不作分析 private String[] getAspectJImports() &#123; List&lt;String&gt; result = new ArrayList(2); result.add("org.springframework.cache.aspectj.AspectJCachingConfiguration"); if(jsr107Present &amp;&amp; jcacheImplPresent) &#123; result.add("org.springframework.cache.aspectj.AspectJJCacheConfiguration"); &#125; return StringUtils.toStringArray(result); &#125; 、、、只保留关键代码、&#125; 如上，CachingConfigurationSelector的父类AdviceModeImportSelector实现了ImportSelector接口，导入两个关键的动态代理配置类。 AutoProxyRegistrarAutoProxyRegistrar就是一个自动代理注册器，他负责给容器注册了一个InfrastructureAdvisorAutoProxyCreator，他就是一个后置增强处理器，负责在Bean初始化后通过动态代理生成代理对象，关于AutoProxyRegistrar的解析，这里有专门的博客对AutoProxyRegistrar创建代理的过程进行阐述。 ProxyCachingConfiguration 123456789101112131415161718192021222324252627282930313233343536@Configuration@Role(2)public class ProxyCachingConfiguration extends AbstractCachingConfiguration &#123; public ProxyCachingConfiguration() &#123; &#125; @Bean( name = &#123;"org.springframework.cache.config.internalCacheAdvisor"&#125; ) @Role(2) public BeanFactoryCacheOperationSourceAdvisor cacheAdvisor() &#123; BeanFactoryCacheOperationSourceAdvisor advisor = new BeanFactoryCacheOperationSourceAdvisor(); advisor.setCacheOperationSource(this.cacheOperationSource()); advisor.setAdvice(this.cacheInterceptor()); if(this.enableCaching != null) &#123; advisor.setOrder(((Integer)this.enableCaching.getNumber("order")).intValue()); &#125; return advisor; &#125; @Bean @Role(2) public CacheOperationSource cacheOperationSource() &#123; return new AnnotationCacheOperationSource(); &#125; @Bean @Role(2) public CacheInterceptor cacheInterceptor() &#123; CacheInterceptor interceptor = new CacheInterceptor(); interceptor.configure(this.errorHandler, this.keyGenerator, this.cacheResolver, this.cacheManager); interceptor.setCacheOperationSource(this.cacheOperationSource()); return interceptor; &#125;&#125; ProxyCachingConfiguration向容器中注入了三个Bean，一起组装了一个BeanFactoryCacheOperationSourceAdvisor，它是一个PointAdvisor(切面),整合了PointCut(切点)和Advice(通知)两个模块，确定了在什么方法上(PointCut)执行什么样的缓存操作(Advice)。 小结@Enable通过@Import注解能够将指定的配置文件或者Bean装配到Spring容器中，完成自动装配的功能。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot源碼|深入理解@Import注解]]></title>
    <url>%2F2019%2F06%2F15%2FSpring-boot%2F%40Import%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[深入理解@Import注解 查看SpringBoot相关组件的源码，会发现有很多地方运用了@Import注解，这个注解有什么用呢，工作原理是什么，我们可以利用这个@Import来做什么？ 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Import &#123; Class&lt;?&gt;[] value();&#125; @Import的使用方式1234567public class Client &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); ServiceImpl service = applicationContext.getBean(ServiceImpl.class); Assert.notNull(service,"service has inject successful"); &#125;&#125; Configuration通过@Import将Class加载到AppConfig类中 1234@Configuration@Import(value = ServiceImpl.class)public class AppConfig &#123;&#125; ImportBeanDefinitionRegistrar123public interface ImportBeanDefinitionRegistrar &#123; void registerBeanDefinitions(AnnotationMetadata var1, BeanDefinitionRegistry var2);&#125; 自定义BeanDefinitionRegistrar的实现12345678public class ServiceBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar&#123; @Override public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) &#123; BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ServiceImpl.class); //BeanDefinitionRegistry将生成的BeanDefinition注册到容器中去 beanDefinitionRegistry.registerBeanDefinition("service",builder.getBeanDefinition()); &#125;&#125; 1234@Configuration@Import(value = ServiceBeanDefinitionRegistrar.class)public class AppConfig &#123;&#125; 通过ImportBeanDefinitionRegistrar实现的Import可以针对Bean注册容器的过程进行自定义ImportSelector告诉容器需要注入哪些类的类名就可以实现Bean的注入 123public interface ImportSelector &#123; String[] selectImports(AnnotationMetadata var1);&#125; 1234567public class ServiceImportSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; //annotationMetadata是关于注解的元数据信息,可以根据需要获取注解的信息 return new String[]&#123;ServiceImpl.class.getName()&#125;; &#125;&#125; 1234@Configuration@Import(value = ServiceImportSelector.class)public class AppConfig &#123;&#125; 总结获取注解元数据信息，返回一组需要注入类的类名，有框架来生成对应的实体类从而注入到容器中去。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记|如何更好的创建和销毁对象]]></title>
    <url>%2F2019%2F04%2F14%2FeffectiveJava%2F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[静态工厂方法代替构造器静态工厂方法的几大优势 静态工厂方法有名称，易于区分。 避免不必要的重复对象的创建工作 不必每次调用都创建一个新的对象，可以将构建好的实例缓存起来重复使用 可以返回原返回类型的任何子类型 返回对象有了更大的灵活性 返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值 方法返回对象所属的类，在编写包含静态工厂方法的类时可以不存在 静态工厂方法的几个缺点 类如果不含公有的或者受保护的构造器，就不能被子类化 不易发现 遇到多个参数时要使用构建器当构造器扩展到大量的可选参数时，静态工厂和构造器就显得相当局限了。目前用的比较多的是重叠构造器1NutritionFacts cocaCola = new NutritionFacts(240,8,100,0,35,27); 缺点 可读性比较差 容易出错,如参数位置弄错位置 使用setter方案123456789101112131415161718192021222324252627282930313233343536373839404142public class NutritionFacts &#123; private int servingSize = -1; private int servings = -1; private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public NutritionFacts() &#123; &#125; public void setServingSize(int servingSize) &#123; this.servingSize = servingSize; &#125; public void setServings(int servings) &#123; this.servings = servings; &#125; public void setCalories(int calories) &#123; this.calories = calories; &#125; public void setFat(int fat) &#123; this.fat = fat; &#125; public void setSodium(int sodium) &#123; this.sodium = sodium; &#125; public void setCarbohydrate(int carbohydrate) &#123; this.carbohydrate = carbohydrate; &#125;&#125;NutritionFacts nutritionFacts = new NutritionFacts();nutritionFacts.setServingSize(240);nutritionFacts.setServings(100);nutritionFacts.setSodium(35);nutritionFacts.setCarbohydrate(27);nutritionFacts.setCalories(8); 可读性增强 一致性的问题(不安全) 构建器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class NutritionFacts &#123; private int servingSize = -1; private int servings = -1; private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; private NutritionFacts(Builder builder)&#123; this.servingSize = builder.servingSize; this.servings = builder.servings; this.calories = builder.calories; this.fat = builder.fat; this.sodium = builder.sodium; this.carbohydrate = builder.carbohydrate; &#125; public static class Builder&#123; private final int servingSize; private final int servings; private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) &#123; this.servingSize = servingSize; this.servings = servings; &#125; public NutritionFacts build()&#123; return new NutritionFacts(this); &#125; public Builder calories(int val)&#123; this.calories = val; return this; &#125; public Builder fat(int val)&#123; this.fat = val; return this; &#125; public Builder sodium(int val)&#123; this.sodium = val; return this; &#125; public Builder carbohydrate(int val)&#123; this.carbohydrate = val; return this; &#125; &#125; public static void main(String[] args) &#123; NutritionFacts nutritionFacts = new NutritionFacts.Builder(240,8).calories(100) .sodium(35).carbohydrate(27).build(); &#125;&#125; 直观、易于阅读(优点) 在注重性能的情况下，创建构建起是个问题(缺点) 最好一开始就用构建器(建议) 小结如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式是个不错的选择 私有构造器或者枚举类型强化Singleton属性Singleton:仅仅被实例化一次的类 Singleton的两种实现单例模式的实现（一）123456789public class Elvis &#123; public static final Elvis instance = new Elvis(); private Elvis()&#123;&#125; public void doSomething()&#123; System.out.println("do something"); &#125;&#125; 特点 私有构造器只调用一次，用来实例化公有的静态final域(instance) 没有public或者protect的构造器，保证了instance的唯一性 但是可以通过反射的方式调用私有构造器(可以修改构造器在创建第二次实例时抛出异常) 单例模式的实现（二）12345678910111213public class Elvis &#123; public static final Elvis instance = new Elvis(); private Elvis()&#123;&#125; public static Elvis getInstance()&#123; return instance; &#125; public void doSomething()&#123; System.out.println("do something"); &#125;&#125; 特点 添加了一个静态工厂方法，静态工厂方法的调用每次都返回同一个对象引用 公有的静态域是final的，该域总是包含相同的对象引用。公有域方法在性能上不会有任何优势，现在JVM实现能够将静态工厂方法的调用内联化。(内联：函数被调用的地方直接展开，编译器在调用时不会像一般函数那样，参数压栈，返回时参数出栈以及释放资源，直接提高程序的执行速度) Singleton可序列化问题Singleton仅仅在声明中加上implement Serializable是不够的，必须所有的实例都是瞬时的，并提供一个readResolve方法，否则每次反序列化都会创建一个新的实例 单例模式的实现（三）— 通过枚举类型实现1234567public enum Elvis &#123; INSTANCE; public void doSomething()&#123; System.out.println(&quot;do something&quot;); &#125; &#125; 特点 简洁 无偿提供了序列化机制，防止多次实例化 单元素的枚举类型是实现Singleton的最佳方法 使用依赖注入来引用资源静态工具类引用底层资源1234567891011public class SpellChecker &#123; private static final Dictionary DICTIONARY = new Dictionary(); public static boolean isValid(String word)&#123; System.out.println("do something"); return true; &#125; public SpellChecker()&#123;&#125;&#125; Singleton引用底层资源1234567891011public class SpellChecker &#123; private final Dictionary dictionary = new Dictionary(); private SpellChecker()&#123;&#125; public boolean isValid(String word)&#123; System.out.println("do something"); return true; &#125;&#125; 以上引入资源的两种形式都不太好。因为没法支持多种词典。所以静态资源类和Singleton类不适合作需要引用底层资源的类。 所以使用依赖注入来引入底层资源，当创建一个新的实例时，将该资源传到构造器中去。12345678910111213public class SpellChecker &#123; private final Dictionary dictionary; public SpellChecker(Dictionary dictionary)&#123; this.dictionary = dictionary; &#125; public boolean isValid(String word)&#123; System.out.println("do something"); return true; &#125;&#125; 依赖注入的变体形式将资源工厂传给构造器 小结 不要使用Singleton和静态工具类来实现依赖一个或者多个底层资源的类 尽量将资源或者创建资源的工厂传给构造器，（或者工厂方法、builder）,这样会增加类的灵活性、重用性和可测试性 避免创建不必要的对象最好重用对象而不是每次需要的时候创建一个相同功能的新对象，这样可以提高性能，缩短响应时间。 String创建的案例123String s = new String("test");String s = "test"; 第一个语句： 每次执行都会创建新的String实例，这些创建的对象都是不必要的。如果用在一个频繁调用的方法中，就回创建成千上万不必要的String实例。 第二个语句： 对于所有在同一台虚拟机运行的代码，只要它们包含相同的字符串字面常量，该对象就会被重用。 java会在方法区运行时常量池保存”test”,当下次调用String = “test”,java会直接返回这个对象的引用，而不会重新创建对象，由此节省了内存开销，可以放心在循环中使用 String s = new String(“test”)实际创建了两个对象，一个对象在堆中，一个保存在常量池 优先使用静态工厂方法而不是构造器来创建对象 构造器每次调用都会创建新对象，而静态工厂方法不会这样，静态工厂方法可以重用对象，也可以加缓存 如果反复需要一些创建成本比较高的对象，建议缓存下来重用。 不要创建多个适配器如果对象是可以变化的，也可以实现重用 适配器：把功能委托给一个后备对象，从而为后备对象提供一个可以替代的接口，适配器除了后备对象，没有其他任何信息。 Map接口的keyset()返回Map对象的Set视图，包含Map的所有键 每次调用都返回Map对象锁对应的Set实例，即便Map内容会有所变化，也能反映到Set实例中。 所以没有必要创建多个Set实例。 123456789101112131415161718192021222324252627282930313233343536373839404142public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; if (ks == null) &#123; ks = new AbstractSet&lt;K&gt;() &#123; public Iterator&lt;K&gt; iterator() &#123; return new Iterator&lt;K&gt;() &#123; private Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); public boolean hasNext() &#123; return i.hasNext(); &#125; public K next() &#123; return i.next().getKey(); &#125; public void remove() &#123; i.remove(); &#125; &#125;; &#125; public int size() &#123; return AbstractMap.this.size(); &#125; public boolean isEmpty() &#123; return AbstractMap.this.isEmpty(); &#125; public void clear() &#123; AbstractMap.this.clear(); &#125; public boolean contains(Object k) &#123; return AbstractMap.this.containsKey(k); &#125; &#125;; keySet = ks; &#125; return ks; &#125; 避免自动装箱造成重复对象的创建自动装箱会导致多余对象的创建 1234567private static long sum()&#123; Long sum = 0L; for(long i = 0;i&lt;=Integer.MAX_VALUE;i++)&#123; sum += i; &#125; return sum; &#125; 声明的变量是Long而不是long,所以每一次循环都会构造多余的Long实例， 所以要优先使用基本类型而不是装箱基本类型，当心无意识的自动装箱。 小结 通过维护对象池来避免创建对象也不是好事情，除非对象池中的对象是非常重要的对象。 维护对象池会把代码弄得很乱，同时增加内存占用，损害性能 消除过期的对象引用虽然java帮助我们完成了大部分内存管理的工作，但是我们还不不能对内存管理置之不理。 Stack引发的内存溢出的问题1234567891011121314151617181920212223242526272829public class Stack &#123; private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACOTY = 16; public Stack()&#123; elements = new Object[DEFAULT_INITIAL_CAPACOTY]; &#125; public void push(Object e)&#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop()&#123; if(size ==0)&#123; throw new RuntimeException("no element"); &#125; return elements[--size]; &#125; private void ensureCapacity()&#123; if(elements.length == size)&#123; elements = Arrays.copyOf(elements,2*size+1); &#125; &#125;&#125; 栈先增长，后收缩，对于弹出来的对象，栈依旧维护者这些对象的引用，所以这些对象不会被当做垃圾回收 所以一旦对象引用已经过期，只需清空这些引用就可以了12345678public Object pop()&#123; if(size ==0)&#123; throw new RuntimeException("no element"); &#125; Object result = elements[--size]; elements[size] = null; return result; &#125; 注意点： 清空对象引用是一种例外，而不是一种规范行为，对于栈这种自己管理内存的情况，程序员就应该警惕内存泄露问题。 缓存引起的内存泄露 缓存容易被遗忘，一旦时间长了,日积月累的缓存容易出现内存溢出的情况。 监听器和回调造成的内存溢出 避免使用终结方法try-with-resource优先于try-finally]]></content>
      <categories>
        <category>读书笔记(Effective Java)</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2019%2F04%2F14%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是适配器模式 将一个接口变换成客户期待的另一个的接口，从而使原本因接口不匹配无法一起工作的两个类能够一起工作。生活中不乏这样的案例，如电脑的电源适配器，它的作用主要是解决家用电和电脑之间的兼容问题 通过适配器模式可以解决‘现有程序’和‘所需程序’之间的差异，让现有程序和所需程序能够完美的兼容。 如何做一个将”交流100伏特电压”转换成“直流12伏特电压”的适配器适配器模式的两种实现 类适配器模式(继承） 对象适配器模式(委托) 继承适配器模式123456789101112public class Banner&#123; //现有的实际情况 private String string; public void showWithParen()&#123; System.out.println(""); &#125; public void showWithAster()&#123; System.out.println(""); &#125;&#125; 123456public interface Print&#123; //需求接口 public abstract void printWeak(); public abstract void printStrong();&#125; 1234567891011public class PrintBanner extends Banner implements Print&#123; //适配器类：在实现了现有的需求接口的方法中对原有的功能情况进行包装，以达到适配以前功能的目的。 public void printWeak()&#123; showWithParen(); &#125; public void printStrong()&#123; showWithAster(); &#125;&#125; 调用方法123Print p = new PringBanner("hello");p.pritWeak();p.printStrong(); 好处 面向接口编程，客户端代码只需要通过Print接口进行调用，隐藏了方法实现。(连接笔记本电脑的12伏特电压就有可能是由100伏特交流电压通过适配器转换而成的) 委托适配器模式通过委托来实现适配器 适配器(PrintBanner)通过调用现有需求的方法(Print)来间接调用以前的的功能(Banner) Banner通过委托的形式传入到适配器(PrintBanner)中,现有功能(Print)作为抽象类被适配器继承。 Talk is cheap, show me the code 12345publc abstract class Print&#123; //抽象类 public abstract void printWeak(); public abstract void printStrong();&#125; 123456789101112public class PrintBanner extends Print&#123; //通过委托的形式将原有功能注入进来，由此虽然调用的是新的功能方法，但实际调用的还是以前的老功能，由此实现了新、老功能之间的适配兼容。 private Banner banner; public void printWeak()&#123; banner.shouwWithParen(); &#125; public void printStrong()&#123; banner.showWithAster(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2019%2F04%2F13%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[实际案例一个主题切换案例123public interface Theme &#123; void applyTheme();&#125; 123456public class DefaultTheme implements Theme&#123; @Override public void applyTheme() &#123; System.out.println("设置默认主题"); &#125;&#125; 123456public class DarkTheme implements Theme&#123; @Override public void applyTheme() &#123; System.out.println("设置暗黑风格主题"); &#125;&#125; 123456public class ColorfulTheme implements Theme&#123; @Override public void applyTheme() &#123; System.out.println("设置彩色风格主题"); &#125;&#125; 123456789101112131415public class ThemeManager &#123; private Theme theme; public ThemeManager() &#123; this.theme = new DefaultTheme(); &#125; public void setTheme(Theme theme)&#123; this.theme = theme; &#125; public void applyTheme()&#123; this.theme.applyTheme(); &#125;&#125; 12345678public class Client &#123; public static void main(String[] args) &#123; ThemeManager themeManager = new ThemeManager(); //设置黑暗风格主题 themeManager.setTheme(new DarkTheme()); themeManager.applyTheme(); &#125;&#125; 主题模式更换的案例中，不同的主题风格就是一个个策略，我们可以根须需要选择不同的策略。 如何理解策略模式 定义椅子算法，将每个算法都以类的方式凤凰钻起来，并且使他们可以互相交换。 类图（TODO） 策略模式模型抽象 Context封装角色 主题更换案例中的ThemeManager就是一个封装角色，也叫上下文角色，拼比高层对策略的直接访问。 Strategy抽象策略角色 定义每个策略必须具有的方法和属性 ConcreteStrategy具体策略角色 抽象策略的实现，具体的算法 策略模式的优点 算法可以自由切换 避免了多重条件的判断 良好的扩展性(符合开闭原则) 策略模式的缺点 策略类会逐渐增多(超过四个考虑使用混合模式) 策略类必须向外暴露(违反迪米特法则) — 上层模块必须知道哪些策略，才能使用哪些策略，可用工厂方法模式修正 策略模式的具体应用 Shiro权限控制框架有三种验证策略]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器模式]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一个故事小明今年买了一个毛坯房，计划六月份装修作为婚房使用。小明选择了自定义的装修方案。线槽、刷漆、家具定制、门窗定制都是由不同的厂家来定制安装。 通过装饰器模式来模拟装修 毛坯房是一个被装饰的对象 线槽、刷漆、家具定制、门窗定制等就是装饰对象，他们负责对毛坯房进行装饰。 123public interface House &#123; void decorate();&#125; 123456public class RoughHouse implements House&#123; @Override public void decorate() &#123; System.out.println("毛坯房要开始装修了"); &#125;&#125; 1234567public abstract class HouseDecorate implements House&#123; protected House house; public HouseDecorate(House house) &#123; this.house = house; &#125;&#125; 刷漆的装饰类1234567891011public class BrushingHouseDecorate extends HouseDecorate&#123; public BrushingHouseDecorate(House house) &#123; super(house); &#125; @Override public void decorate() &#123; house.decorate(); System.out.println("房屋装修------刷漆"); &#125;&#125; 家具定制的装饰类123456789101112public class CustomizedFurnitureHouseDecorate extends HouseDecorate&#123; public CustomizedFurnitureHouseDecorate(House house) &#123; super(house); &#125; @Override public void decorate() &#123; house.decorate(); System.out.println("房屋装修------定制家具"); &#125;&#125; 门窗定制的装饰类1234567891011public class DoorWindowHouseDecorate extends HouseDecorate&#123; public DoorWindowHouseDecorate(House house) &#123; super(house); &#125; @Override public void decorate() &#123; house.decorate(); System.out.println("房屋装修------门窗定制"); &#125;&#125; 线槽安装的装饰类1234567891011public class TrunkingHouseDecorate extends HouseDecorate&#123; public TrunkingHouseDecorate(House house) &#123; super(house); &#125; @Override public void decorate() &#123; house.decorate(); System.out.println("房屋装修------安装线槽"); &#125;&#125; 客户端12345678910111213public class Client &#123; public static void main(String[] args) &#123; House house = new RoughHouse(); house = new BrushingHouseDecorate(house); house = new TrunkingHouseDecorate(house); house = new CustomizedFurnitureHouseDecorate(house); house = new DoorWindowHouseDecorate(house); house.decorate(); &#125;&#125; Result12345毛坯房要开始装修了房屋装修------刷漆房屋装修------安装线槽房屋装修------定制家具房屋装修------门窗定制 如何理解装饰器模式 动态的给一个对象添加额外的职责。提供了比集成更有弹性的替代方案 装饰器刷漆装修、安装线槽、定制家具、门窗定制都是属于装饰器。当我们居住一段时间后，想把厕所改造一下，我们只需要再构造一个装饰器，对房屋就是包装装饰就完成了工作，而不需要做过多的改变。 被装饰对象毛坯房就是属于被装饰对象 特点 装饰器与被装饰对象实现同一个接口 装饰器持有被装饰对象的引用 可以随意添加装饰器 看到装饰器模式的前两个特点，我们是不是有种似曾相识的感觉，这不是静态代理的特点吗？装饰器就好比代理类，他持有被代理对象（被装饰对象）的引用，去做被代理对象能做但是不想做的事情。 装饰器模式与静态代理 静态代理想做但不能做，需要找一个能干的人帮我做 装饰器模式我想做，但不能做，需要找各具特色的人来帮我做 用一个例子来说明这是一个代理类的实现12345678910111213141516171819202122public class Proxy implements Subject&#123; private Subject subject; public Proxy(Subject subject)&#123; this.subject = subject; &#125; @Override public void request() &#123; this.before(); subject.request(); this.after(); &#125; private void before()&#123; System.out.println("前置处理。。。。"); &#125; private void after()&#123; System.out.println("后置处理。。。。"); &#125;&#125; 如果我们想给主题添加一点操作日志，最简单的方法就是添加一个log();123private void log()&#123; System.out.println("添加日志");&#125; 对于需求，我们是不可控的，未来需求不断的增长，代理类会越来越大，难以维护，而且也不符合开闭原则。 如何应用 装饰器模式与静态代理模式都是包装模式，为其添加特定的功能 功能单一，可以选择代理模式 功能较多其需要动态扩张海燕，可以选择装饰器模式 装饰器模式应用场景 Java IO流123456DataInputStream in = new DataInputStream(new FileInputStream("test.txt")); String str; while ((str = in.readLine())!=null)&#123; System.out.println(str); &#125; in.close(); 查看DataInputStream源码1234567891011121314publicclass DataInputStream extends FilterInputStream implements DataInput &#123; /** * Creates a DataInputStream that uses the specified * underlying InputStream. * * @param in the specified input stream */ public DataInputStream(InputStream in) &#123; super(in); &#125; ......&#125; 12345678910111213141516171819202122publicclass FilterInputStream extends InputStream &#123; /** * The input stream to be filtered. */ protected volatile InputStream in; /** * Creates a &lt;code&gt;FilterInputStream&lt;/code&gt; * by assigning the argument &lt;code&gt;in&lt;/code&gt; * to the field &lt;code&gt;this.in&lt;/code&gt; so as * to remember it for later use. * * @param in the underlying input stream, or &lt;code&gt;null&lt;/code&gt; if * this instance is to be created without an underlying stream. */ protected FilterInputStream(InputStream in) &#123; this.in = in; &#125; ...&#125; 通过源代码可以看出 装饰器FilterInputStream及其子类（DataInputstream） 被装饰对象InputStream 由此可以设计出很多具有不同的特性的IO流。 装饰器模式的优点 扩展方式了灵活 每个装饰器互相独立不受影响 装饰模式是继承的替代方案，能够解决类膨胀的问题，继承是静态增加功能，装饰模式是动态增加功能。不管装饰多少层，返回的还是父类，实现的是is-a的关系。如果需要去掉某个功能，装饰模式去掉封装就可以了，但是继承就必须修改代码。 动态扩展装饰器类 装饰器模式的缺点 多层装饰比较复杂(类似剥洋葱)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一个故事 小张需要申请一台显示器，需要在公司内部系统提交审核清单。审核清单的审批流程要经过直属领导、部门领导、资源部领导几个环节审批，其中任何一个环节审核不通过，显示器就申请不下来。 责任链模式来模拟审批流程审批流程就像一个链条一样，一级一级审批，直到最后资源部领导核查通过，小张就能拿到想要的显示器了 代码案例123456789101112131415public abstract class VerifyHandler &#123; private VerifyHandler nextVerify; public void setNextVerify(VerifyHandler nextVerify)&#123; this.nextVerify = nextVerify; &#125; public abstract void examine(Request request); public void nextVerify(Request request)&#123; if(nextVerify != null)&#123; this.nextVerify.examine(request); &#125; &#125;&#125; 1234567891011public class TeamLeaderVerifyHandler extends VerifyHandler&#123; @Override public void examine(Request request) &#123; System.out.println(request.getRequest()); System.out.println("直属领导审批通过"); nextVerify(request); &#125;&#125; 12345678public class ApartmentVerifyHandler extends VerifyHandler&#123; @Override public void examine(Request request) &#123; System.out.println("部门领导审批通过"); nextVerify(request); &#125;&#125; 1234567public class ResourceVerifyHandler extends VerifyHandler&#123; @Override public void examine(Request request) &#123; System.out.println("资源部领导审批通过"); System.out.println("发放显示器"); &#125;&#125; 123456789101112131415public class Request &#123; private String request; public String getRequest() &#123; return request; &#125; public void setRequest(String request) &#123; this.request = request; &#125; public Request(String request)&#123; this.request = request; &#125;&#125; 12345678910111213public class Client &#123; public static void main(String[] args) &#123; TeamLeaderVerifyHandler teamLeaderVerifyHandler = new TeamLeaderVerifyHandler(); ApartmentVerifyHandler apartmentVerifyHandler = new ApartmentVerifyHandler(); ResourceVerifyHandler resourceVerifyHandler = new ResourceVerifyHandler(); teamLeaderVerifyHandler.setNextVerify(apartmentVerifyHandler); apartmentVerifyHandler.setNextVerify(resourceVerifyHandler); Request request = new Request("申请一条显示器"); teamLeaderVerifyHandler.examine(request); &#125;&#125; 如何理解责任链模式 使多个对象都有机会处理请求，从未避免了发送者与接收者之间的耦合关系，将这些对象连成一个链条，沿着链条传递请求。其结构和链表是类似的。 当有审批流程进入时，先经过直属领导审批，待直属领导审批通过后，再把审批请求传递给部门领导，部门领导审批过后再传递给资源部领导，由此类推，形成一个链条，链条上的每个对象的职责各不相同。 责任链模式模型抽象类图（TODO） 责任链模式的应用 过滤器 拦截器 责任链模式的优点 请求者与接收者之间解耦 符合开闭原则，易于扩展 责任链模式的缺点 性能问题。链表较长的时候会有性能问题（应该设置节点阈值） 调试逻辑比较复杂（调用者不知道被哪些接受者调用）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是命令模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[关于克隆，我们会想到《西游记》里面孙悟空的猴毛分身，也会想到《火影忍者》里面的影分身之术。他们都是用一个物体复制若干个一模一样的物体。在面向对象的系统中，我们也可以通过克隆来复制一些对象—也就是我们所说的原型模式 用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象，也就是利用一个原型对象来指明我们要创建对象的类型，然后通过复制这个对象来获取一模一样的对象实例 一个简单的原型模式Demo123456789101112public class PrototypeClass implements Cloneable&#123; @Override protected PrototypeClass clone()&#123; PrototypeClass prototypeClass = null; try &#123; prototypeClass = (PrototypeClass)super.clone(); &#125;catch (CloneNotSupportedException e)&#123; &#125; return prototypeClass; &#125;&#125; 实现Cloneable接口，在JVM中只有具有这个标记的对象才有可能被拷贝 重写覆盖Clone()方法 为什么要用原型模式 性能优良。 原型模式是在内存二进制流的拷贝，比直接new一个对象性能要好得多。所以特别是要在一个循环体内产生大量对象的时候，原型模式更好体现其优点 避开构造函数的束缚（既是优点也是缺点）直接在内存中拷贝，构造函数是不会执行的 原型模式应用场景 资源优化场景 性能和安全要求场景 一个对象多个修改者的场景 两种拷贝方式浅拷贝只拷贝本对象，对象内部的数组、引用对象都不拷贝，还是指向原生对象的内部元素地址。原始类型（int、long、char）以及String都会被拷贝 如何才能保证成员变量不被拷贝（保证以下两个条件） 必须是类的成员变量，而不是方法内变量 必须是一个可变的引用对象，而不是一个原始类型或者不可变对象 12345678910111213141516171819202122public class Thing implements Cloneable &#123; private List&lt;String&gt; list = new ArrayList&lt;String&gt;(); @Override protected Thing clone()&#123; Thing thing = null; try &#123; thing = (Thing)super.clone(); &#125;catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return thing; &#125; public void setValue(String value)&#123; this.list.add(value); &#125; public List&lt;String&gt; getValue()&#123; return this.list; &#125;&#125; 浅克隆是不安全的方式，两个对象共享了一个私有变量，大家都能够进行修改。 深拷贝1234567891011121314151617181920212223public class DeepThing implements Cloneable &#123; private ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); @Override protected DeepThing clone()&#123; DeepThing thing = null; try &#123; thing = (DeepThing)super.clone(); this.list = (ArrayList&lt;String&gt;)this.list.clone(); &#125;catch (CloneNotSupportedException e)&#123; e.printStackTrace(); &#125; return thing; &#125; public void setValue(String value)&#123; this.list.add(value); &#125; public List&lt;String&gt; getValue()&#123; return this.list; &#125;&#125; 总结 原型模式向客户隐藏了创建对象的复杂性，客户只需要知道创建对象类型，就可以获得对象一模一样的新对象。 有两种克隆方式：深克隆、浅克隆 浅克隆；不安全，对象公有私有变量 有时对象的复制可能会比较复杂]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式|动态代理原理浅析]]></title>
    <url>%2F2019%2F04%2F05%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[为其他对象提供一个代理以控制对这个对象的访问，在不改变目标对象基础上添加额外的功能。 如何理解代理模式 两个主体：代理对象和被代理对象 对于被代理对象，事情必须要去做吗，但是自己不想去做或是没有条件去做，需要代理对象代替被代理对象去做。 代理对象能够获取被代理对象的资料信息。 代理层面（获得被代理对象的引用） 生活案例 中介：通常买二手车的时候，会去网上找车源，对车进行质量检测，以及各种过户手续的办理，自己可能不想做这些事情，所以可以找第三方的中介公司来完成这些事情，我只负责把我想要的车辆的信息（价位、车辆新旧程度、品牌）反馈给中介，中介把所有的办好就只管我来签字验收就可以了。 黄牛：当春运火车票比较紧张的时候，我抢不到票，且自己也不想去抢，则可以通过黄牛去买，我只管把我的车票信息给他（初始地、目的地、出发时间、车次），由此不用抢票，也可以买到相应的车票，抢票的过程由黄牛去做。 媒人：平时自己没有时间去交女朋友，则需要媒人去介绍，我们只管把我们想要的女朋友的类型给媒人，媒人则帮我们去寻找合适的对象。 需要类图 Subject(抽象主题) 可以是抽象类也可以是接口 RealSubject(具体角色) 被代理的对象，业务逻辑的执行者 Proxy(代理角色) 代理类，负责对真实角色的应用，把所有抽象主题定义的方法限制委托给真实角色实现，并在真实角色处理完毕前后做相应工作 几种代理实现形式代理有两种主要形式 静态代理 编译前，代码已经创建好，程序运行时，class文件已经存在 动态代理 程序运行时通过反射生成代理类 静态代理 代理类与目标类实现相同的接口 代理类持有目标类的引用，可以控制目标类方法的访问 普通代理1234public interface Subject &#123; void request();&#125; 123456public class RealSubject implements Subject &#123; @Override public void request() &#123; System.out.println("start to request"); &#125;&#125; 12345678910111213141516171819202122public class Proxy implements Subject&#123; private Subject subject; public Proxy(Subject subject)&#123; this.subject = subject; &#125; @Override public void request() &#123; this.before(); subject.request(); this.after(); &#125; private void before()&#123; System.out.println("前置处理。。。。"); &#125; private void after()&#123; System.out.println("后置处理。。。。"); &#125;&#125; 强制代理 只能通过真实角色角色制定的代理类才能访问 不允许直接访问真实角色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public interface Subject &#123; void request(); Subject getProxy();&#125;```javapublic class SubjectProxy implements Subject&#123; private Subject subject; public SubjectProxy(Subject subject) &#123; this.subject = subject; &#125; @Override public void request() &#123; this.subject.request(); &#125; @Override public Subject getProxy() &#123; return this; &#125;&#125;```javapublic class RealSubject implements Subject&#123; private Subject proxy = null; @Override public void request() &#123; if(this.isProxy())&#123; System.out.println("start to request"); &#125;else &#123; System.out.println("请使用指定的代理进行访问"); &#125; &#125; @Override public Subject getProxy() &#123; this.proxy = new SubjectProxy(this); return this.proxy; &#125; private boolean isProxy()&#123; if(this.proxy == null)&#123; return false; &#125;else &#123; return true; &#125; &#125;&#125; 1234567public class Client &#123; public static void main(String[] args) &#123; RealSubject subject = new RealSubject(); Subject proxy = subject.getProxy(); proxy.request(); &#125;&#125; 静态代理局限性 不够灵活，每个代理只为一个接口服务，会造成大量代码重复 静态代理类职位特定的接口服务，如果有多个接口，需要生成多个代理对象，不利于系统维护 动态代理123public interface CustomerService &#123; void buyCar();&#125; 123456public class CustomerServiceImpl implements CustomerService&#123; @Override public void buyCar() &#123; System.out.println("决定买这个车了"); &#125;&#125; 123456789101112131415161718public class CarAgency implements InvocationHandler&#123; //被代理对象的引用 private Object target; public Object getInstance(Object target)&#123; this.target = target; Class clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(),target.getClass().getInterfaces(),this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("办理车辆质量检查报告"); method.invoke(target,args); System.out.println("办理车辆二手车过户"); return null; &#125;&#125; 动态代理源码解析 代理模式的意义（如何案例理解） 三种代理方式 动态代理实现原理 动态代理的实际运用（RPC、Spring等 RMI 收集相关的应用）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2F2019%2F04%2F05%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[中介者模式如何理解中介者模式复杂的进销存系统类图 类图 虽然不同类型的参与者完成各自的活动，但是每个类相互关联耦合 每个类与多个朋友类相互交互，朋友类越多，耦合性越大，要修改一个，就得修改一大片— 违反迪米特法则 不同参与者之间交互过于复杂，维护比较困难 使用一个中介者对象，他将各个对象之间的交互封装起来作为一个中间桥梁，降低各个参与者的耦合性。 中介者类图 每个参与者只负责自己的业务逻辑，不属于自己的交给中介者去处理 每个参与者不再交互交流，简化了各模块间的耦合性 抽象中介者类 定义统一的接口，用于各个参与者角色之间的通信1234567891011121314151617public abstract class Mediator &#123; protected ConcreteColleagueA concreteColleagueA; protected ConcreteColleagueB concreteColleagueB; public Mediator()&#123; concreteColleagueA = new ConcreteColleagueA(this); concreteColleagueB = new ConcreteColleagueB(this); &#125; public abstract void doSomethingA(); public abstract void doSomethingB();&#125;Q:为什么使用参与类实现类注入，而不使用抽象类注入(接口注入)A:因为每个参与类没有必须要完成的业务方法(没有相同的方法), 假如有相同的方法，当然要注入抽象类做到依赖倒置。 抽象参与者类 每一个参与者必须知道中介者角色，所以通过构造函数传入1234567public abstract class Colleague &#123; protected Mediator mediator; public Colleague(Mediator mediator)&#123; this.mediator = mediator; &#125;&#125; 具体中介者类 协调各个参与者实现协作工作行为，要依赖各个参与者 1234567891011121314public class ConcreteMediator extends Mediator&#123; @Override public void doSomethingA() &#123; super.concreteColleagueA.selfMethod(); super.concreteColleagueB.selfMethod(); &#125; @Override public void doSomethingB() &#123; super.concreteColleagueA.selfMethod(); super.concreteColleagueB.selfMethod(); &#125;&#125; 具体参与者类A 自身的行为selfMethod,用于处理自身的业务逻辑 依赖的行为depMethod,依靠中介者去完成1234567891011121314public class ConcreteColleagueA extends Colleague&#123; public ConcreteColleagueA(Mediator mediator)&#123; super(mediator); &#125; public void selfMethod()&#123; //自己的业务逻辑 &#125; public void depMethod()&#123; //不能处理的业务逻辑，交给中介者处理 super.mediator.doSomethingA(); &#125;&#125; 具体参与者类B 12345678910111213public class ConcreteColleagueB extends Colleague&#123; public ConcreteColleagueB(Mediator mediator) &#123; super(mediator); &#125; public void selfMethod()&#123; //自己能够处理的业务逻辑 &#125; public void depMethod()&#123; super.mediator.doSomethingB(); &#125;&#125; 客户端 12345678910111213public class ConcreteColleagueB extends Colleague&#123; public ConcreteColleagueB(Mediator mediator) &#123; super(mediator); &#125; public void selfMethod()&#123; //自己能够处理的业务逻辑 &#125; public void depMethod()&#123; super.mediator.doSomethingB(); &#125;&#125; 用一个中介对象封装一系列的对象交互，中介者使对象不需要显示的相互作用，从而使其耦合松散,并且可以独立的改变他们之间的交互 中介者模式有什么优势 系统更加灵活，各个参与者相互独立 减少类间的依赖，参与类只依赖中介者，减少了依赖，降低了类间的耦合中介者模式存在的问题 中介者承担了太多的职责，一旦出现问题，整个系统都会受影响 中介者会变得非常复杂，原本参与者间的关系转换成了中介者与参与者的关系，参与者越多，中介者就越复杂 中介者模式要慎用 量力而行。 中介者模式会使中介者逻辑复杂化。使用不当会把问题变得复杂，如果本身就只有简单的几个依赖关系，就没必要用终结者模式。所以要根据情况权衡中介者模式的使用 中介者适合多个对象紧密耦合的情况–蜘蛛网结构，中介者模式能将蜘蛛网结构梳理成星型结构 留下的问题Q:不符合依赖倒置原则，很少使用接口或者抽象类 参与者之间是协作关系，处理不同的任务，不能严格定义参与者需要具有的方法，不能抽象出一个统一的父类 每个中介者所围绕的参与类各不相同，不能抽象出一个具有共性的中介者 两个对象不能提炼出共性，就不要追求两者的抽象]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[建造者模式 将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示 如何理解建造者模式建造者模式就是将建造复杂对象的过程和组成对象的部件进行解耦。 案例游戏公司设计游戏角色，其中人、兽、精灵三个种族。而每个种族又拥有不同的英雄角色。所以角色设计应该具备以下特点: 角色基本属性一致 角色创建过程复杂，不暴露创建细节 符合开闭原则，可以随时新增角色 各个角色间彼此不受影响 这些特点很符合工厂模式的适用特点，那用工厂模式就可以实现的案例为何要用建造者模式？ 主要是一个角色包含有头、手、脚、毛发…等许多部件，不同种族不同角色的部件有许多差异。如果使用工厂模式，那么角色的创建过程会与其各个部件耦合在一起，如果部件比较多，那么角色的创建是比较复杂的。比如所以我们需要将对象的创建过程与组成对象的部件进行解耦，也就是这一章的主题—建造者模式 类图（todo） 产品类 定义产品的基本属性 抽象建造者 定义产品各个部件的构建规范 具体构建者 实现抽象构建者的所有方法，返回一个具体的产品 导演类 负责封装已有模块的顺序 隔离客户与生产过程 控制产品的生成过程 优势 良好的封装性。产品类和建造类相对固定，将主要逻辑封装到导演类可以取得比较好的稳定性。 不需暴露产品内部细节，将产品本身与产品创建过程进行解耦。 精细控制产品创建过程。创建过程清晰，能够把控产品每个部件的创建过程。 良好的扩展性。新的需求只需要增加新的建造类就可以解决，符合开闭原则。 局限性 建造者不适合差异性很大的产品类。 产品内部变化复杂，需要定义很多建造类来实现，会导致系统变得庞大。 使用场景 相同的方法，不同的执行顺序，产生不同的事件结果 一个对象具有多个部件，但是不同的对象的部件有所差异，也可以使用建造者模式 需要隔离复杂对象的创建和使用，并使相同创建过程可以创建不同的产品 建造者模式与工厂模式的区别工厂模式职责—创建对象 将创建过程封装到工厂类，有工厂类提供最终产品。 建造模式职责—零件的装配以产生不同的对象 负责创建复杂对象，需要对对象的部件进行装配以产生不同效果的对象，具有的建造过程交给指挥类。由指挥类负责将各个组件按照规则组建为产品。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板模式]]></title>
    <url>%2F2019%2F03%2F25%2F%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法模式 定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤 如何理解模板模式在我们的认识中，模板就是一些约定俗成的东西，是一些自然而然的事物规律。当我们想要解决一些具有模板规律的事情的时候，手中的模板就是一个个整齐待发的磨具，能够轻松进行重复制造、生产。由此想了想，生活中哪些事情满足模板模式的规律： 制茶，制茶是一个很有讲究的学问。制造茶的流程总是相对固定的。采青-&gt; 萎凋-&gt;发酵-&gt; 杀青 -&gt; 揉捻 -&gt; 干燥 -&gt; 初制茶。每个工坊的制作工艺有所差别，有些工坊的手工揉捻做的比较好，有些工坊的萎凋做的比较有特点，所以生产出来的茶叶有所区别。但是他们的总体流程是相对差不多的，都遵循相同的制作模板。 造车，车的总体功能差不多， 能够启动、停止，能够鸣笛、跑路。但是不同型号的车是有所差异的。有些车是手动挡，有些是自动挡。 我们可以根据这类食物的规律总结一下特点： 具有一个抽象的模板，这个模板决定了这类事物的总体流程规律（父类抽象模板） 不同的事物虽然具有共同的抽象模板，但是彼此有着个性化的差异（个性化子类） 子类的个性化特点能够重新定义整个事物的最终呈现结构，就好比不同的茶叶工坊的制作工艺的差别会导致这个茶叶具有不同销量和名声。不同型号的车会导致车具有不同的价格和市场。 程序是现实世界的抽象，模板模式的类可以总结如下： 抽象模板 基本方法 子类的个性化方法，由子类去实现，如制茶过程中每一个环节（发酵…） 模板方法 对基本方法的调度，已完成固定的逻辑。如制茶这样的模板方法就是将制茶每个环节的调度，完成造茶这么一个逻辑。 注意： 基本方法尽量设计成protected类型，符合迪米特法则，若非必要，尽量不要扩大父类的访问权限。 模板方法一般设计成final类型，不要被覆写 为什么要用模板模式 封装不变部分，扩展可变部分 不变的流程规律由父类来实现，而可变的每个环节由子类来控制。 提取公共部分代码，便于维护 行为由父类控制、子类实现 基本方法由子类实现，子类可以通过扩展类来增加相应功能，符合开闭原则。 模板模式实现 模板模式也有缺陷 四思维方式与以往有所不同，不好理解。 常规思路: 抽象类-&gt;最抽象、最一般的事物属性和方法 具体类-&gt;具体的事物属性和方法 模板模式思路： 抽象类-&gt;定义部分抽象方法 实现类-&gt;子类的执行结果对父类结构产生影响 总结一下 模板模式的扩展–钩子函数的应用由子类的一个方法返回值来决定公共部分的执行结果 引申 父类怎么调用子类的方法 子类传递到父类的有参构造中 反射 父类调用子类的静态方法 其实模板模式就间接的实现了父类依赖子类的场景 父类建立框架-&gt;子类重写父类 -&gt; 调用父类继承方法-&gt; 影响父类结果]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式|如何优雅的new对象]]></title>
    <url>%2F2019%2F03%2F24%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[写在前面在面向对象编程（OOP）中，通过new去实例化一个对象是再正常不过的事情。但是每当new一个对象，后面都会跟一个具体类，这使得代码与具体类过度耦合，让我们陷入面向实现编程的漩涡里面。每当有新的需求变更，我们代码的扩展性就比较差。 手动new对象有哪些问题 与具体类耦合，每当有新的变化，就必须改变代码（不符合对修改关闭） 无法借助接口、多态的力量去隔离变化（与面向接口编程相违背） 如何才能优雅的new对象 对扩展开放，应对后期的各种需求 对修改关闭，对于新的需求，不改变原有的代码 不关心构造对象的细节和复杂过程，轻松获取对象实例 可以通过工厂模式来构造我们想要的对象。 工厂模式是一种常用的创建型设计模式，在基类中定义了创建对象的接口，让子类来决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。 工厂模式包括我们所熟知的简单工厂模式、工厂方法模式、抽象工厂工厂模式。其中简单工厂模式在一定程度上只算是一种编程思想，还谈不上设计模式。但它作为工厂方法模式和抽象工厂模式的基石，还是有必要深入了解一下。 造车案例来了解一下不同的工厂模式 客户想要一辆奔驰车，客户需要奔驰车的设计图纸相应的汽车零件来自己制造。当客户想要悍马车，手上的设计图纸和汽车零件已经毫无用处，需要获取悍马车的设计图纸以及汽车零件（不符合对修改关闭） 客户不需要自己生产汽车，由工厂来提供服务，客户需要什么车，工厂就生产什么车。但是每当客户有新的需求的时候，工厂就得想尽办法去找相关的图纸和零件来交付生产。—简单工厂模式（不符合对修改关闭） 客户的需求太多，一个工厂完全应付不过来，所以工厂就开始建立新的场地，有些场地只生产宝马车，有些场地只生产悍马车，这样客户想要什么样的车就找对应的车工厂去提货。— 工厂方法模式 客户的需求逐渐升级，不同型号的车具有不同配置，所以每一个具体工厂应该具备生产不同型号车辆的能力，奥迪的工厂不仅能生产A4，也能生产A6、A8。所以一个工厂应该具备生产不同型号车辆的生产车间—抽象工厂模式 几种工厂模式的实现简单工厂 定义一个工厂类，根据传入的参数不同返回不同的实例。 123public interface Shape &#123; void draw();&#125; 123456public class RectShape implements Shape &#123; @Override public void draw() &#123; System.out.println("draw rectangle"); &#125;&#125; 123456public class CircleShape implements Shape &#123; @Override public void draw() &#123; System.out.println("draw circle"); &#125;&#125; 12345678910111213141516171819public class ShapeFactory &#123; public static Shape getShape(String type)&#123; Shape shape = null; if("circle".equalsIgnoreCase(type))&#123; shape = new CircleShape(); &#125;else if("rectangle".equalsIgnoreCase(type))&#123; shape = new RectShape(); &#125; return shape; &#125; public static void main(String[] args) &#123; Shape circle = ShapeFactory.getShape("circle"); circle.draw(); Shape rectangle = ShapeFactory.getShape("rectangle"); rectangle.draw(); &#125;&#125; 应用场景： 只有一个工厂类，对于创建对象不多的案例比较适合 工厂类封装了对象的创建过程，客户端不需要关心对象的创建过程。 工厂方法 简单工厂的深入化， 通过创建不同的对象工厂来取代统一的工厂。让子类来决定哪一个类实例化，让一个类的实例化延迟到子类。 案例：有一个图片加载器，可以加载jpg、png、gif等图片格式， 123456/** * 图片加载器接口 */public interface Reader &#123; void read();&#125; 12345678910/** * * gif 图片加载器 */public class GifReader implements Reader&#123; @Override public void read() &#123; System.out.println("gif picture reader"); &#125;&#125; 12345678910/** * * png 图片加载器 */public class PngReader implements Reader&#123; @Override public void read() &#123; System.out.println("png picture reader"); &#125;&#125; 12345678910/** * * jpg 图片加载器 */public class JpgReader implements Reader&#123; @Override public void read() &#123; System.out.println("jpg picture reader"); &#125;&#125; 123456789/** * gif 图片加载器工厂 */public class GifReaderFactory implements ReaderFactory&#123; @Override public Reader getReader() &#123; return new GifReader(); &#125;&#125; 123456789/** * jpg 图片加载器工厂 */public class JpgReaderFactory implements ReaderFactory&#123; @Override public Reader getReader() &#123; return new JpgReader(); &#125;&#125; 123456789/** * png 图片加载器工厂 */public class PngReaderFactory implements ReaderFactory &#123; @Override public Reader getReader() &#123; return new PngReader(); &#125;&#125; 12345678910111213141516171819/** * 客户端 */public class Client &#123; public static void main(String[] args) &#123; GifReaderFactory gifReaderFactory = new GifReaderFactory(); Reader gifReader = gifReaderFactory.getReader(); gifReader.read(); PngReaderFactory pngReaderFactory = new PngReaderFactory(); Reader pngReader = pngReaderFactory.getReader(); pngReader.read(); JpgReaderFactory jpgReaderFactory = new JpgReaderFactory(); Reader jpgReader = jpgReaderFactory.getReader(); jpgReader.read(); &#125;&#125; 工厂方法模式优点 良好的封装性。调用者需要创建一个产品对象，只需要知道产品工厂的类名就可以了，不要了解对象创建过程，降低模块间的耦合。 良好的扩展性。当有新增产品类的需求变化，只要适当扩展一个工厂类就可以完成拥抱变化 屏蔽产品类。产品类如何变化，调用者不需要关心—切换数据源（数据库从MySQL切换到Oracle,需要改动的只是切换一下驱动名称） 典型的解耦框架。 高层模块需要知道产品抽象类，不关心实现类—迪米特法则 只依赖产品类的抽象 — 依赖倒置原则 产品子类替换产品父类 — 里氏替换原则 应用场景 所以生成对象的地方都可以使用工厂方法模式，但是要权衡增加工厂类进行管理带来的代码复杂度 需要灵活、可扩展的框架是，可以采用工厂方法模式 客户端不需要知道它所创建对象的类，只需要知道创建的工厂名就可以完成创建过程 抽象工厂 为创建一组相关或相互依赖的对象提供一个借口，而无需指定他们的具体类。 案例：设计一个兼容Android、ios、Wp三个操作系统的游戏，每个系统都有一套操作控制和界面控制器 123456/** * 界面控制器 */public interface UIController &#123; void display();&#125; 123456/** * 操作控制器 */public interface OperationController &#123; void control();&#125; 123456789/** * wp ui controller */public class WpUIController implements UIController &#123; @Override public void display() &#123; System.out.println("wp ui controller"); &#125;&#125; 123456789/** * ios 界面控制器 */public class IosUIController implements UIController &#123; @Override public void display() &#123; System.out.println("ios ui controller"); &#125;&#125; 123456789/** * 安卓界面控制器 */public class AndroidUIController implements UIController&#123; @Override public void display() &#123; System.out.println("android ui controller"); &#125;&#125; 123456789/** * wp 操作控制器 */public class WpOperationController implements OperationController &#123; @Override public void control() &#123; System.out.println("wp operation controller"); &#125;&#125; 123456789/** * ios 操作控制器 */public class IosOperationController implements OperationController &#123; @Override public void control() &#123; System.out.println("ios operation controller"); &#125;&#125; 123456789/** * 安卓操作控制器 */public class AndroidOperationController implements OperationController&#123; @Override public void control() &#123; System.out.println("android opration controller"); &#125;&#125; 1234public interface SystemFactory &#123; OperationController createOperationController(); UIController createUIController();&#125; 1234567891011121314/** * ios 工厂 */public class IosFactory implements SystemFactory &#123; @Override public OperationController createOperationController() &#123; return new IosOperationController(); &#125; @Override public UIController createUIController() &#123; return new IosUIController(); &#125;&#125; 1234567891011121314/** * wp 工厂 */public class WpFactory implements SystemFactory&#123; @Override public OperationController createOperationController() &#123; return new WpOperationController(); &#125; @Override public UIController createUIController() &#123; return new WpUIController(); &#125;&#125; 1234567891011121314/** * 安卓工厂 */public class AndroidFactory implements SystemFactory &#123; @Override public OperationController createOperationController() &#123; return new AndroidOperationController(); &#125; @Override public UIController createUIController() &#123; return new AndroidUIController(); &#125;&#125; 123456789101112131415161718192021222324public class Client &#123; public static void main(String[] args) &#123; AndroidFactory androidFactory = new AndroidFactory(); OperationController androidOperation = androidFactory.createOperationController(); androidOperation.control(); UIController androidUI = androidFactory.createUIController(); androidUI.display(); IosFactory iosFactory = new IosFactory(); OperationController iosOperation = iosFactory.createOperationController(); iosOperation.control(); UIController iosUI = iosFactory.createUIController(); iosUI.display(); WpFactory wpFactory = new WpFactory(); OperationController wpOperation = wpFactory.createOperationController(); wpOperation.control(); UIController wpUI = wpFactory.createUIController(); wpUI.display(); &#125;&#125; 优点 封装性。高层模块不需要关心产品实现类 缺点 产品族扩展困难,当要新增一个控制器，所有的实现类都要改变—违反开闭原则，改变了契约，所有与契约有关系的代码都要改变 应用场景 不关心对象创建过程 需要一组对象功能完成某种功能 系统结构稳定，不会频繁的增加产品族功能，增加产品族功能就回修改原有代码，不符合开闭原则。 注意产品族扩展困难(增加控制器)，但是产品扩展容易(增加小米系统的支持)，也就是纵向扩展困难，横向扩展容易，从产品横向扩展来说，抽象工厂模式是符合开闭原则的 参考文档 https://juejin.im/entry/58f5e080b123db2fa2b3c4c6]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于单例模式的几种变体形式]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式是一种简单的的设计模式。虽然简单，但是应用却是十分的广泛。所有有必要针对单例模式的知识点进行梳理。 单例模式 确保类只有一个实例，并自动实例化向整个系统提供全局的访问点。从定义上可以推断出单例模式更倾向于节约资源，利于资源的重用从而节约时间。所以应用单例模式的对象应该具有以下特点： 频繁地创建、销毁且性能无法优化 消耗大量资源（读取配置、产生依赖对象），可以在应用启动时直接产生一个单例对象 避免资源的多重占用 设置全局的访问点，优化和共享资源访问 应用场景单例模式设计的几点考虑 延迟加载 线程安全 并发性能 序列化/反序列化安全 name 延迟加载 线程安全 并发性能 序列化/反序列化安全 饿汉式 N Y Y N 懒汉式(不加锁) Y N Y N 懒汉式(加锁) Y Y N N DCL Y Y Y N 静态内部类 Y Y Y N 枚举 N Y Y Y 单例模式实现 饿汉式 类加载时完成初始化 类加载慢 获取对象速度快 123456789public class Singleton &#123; private static Singleton singleton = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return singleton; &#125;&#125; 懒汉式 获取对象的时候完成初始化，实现懒加载。但是线程不安全，高并发下会出现多个实例。123456789101112public class Singleton &#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if( instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉式（加锁） 线程安全的懒汉式单例模式。 1234567891011121314public class SafeSingleton &#123; private static SafeSingleton instance = null; private SafeSingleton()&#123;&#125; public static synchronized SafeSingleton getInstance()&#123; if(instance == null)&#123; instance = new SafeSingleton(); &#125; return instance; &#125;&#125; 双重检查DCL synchronized同步代码块保证只创建一个对象。 条件判断使对象创建过后，不在进入同步块，减少锁的粒度。 volatitle防止指令重排序(否则出现一个线程创建一般的对象呗另一个线程访问，造成空指针)。 12345678910111213141516public class Singleton &#123; private volatile static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized (Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类 利用ClassLoader的机制保证了线程安全 相比饿汉式单例模式，实现懒加载，只有显示调用SingleHolder才会触发初始化。 1234567891011121314public class Singleton &#123; private static class SingletonHolder&#123; private static final Singleton instance = new Singleton(); &#125; private Singleton()&#123;&#125; public static final Singleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 枚举 线程安全（虚拟机加载枚举的时候，会使用ClassLoader的loadClass方法，这个方法使用同步代码块保证线程安全） 解决反序列化破坏单例的问题: 普通序列化过程中，通过反射调用默认构造函数来初始化对象，反序列化的对象是新建的 枚举的反序列化不是通过构造函数实现，因此不会发生于由于反序列化导致的单例破坏问题 1234567public enum Singleton &#123; INSTANCE; public void getInstance()&#123; &#125;&#125; 如何设计优秀的单例模式引申 双重校验DCL为什么使用volatile synchronized与volatile的区别]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单一职责原则]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[单一职责原则应该有且只有一个原因引起累的变更。 一个例子去理解单一职责原则12345678public interface IPhone &#123; //接通 public void dial(String phoneNumber); //聊天 public void chat(Object o); //挂断 public void hangup();&#125; 定义了一个Iphone的接口，包含了电话的三个功能，接通、聊天、挂断。 试想一下这个接口符合单一职责原则吗？（一个类或者接口只有一个原因引起变化） 很明显，IPhone包括了两个职责,应该设计成两个接口。 信号的接通与果断 通话（数据传输） 12345public interface IConnectionManager &#123; void dial(String phoneNumber); void hangup();&#125; 123public interface IDataTransfer &#123; void transfer();&#125; 单一职责原则的好处 降低类的复杂度，职责清晰、明确 复杂度降低，可读性提高 可维护性提高 变更的风险降低 职责没有量化的标准类的单一职责原则受非常多的网因素制约，从理论上是非常优秀，但从实际的角度上来讲，单一职责原却难以落地。类职责的划分没有量化的标准，因为职责和变化原因都是不可度量的，因项目而异，因环境而异。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迪米特法则|如何降低类间耦合]]></title>
    <url>%2F2019%2F03%2F22%2F%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%2F</url>
    <content type="text"><![CDATA[软件开发一直在推崇一个概念-低耦合、高内聚。 那什么样的代码设计才算得上低耦合、高内聚的代码。本文通过迪米特法则来讲解一下如何进行低耦合的代码设计。 迪米特法则也叫最小知识原则（Least Knowledge Principle）,即一个类应该对自己需要耦合和调用的类保持最少的认识。也就是一个类对自己依赖的类知道的越少越好。因而迪米特法则应该遵循一下的要义 被依赖者，只应该暴露应该暴露的方法 依赖者，只依赖应该依赖的对象 一个案例David Bock根据迪米特法则给出了一个超市购物的案例。三个关键信息：消费者、钱包、收银员定义了三个类，分别是Customer、Wallet、PaperBoy1234567891011121314public class Customer &#123; private String firstName; private String lastName; private Wallet myWallet; public String getFirstName()&#123; return firstName; &#125; public String getLastName()&#123; return lastName; &#125; public Wallet getWallet()&#123; return myWallet; &#125;&#125; 123456789101112131415public class Wallet &#123; private float value; public float getTotalMoney() &#123; return value; &#125; public void setTotalMoney(float newValue) &#123; value = newValue; &#125; public void addMoney(float deposit) &#123; value += deposit; &#125; public void subtractMoney(float debit) &#123; value -= debit; &#125;&#125; 12345678910public class Paperboy &#123; public void charge(Customer myCustomer, double payment) &#123; Wallet theWallet = myCustomer.getWallet(); if (theWallet.getTotalMoney() &gt; payment) &#123; theWallet.subtractMoney(payment); &#125; else &#123; //money not enough &#125; &#125;&#125; 从这三个类可以看出， PaperBoy承担了大多数的功能实现。PaperBoy从消费者那里拿到了钱包，核点钱包的的金钱并自己从中拿去购物的费用。paperBoy既与Customer发生直接交互，又与Wallet发生间接交互，不符合最小知识原则（迪米特法则）。案例主要存在以下问题 Wallet暴露太多方法，其实Customer只要能够用钱包进行付钱就行了。所以这违反了迪米特法则的第一条（被依赖者，只暴露应该暴露的方法） 让PaperBoy与Wallet直接交互是错误的行为，Wallet是Customer的私有财物，ParperBoy是无权过问Wallet的情况的， 所以从职责的角度上来看，这是不符合逻辑，违反了迪米特法则的第二条（依赖者，只依赖应该依赖的对象） 如何进行修改 PaperBoy不再与钱包发生直接关系，直接向customer要钱 钱包只暴露付钱的方法给Customer。 方法暴露越多，后期需求变更的影响越大。 1234567891011public class PaperBoy &#123; private Customer customer; public PaperBoy(Customer customer)&#123; this.customer = customer; &#125; public void charge(float payment)&#123; customer.pay(payment); &#125;&#125; 12345678910111213141516171819202122public class Customer &#123; private String firstName; private String lastName; private Wallet myWallet; public Customer(String firstName, String lastName, Wallet myWallet) &#123; this.firstName = firstName; this.lastName = lastName; this.myWallet = myWallet; &#125; public String getFirstName()&#123; return firstName; &#125; public String getLastName()&#123; return lastName; &#125; public void pay(float payment)&#123; myWallet.pay(payment); &#125;&#125; 1234567891011121314151617181920212223public class Wallet &#123; private float value; private float getTotalMoney() &#123; return value; &#125; public void setTotalMoney(float newValue) &#123; value = newValue; &#125; private void addMoney(float deposit) &#123; value += deposit; &#125; private void subtractMoney(float debit) &#123; value -= debit; &#125; public void pay(float payment)&#123; if(getTotalMoney()&gt;payment)&#123; subtractMoney(payment); &#125;else &#123; &#125; &#125;&#125; 迪米特法则核心观念— 类间解耦、弱耦合]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[里氏替换原则]]></title>
    <url>%2F2019%2F03%2F22%2F%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[里氏替换原则继承作为面向对象设计的重要手段，具有以下的特点 优点 代码共享，减少重复工作 提高代码复用性 子类形似于父类而区别于父类 提高代码扩展性 缺点 代码侵入性，继承必须拥有父类的所有方法 降低代码灵活性，子类必须拥有父类的属性和方法 增强了耦合性，当父类被改变时，需要考虑到子类的修改 什么叫里氏替换原则 所有引用基类的地方必须能够透明的使用其子类的对象（） 由此里氏替换原则是为继承定义的一个规范 子类必完全实现父类的方法 子类可以有自己独特的个性 覆盖或者实现父类的方法时，输入参数可以被放大 覆盖或实现父类方法时，输出结果可以被缩小]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口隔离原则|]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[什么是接口隔离原则 客户端不应该依赖它不需要的接口 类间的依赖关系应该建立在最小的接口上 总的来说，就是建立单一的接口，不要建立臃肿庞大的接口，接口尽量细化，接口的方法尽量少]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开闭原则|]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
</search>
